<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://markyang920413.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://markyang920413.github.io//" rel="alternate" type="text/html" /><updated>2021-03-07T20:16:13+09:00</updated><id>https://markyang920413.github.io//feed.xml</id><title type="html">혼자 보려고 만든 블로그</title><subtitle>It is just my note</subtitle><author><name>Dong-Heyon Yang</name><email>markyang920413@gmail.com</email></author><entry><title type="html">디스크 관리 명령어: df, du, fsck, e2fsck, badblocks, dump2efs</title><link href="https://markyang920413.github.io//linux-system/linux-linux_system-disk_manage/" rel="alternate" type="text/html" title="디스크 관리 명령어: df, du, fsck, e2fsck, badblocks, dump2efs" /><published>2021-03-07T00:00:00+09:00</published><updated>2021-03-07T00:00:00+09:00</updated><id>https://markyang920413.github.io//linux-system/linux-linux_system-disk_manage</id><content type="html" xml:base="https://markyang920413.github.io//linux-system/linux-linux_system-disk_manage/">## 디스크 사용량 관리
### df - 파일 시스템별 사용량 확인
---
- **df**: ***disk free***의 약자로 현재 시스템에서 `사용 중`인 파일 시스템의 `사용량`에 대한 정보 출력
	- 전체 용량, 사용 가능한 용량, 마운트 정보 등도 함께 출력
  
```c
$ df [옵션] [파일 시스템]

option:
	-a			모든 파일 시스템을 대상으로 디스크 사용량을 확인한다.
	-k			디스크 사용량을 KB 단위로 출력한다.
	-m			디스크 사용량을 MB 단위로 출력한다.
	-h			디스크 사용량을 알기 쉬운 단위(GB, MB, KB 등)로 출력한다.
	-t &lt;파일 시스템의 종류&gt;	지정한 파일 시스템의 종류에 해당하는 디스크 사용량을 출력한다.
	-T			파일 시스템의 종류도 출력한다.

사용 예:
	df -h
```
- df 명령으로 출력되는 항목은 다음과 같다.
	- 파일 시스템 장치명
	- 파일 시스템의 전체 용량
	- 파일 시스템의 사용량
	- 사용량을 퍼센트로 표시
	- 파일 시스템의 사용 가능한 남은 용량
	- 마운트 포인트
&lt;br&gt;   
&lt;br&gt;   
- `-t ext4`: ext4 파일 시스템에 대해서만 정보 출력

- `-T` : 파일 시스템의 종류 정보 출력
  
&lt;img src=&quot;img1.jpg&quot;&gt;  

### du - 디렉터리, 사용자별 디스크 사용량 확인
- **disk usage**: 특정 `디렉터리별`로 `디스크의 사용량`을 알려준다.
  
```c
$ du [옵션] [디렉터리]

option:
	-s		특정 디렉터리의 전체 사용량을 출력한다.
	-h		디스크 사용량을 알기 쉬운 단위(GB, MB, KB 등)로 출력한다.

사용 예:
	du -sh .
	du -sh ~/blog
```

## 파일 시스템 검사 복구
### fsck - 파일 시스템 검사 및 복구
---
- **fsck**: 'file system check'의 약자로, inode 및 블록, 디렉터리, 파일 링크 등을 검사하고 필요시 복구 작업도 수행
  
```c
$ fsck [옵션] 장치명

option:
	-f			강제로 점검한다.
	-b &lt;수퍼 블록&gt;		지정한 백업 수퍼 블록을 사용한다.
	-y			모든 질문에 yes로 대답하게 한다.
	-a			파일 시스템 검사에서 문제가 발생했을 때 자동으로 복구한다.

사용 예:
	fsck /dev/sdb1
	fsck -f /dev/sdb1
```
- fsck 명령은 기본적으로 /etc/fstab에 지정된 파일 시스템을 대상으로 한다.&lt;br&gt;물론 다른 파일 시스템에 대한 검사도 수행할 수 있다.
- 각 파일 시스템 종류별로 ***fsck.ext2, fsck.ext3, fsck.ext4*** 명령도 제공한다.
  
```c
$ sudo fsck /dev/sdd1
fsck from util-linux 2.20.1
e2fsck 1.42.8 (20-Jun-2013)
/dev/sdd1: clean, 11/76912 files, 11777/307200 blocks
$
```

- 파일 시스템 `종류 지정`해 검사
  
```c
$ sudo fsck.ext4 /dev/sdd1
e2fsck 1.42.8 (20-Jun-2013)
/dev/sdd1: clean, 11/76912 files, 11777/307200 blocks
$
```

### e2fsck - fsck 기능
---
- fsck 처럼 inode 및 블록, 디렉터리, 파일 링크 등을 검사하고 필요시 복구 작업도 수행한다.
	- &lt;span style=&quot;color:red&quot;&gt;**\&lt;주의!\&gt;**&lt;/span&gt; e2fsck 명령으로 파일 시스템을 점검할 때는 해당 파일 시스템의 마운트를 해제하고 해야한다!!
  
```c
$ sudo e2fsck /dev/sdd1
$ sudo e2fsck -f /dev/sdd1
```

### badblocks - 배드 블록 검사하기
---
- 배드 블록으로 인한 데이터 유실 피해 방지하는 것 중요!
	- fsck, e2fsck 명령으로 배드 블록 검사가 가능하나 배드 블록을 검사하는 별도의 badblocks 명령도 있다.

- **badblocks**: **배드 블록을 검색**한다.
  
```c
$ badblocks [옵션] 장치명

options:
	-v				검색 결과를 자세하게 출력한다.
	-o 출력파일			검색한 배드 블록 목록을 지정한 출력 파일에 저장한다.

사용 예:
	badblocks -v /dev/sdb1
	badblocks -v -o bad.out /dev/sdb1
```

## 백업 수퍼블록을 이용해 파일 시스템 복구하기
- 파일 시스템의 기본 [수퍼블록](https://markyang920413.github.io/linux-filesystem/linux-linux_filesystem-filesystem_architecture/#%EB%A6%AC%EB%88%85%EC%8A%A4-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B5%AC%EC%A1%B0)에 문제가 있으면 해당 파일 시스템을 사용할 수 없다.
	- 이럴 경우를 대비해 `백업 수퍼 블록`이 있다.
	- 이 &lt;span style=&quot;color:steelblue&quot;&gt;백업 수퍼 블록&lt;/span&gt;을 사용하여 **파일 시스템 복구** 가능하다.

### dumpe2fs - 파일 시스템 정보 출력
---
- dumpe2fs: **파일 시스템** `정보 출력`
 
```c
$ dumpe2fs &lt;장치명&gt;

사용 예:
	dumpe2fs /dev/sdb1
```

#### dumpe2fs를 이용해 수퍼 블록 정보 추출
- 먼저 어떤 장치의 수퍼 블록 정보를 얻을 것인지 체크
&lt;img src=&quot;img2.jpg&quot;&gt;
- /dev/sda2 장치의 수퍼 블록 정보를 얻어보자
&lt;img src=&quot;img3.jpg&quot;&gt;
- 32768번 블록 등 백업 수퍼블록은 모두 13개이다.
	- 이 중 `하나를 사용`해 `파일 시스템 복구`할 수 있다.

#### fsck, e2fsck -b 로 파일 시스템 복구
- 위 ***dumpe2fs*** 를 이용해 얻은 **백업 수퍼 블록 정보**를 이용해 **fsck -b** 옵션을 이용해 파일 시스템을 **복구**한다.
  
```c
$ sudo e2fsck -b 32768 -y /dev/sda2
e2fsck 1.42.8 (20-Jun-2013)
/dev/sda2 was not cleanly unmounted, check forced.
Pass 1: Checking inodes, blocks, and sizes
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Checking reference counts
Pass 5: Checking group summary information

/dev/sda2: ***** FILE SYSTEM WAS MODIFIED *****
/dev/sda2: 11/76912 files (0.0% non-contiguous), 11777/307200 blocks
$
```
- e2fsck **-b** 옵션은 **백업 수퍼블록 위치 지정**이고, -y는 All yes!</content><author><name>Dong-Heyon Yang</name><email>markyang920413@gmail.com</email></author><category term="[&quot;linux-system&quot;]" /></entry><entry><title type="html">LVM</title><link href="https://markyang920413.github.io//linux-filesystem/linux-linux_filesystem-LVM/" rel="alternate" type="text/html" title="LVM" /><published>2021-03-07T00:00:00+09:00</published><updated>2021-03-07T00:00:00+09:00</updated><id>https://markyang920413.github.io//linux-filesystem/linux-linux_filesystem-LVM</id><content type="html" xml:base="https://markyang920413.github.io//linux-filesystem/linux-linux_filesystem-LVM/">## LVM
- **LVM**은 독립적으로 구성된 디스크 파티션을 하나로 연결하여 `한 파티션처럼` 사용할 수 있도록 해준다.
	- **PV**(physical volume, 물리 볼륨): /dev/sdb1, /dev/sdb2 같은 실제 물리 디스크의 파티션
	- **VG**(volume group, 볼륨 그룹): **여러 개의 PV**를 **그룹으로** 묶은 것을 말한다.&lt;br&gt;예: /dev/sdb1, /dev/sdb2가 GRP1이라는 그룹을 만들 때 **GRP1을 VG**라고 한다.
	- **LV**(logical volume, 논리 볼륨): VG를 다시 적절한 크기의 파티션으로 나눌 때, 각 파티션을 **LV**라고 함
	- **PE**(physical extent): PV가 가진 일정한 블록을 의미
	- **LE**(logical extent): LV가 가진 일정한 블록을 의미
&lt;br&gt;
&lt;br&gt;
  
&lt;img src=&quot;img1.png&quot;&gt;
- 물리 파티션(PV) 세 개를 묶어 VG 하나를 만들고, 다시 LV 두 개로 분리.&lt;br&gt;LV에 파일 시스템 생성 후 마운트

## LVM 명령

**구분**|**기능**|**명령**
PV|PV 생성|pvcreate [파티션 이름]
PV|PV 상태 확인|pvscan
VG|VG 생성|vgcreate [VG 명] [PV 명1] [PV 명2] ...
VG|VG 활성화|vgchange -a y [VG 명]
VG|VG 비활성화|vgchange -a n [VG 명]
VG|VG 삭제|vgremove [VG 명]
VG|VG 정보 확인|vgdisplay -v [VG 명]
VG|VG에 PV 추가|vgextend [VG 명] [PV 명]
VG|VG에 PV 삭제|vgreduce [VG 명] [PV 명]
VG|VG명 변경|vgrename [기존 VG 명] [새로운 VG 명]
LV|LV 생성|lvcreate -l [PE 수] [VG 명] -n [LV 명]
LV|LV 삭제|lvremove [LV 명]
LV|LV 상태 확인|lvscan
LV|LV 용량 확대|lvextent -l [+PE 수] [LV 명]
LV|LV 용량 축소|lvextent -l [-PE 수] [LV 명]

## LVM 생성하기
- 기존 파일 시스템을 LVM으로 만드는 과정
	- /dev/sdb1, /dev/sdb2는 **각 500MB**인데 이를 **LVM으로 1GB 짜리 LV**를 생성하여 마운트 해보자.
&lt;br&gt;
&lt;br&gt;
- **lvm2 패키지**를 우선 설치한다.
  
```c
$ sudo apt install lvm2
```

- **/dev/sdb1, /dev/sdb2**의 **파일 시스템**을 **83(Linux)**에서 **8e(Linux LVM)**으로 변경
	- **fdisk** -&gt; **내부 명령 t** -&gt; **w로 저장**
  
```c
$ sudo fdisk /dev/sdb

Command (m for help): p			# 한번 정보부터 보자

Disk /dev/sdb: 1073 MB, 1073741824 bytes
255 heads, 63 sectors/track, 130 cylinders, total 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x2fa4c807

Device Boot	Start	End	Blocks	Id	System
/dev/sdb1	2048	1026047	512000	83	Linux
/dev/sdb2	1026048	2050047	512000	83	Linux

Command (m for help): t						# 내부 명령 t
Partition number (1-4): 1					# 파티션 1(sdb1) 선택
Hex code (type L to list codes): 8e				# 파일 시스템을 83(Linux) -&gt; 8e(Linux LVM)
Changed system type of partition 1 to 8e (Linux LVM)

Command (m for help): t						# 내부 명령 t
Partition number (1-4): 2					# 파티션 2(sdb2) 선택
Hex code (type L to list codes): 8e				# 파일 시스템을 83(Linux) -&gt; 8e(Linux LVM)
Changed system type of partition 1 to 8e (Linux LVM)

Command (m for help): p						# 다시 정보 조회

Disk /dev/sdb: 1073 MB, 1073741824 bytes
255 heads, 63 sectors/track, 130 cylinders, total 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x2fa4c807

Device Boot	Start	End	Blocks	Id	System
/dev/sdb1	2048	1026047	512000	8e	Linux LVM		# 파일 시스템 LVM 변경 확인
/dev/sdb2	1026048	2050047	512000	83	Linux LVM		# 파일 시스템 LVM 변경 확인

Command (m for help): w							# w 명령을 줘야 저장됨
The partition table has been altered!

Calling ioctl() to re-read paritition table.
Syncing disks.
$
```
  
- /dev/sdb1, /dev/sdb2에 **PV**를 생성한다.
  
```c
$ sudo pvcreate /dev/sdb1
	Physical volume &quot;/dev/sdb2&quot; successfully created
$ sudo pvcreate /dev/sdb2
	Physical volume &quot;/dev/sdb2&quot; successfully created
#
```
  
- **pvscan** 명령으로 **PV의 상태 확인**
  
```c
$ sudo pvscan
	PV /dev/sdb1				lvm2 [500.00 MiB]
	PV /dev/sdb2				lvm2 [500.00 MiB]
	Total: 2 [1000.00 MiB] / in use: 0 [0  ] / in no VG: 2 [1000.00 MiB]
$
```
  
- 두 **PV**를 통합하여 **VG**를 생성한다. **VG**의 이름은 **grp1**로 한다.
  
```c
$ sudo vgcreate grp1 /dev/sdb1 /dev/sdb2
	Volume group *grp1* successfully created
$
```
  
- 생성된 **VG grp1**을 **활성화**한다.
  
```c
$ sudo vgchange -a y grp1
	0 logical volume(s) in volume group *grp1* now active
$
```

- 활성화된 **VG grp1**의 **상태**를 **vgdisplay**명령으로 확인
  
```c
$ sudo vgdisplay -v grp1
	Using volume group(s) on command line
	Finding volume group *grp1*
-- Volume group --
VG Name				grp1
System ID
Format				lvm2
Metadata Areas			2
Metadata Sequence No		1
VG Access			read/write
VG Status			resizable
MAX LV				0
Cur LV				0
Open LV				0
Max PV				0
Cur PV				2
Act PV				2
VG Size				992.00 MiB
PE Size				4.00 MiB
Total PE			248
Alloc PE / Size			0 / 0
Free PE / Size			248 /992.00 MiB
VG UUID				C2ezGa-rtX5-pUES-pczS-PVTA-tswP-Ff1MYc


--- Physical volumes ---
PV Name				/dev/sdb1
PV UUID				LlfbHM-i35S-RA0t-ZKUa-bMHY-yIj7-hz01x0
PV Status			allocatable
Total PE / Free PE		124 / 124

PV Name				/dev/sdb2
PV UUID				h1Vt26-2QPO-fAbi-ABpR-s20x-6R63-2oPbEx
PV Status			allocatable
Total PE / Free PE		124 / 124

$
```

- VG grp1 에는 PE가 총 248개 있다. 이를 모두 합하여 하나의 LV를 생성한다.
  
```c
$ sudo lvcreate -l 248 grp1 -n mylvm1
	Logical volume &quot;mylvm1&quot; created
$
```

- 생성된 LV의 상태를 확인해보면 ACTIVE임을 알 수 있다.
  
```c
$ sudo lvscan
	ACTIVE	'/dev/grp1/mylvm1' [992.00 MiB] inherit
$
```

- LV mylvm1에 **ext4** 파일 시스템을 생성한다.
	- 위에서 확인한 LV의 장치명이 /dev/grp1/mylvm1로 되어 있음을 주의한다.
  
```c
$ sudo mke2fs -t ext4 /dev/grp1/mylvm1
mke2fs 1.42.8 (20-Jun-2013)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
63488 inodes, 253952 blocks
12697 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=260046848
8 block groups
32768 blocks per group, 32768 fragments per group
7936 inodes per group
Superblock backups stored on blocks:
	32768, 98304, 163840, 229376

Allocating group tables: done
Writing inode tables: done
Creating journal (4096 blocks):
done
Writing superblocks and filesystem accounting information: done

$
```

- VG의 상태를 확인하여 LV의 정보가 수정되었는지 확인한다.
  
```c
$ sudo vgdisplay -v grp1
	Using volume group(s) on command line
	Finding volume group &quot;grp1&quot;
--- Volume group ---
(생략)
--- Logical volume ---
LV Path				/dev/grp1/mylvm1
LV Name				mylvm1
VG Name				grp1
LV UUID				m7ypbD-4PZZ-c8zl-Ftrz-Yv1T-dB04-szjKEI
LV Write Access			read/write
LV Creation host, time myubuntu, 2014-03-10 00:55:53 +0900
LV Status			available
# open				0
LV Size				992.00 MiB
Current LE			248
Segments			2
Allocation			inherit
Read ahead sectors		auto
- currently set to 256 
Block device			252:0

--- Physical volumes ---
(생략)

$
```

- LV를 /mnt/lvm 디렉터리에 마운트하고 파일을 복사해본다.
  
```c
$ sudo mkdir /mnt/lvm
$ sudo mount /dev/grp1/mylvm1 /mnt/lvm
$ sudo cp /etc/hosts /mnt/lvm
$ ls /mnt/lvm
hosts lost+found
$
```</content><author><name>Dong-Heyon Yang</name><email>markyang920413@gmail.com</email></author><category term="[&quot;linux-filesystem&quot;]" /></entry><entry><title type="html">리눅스 부팅, init 스크립트 다루기 명령 - initctl, 런레벨, runlevel</title><link href="https://markyang920413.github.io//linux-system/linux-linux_system-boot/" rel="alternate" type="text/html" title="리눅스 부팅, init 스크립트 다루기 명령 - initctl, 런레벨, runlevel" /><published>2021-03-07T00:00:00+09:00</published><updated>2021-03-07T00:00:00+09:00</updated><id>https://markyang920413.github.io//linux-system/linux-linux_system-boot</id><content type="html" xml:base="https://markyang920413.github.io//linux-system/linux-linux_system-boot/">## 리눅스 시스템의 부팅
&lt;img src=&quot;img1.png&quot;&gt;

## 바이오스 단계
- BIOS가 동작한다.
	- ROM에 저장되어 있다.
	- PC의 기본적인 HW(키보드, 디스크 등)을 체크
	- 부팅 장치 선택 -&gt; **부트 디스크의 첫 섹터의** `512Byte 로딩` -&gt; **메모리**
		- 이 부트 디스크의 첫 섹터의 512Byte를 `마스터 부트 레코드`**(MBR)**: 디스크의 어느 파티션에 2차 부팅 프로그램(`부트로더`)가 있는지 **정보가 저장**
- 메모리에 로딩된 MBR
	- 부트로더 정보가 저장되어 있음
	- **부트로더**를 **메모리**에 **로딩**
  
&lt;img src=&quot;img2.png&quot; width=&quot;70%&quot;&gt;

## 부트로더 단계
- MBR이 부트로더를 메모리에 로딩하면, 부트로더는 **여러 OS 중 부팅할 OS 선택**하게 메뉴 제공.
	- 리눅스 부트로더: **GRUB, LILO**
- 부트로더: `리눅스 커널`을 `메모리에 로딩`하는 역할
	- &lt;span style=&quot;color:steelblue&quot;&gt;**리눅스 커널**&lt;/span&gt;은 ***/boot/vmlinuz***&lt;span style=&quot;color:red&quot;&gt;***-버전명***&lt;/span&gt; 형태로 제공된다.  
	&lt;img src=&quot;img4.png&quot;&gt;

&lt;br&gt;&lt;br&gt;
- 우분투 부트로더: `GRUB`
- 부팅 시 GRUB 메뉴를 출력하려면 **/etc/default/grub**파일을 수정해야 한다.
  
```bash
$ vi /etc/default/grub
```
  
&lt;img src=&quot;img3.png&quot; width=&quot;60%&quot;&gt;
- **GRUB_HIDDEN_TIMEOUT=0** 을 주석 처리
- **GRUB_TIMEOUT=10**은 GRUB메뉴가 출력되는 시간이다.
	- 이 시간이 지나고 나면 부팅 과정이 자동으로 진행된다.
  
- 위 파일을 수정했다면  
```bash
$ sudo update-grub
```
수행하여 적용한다.
  

## 커널 초기화 단계
- 부트로더에 의해 로딩된 `커널`은 먼저 시스템에 연결된 메모리, 디스크, 키보드, 마우스 등의 `장치 검사`
- fork를 사용하지 않고 생성되는 `프로세스, 스레드 생성`
	- 이들은 **메모리 관리**와 같은 커널의 여러 가지 동작을 수행한다.
	- `[`**프로세스 명**`]` 으로 표기되어 있다.
```c
$ ps -ef | more
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 15:26 ?        00:00:00 /sbin/init splash
root           2       0  0 15:26 ?        00:00:00 [kthreadd]
root           3       2  0 15:26 ?        00:00:00 [rcu_gp]
root           4       2  0 15:26 ?        00:00:00 [rcu_par_gp]
root           6       2  0 15:26 ?        00:00:00 [kworker/0:0H-kblockd]
root           8       2  0 15:26 ?        00:00:00 [mm_percpu_wq]
root           9       2  0 15:26 ?        00:00:00 [ksoftirqd/0]
root          10       2  0 15:26 ?        00:00:00 [rcu_sched]
root          11       2  0 15:26 ?        00:00:00 [migration/0]
root          12       2  0 15:26 ?        00:00:00 [idle_inject/0]
root          14       2  0 15:26 ?        00:00:00 [cpuhp/0]
root          15       2  0 15:26 ?        00:00:00 [cpuhp/1]
root          16       2  0 15:26 ?        00:00:00 [idle_inject/1]
root          17       2  0 15:26 ?        00:00:00 [migration/1]
root          18       2  0 15:26 ?        00:00:00 [ksoftirqd/1]
root          20       2  0 15:26 ?        00:00:00 [kworker/1:0H-kblockd]
root          21       2  0 15:26 ?        00:00:00 [kdevtmpfs]
root          22       2  0 15:26 ?        00:00:00 [netns]
root          23       2  0 15:26 ?        00:00:00 [rcu_tasks_kthre]
root          24       2  0 15:26 ?        00:00:00 [rcu_tasks_rude_]
root          25       2  0 15:26 ?        00:00:00 [rcu_tasks_trace]
root          27       2  0 15:26 ?        00:00:00 [kauditd]
root          28       2  0 15:26 ?        00:00:00 [khungtaskd]
root          29       2  0 15:26 ?        00:00:00 [oom_reaper]
root          30       2  0 15:26 ?        00:00:00 [writeback]
root          31       2  0 15:26 ?        00:00:00 [kcompactd0]
root          32       2  0 15:26 ?        00:00:00 [ksmd]
root          33       2  0 15:26 ?        00:00:00 [khugepaged]
root          79       2  0 15:26 ?        00:00:00 [kintegrityd]
root          80       2  0 15:26 ?        00:00:00 [kblockd]
root          81       2  0 15:26 ?        00:00:00 [blkcg_punt_bio]
root          82       2  0 15:26 ?        00:00:00 [tpm_dev_wq]
root          83       2  0 15:26 ?        00:00:00 [ata_sff]
---more---
```
	- **커널 프로세스**가 생성되면 커널이 수행할 작업이 끝난다. 이제 **init**단계를 동작한다.

## init 실행 단계
- 다양한 서비스를 동작한다.
- 부팅 메시지를 출력하려면&lt;br&gt;**/etc/default/grub**파일에서&lt;Br&gt; **GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;**를 찾아 **quiet**를 삭제하고&lt;br&gt; sudo update-grub를 실행하면 된다.
- 부팅 메시지는 부팅 후, dmesg 명령이나 more /var/lob/boot.log 명령으로 확인할 수 있다.  
```c
$ dmesg | more
[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x410f0000]
[    0.000000] Linux version 5.8.0-45-generic (buildd@bos02-arm64-071) (gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0, GNU ld (GNU Binutils for Ubuntu) 2.34) #51~20.04.1-Ubuntu SMP Tue Feb 23 13:48:59 UTC 20
21 (Ubuntu 5.8.0-45.51~20.04.1-generic 5.8.18)
[    0.000000] Machine model: Parallels ARM Virtual Machine
[    0.000000] efi: EFI v2.70 by EDK II
[    0.000000] efi: ACPI 2.0=0xfc1a0000 SMBIOS 3.0=0xff870000 MEMATTR=0xfe45da98 MEMRESERVE=0xfc089d98
[    0.000000] secureboot: Secure boot disabled
[    0.000000] cma: Reserved 32 MiB at 0x00000000fa000000
[    0.000000] NUMA: No NUMA configuration found
[    0.000000] NUMA: Faking a node at [mem 0x0000000080000000-0x00000000fffeffff]
[    0.000000] NUMA: NODE_DATA [mem 0xffbe70c0-0xffbebfff]
[    0.000000] Zone ranges:
[    0.000000]   DMA      [mem 0x0000000080000000-0x00000000bfffffff]
[    0.000000]   DMA32    [mem 0x00000000c0000000-0x00000000fffeffff]
[    0.000000]   Normal   empty
[    0.000000]   Device   empty
[    0.000000] Movable zone start for each node
[    0.000000] Early memory node ranges
[    0.000000]   node   0: [mem 0x0000000080000000-0x00000000fc08ffff]
[    0.000000]   node   0: [mem 0x00000000fc090000-0x00000000fc14ffff]
[    0.000000]   node   0: [mem 0x00000000fc150000-0x00000000ff67ffff]
[    0.000000]   node   0: [mem 0x00000000ff680000-0x00000000ffa5ffff]
[    0.000000]   node   0: [mem 0x00000000ffa60000-0x00000000fffeffff]
[    0.000000] Zeroed struct page in unavailable ranges: 592 pages
[    0.000000] Initmem setup node 0 [mem 0x0000000080000000-0x00000000fffeffff]
[    0.000000] On node 0 totalpages: 524272
[    0.000000]   DMA zone: 4096 pages used for memmap
[    0.000000]   DMA zone: 0 pages reserved
[    0.000000]   DMA zone: 262144 pages, LIFO batch:63
[    0.000000]   DMA32 zone: 4096 pages used for memmap
[    0.000000]   DMA32 zone: 262128 pages, LIFO batch:63
[    0.000000] psci: probing for conduit method from DT.
[    0.000000] psci: PSCIv1.0 detected in firmware.
[    0.000000] psci: Using standard PSCI v0.2 function IDs
(생략)
```
&lt;br&gt;
- UNIX에서는 init 프로세스가 서비스를 실행시켰다.
	- 따라서 init 프로세스는 PID 1번이다.

## init 프로세스와 런레벨
### upstart, init process
---
- **init**프로세스는 PID가 1번인 **모든 프로세스의 조상**
	- 부팅과정에서 **커널에 의해 실행**, 각종 서비스를 제공하는 다른 프로세스를 동작시키는 역할
&lt;br&gt;&lt;br&gt;
- ***init process***
	- 기존 UNIX에서 init 프로세스는 스크립트를 순차적으로 실행하여 다른 프로세스들을 동작시켰다.
	- 최근 Ubuntu Linux에서는 이벤트 기반으로 동작하는 방식으로 init 프로세스를 대체하고 있다.
		- Ubuntu는 자체적으로 개발한 `upstart`를 init 대신 사용한다. 다만 기존 UNIX 호환을 위해 init을 유지하고 있다.
		- init의 동작 방식이 바뀜에 따라 전통적으로 init 프로세스와 관련된 설정 파일인 /etc/inittab 파일은 우분투에서 사라졌다.
&lt;br&gt;&lt;br&gt;
- ***init process and scriptfile***
	- 기존 init과 새로운 upstart는 모두 `프로세스를 실행, 종료`하기 위해 `스크립트 파일`을 사용한다.
		- 설치하는 서비스에 따라 upstart용 스크립트가 설치, init용 스크립트가 설치되기도 한다.
	- 만약 /etc/init 디렉터리와 /etc/init.d 디렉터리에 같은 서비스에 대한 파일이 있다면 /etc/init 디렉터리 스크립트 파일이 우선적으로 적용된다.
  
```bash  
$ ls /etc/init
whoopsie.conf
$ ls /etc/init.d
alsa-utils  avahi-daemon      cups          grub-common  keyboard-setup.sh  openvpn       procps                       samba-ad-dc        spice-vdagent  unattended-upgrades
anacron     bluetooth         cups-browsed  hwclock.sh   kmod               plymouth      pulseaudio-enable-autospawn  saned              ssh            uuidd
apparmor    console-setup.sh  dbus          irqbalance   network-manager    plymouth-log  rsync                        smbd               udev           whoopsie
apport      cron              gdm3          kerneloops   nmbd               pppd-dns      rsyslog                      speech-dispatcher  ufw            x11-common
```
- &lt;span style=&quot;color:navy&quot;&gt;**upstart**&lt;/span&gt;가 사용하는 작업 파일은 ***/etc/init*** 디렉터리에 &lt;span style=&quot;color:red&quot;&gt;**작업명.conf**&lt;/span&gt; 형태로 구성되어 있다. 
- &lt;span style=&quot;color:magenta&quot;&gt;**init**&lt;/span&gt;가 사용하는 작업 파일은 ***/etc/init.d*** 디렉터리에 있다.
- 만약 ***init, init.d*** &lt;U&gt;모두에 같은 서비스와 관련된 스크립트&lt;/U&gt;들이 있다면 ***/etc/init.d*** 디렉터리에 있는 스크립트 중 일부는 /lib/init/upstart-job에 대한 &lt;span style=&quot;color:steelblue&quot;&gt;**심벌릭 링크**&lt;/span&gt;이다.
	- **upstart-job**: 해당 서비스의 upstart 스크립트를 찾아서 실행시킨다.
	```c
	$ ls -l /etc/init.d | grep upstart
	```
  
### upstart, init script 시작하고 정지하기
---
- &lt;span style=&quot;color:navy&quot;&gt;**upstart**&lt;/span&gt;와 &lt;span style=&quot;color:magenta&quot;&gt;**init**&lt;/span&gt;를 **시작**하고 **정지**하는 방법은 약간 다르다.
  
#### initctl - upstart 스크립트 제어
- &lt;span style=&quot;color:navy&quot;&gt;**upstart**&lt;/span&gt; 스크립트 시작하고 정지하기
	- upstart에서는 &lt;U&gt;서비스를 제공하는 프로세스&lt;/U&gt;를 **&lt;U&gt;작업&lt;/U&gt;**이라고 부르며 다음과 같은 두 가지 방법으로 작업을 시작하거나 정지한다.  
	```c
	$ initctl [start | stop | restart | reload | status] 작업명
	$ [start | stop | restart | reload | status] 작업명
	```
	- 위 두 명령어 모두 `initctl` 명령을 사용하는 것이다.  
	```c
	$ ls -l /sbin | grep initctl
	-rwxr-xr-x	1	root	root	179012	10월 10 00:05	initctl
	lrwxrwxrwx	1	root	root	7	2월 20 21:12	reload -&gt; initctl
	lrwxrwxrwx	1	root	root	7	2월 20 21:12	restart -&gt; initctl
	lrwxrwxrwx	1	root	root	7	2월 20 21:12	start -&gt; initctl
	lrwxrwxrwx	1	root	root	7	2월 20 21:12	status -&gt; initctl
	lrwxrwxrwx	1	root	root	7	2월 20 21:12	stop -&gt; initctl
	$
	```
- `initctl`은 &lt;span style=&quot;color:navy&quot;&gt;**upstart**&lt;/span&gt; 스크립트를 **실행하기 위한 명령**!
	- 서브 명령에 따라 서비스를 시작/ 정지
  
```c
$ initctl [서브 명령] 작업명

서브 명령:
	start		작업을 시작한다.
	stop		작업을 정지한다.
	reload		작업에 SIGHUP 시그널을 보낸다.
	restart		작업을 다시 시작한다.
	status		작업 상태를 출력한다.
	list		알려진 작업의 목록을 현재 상태와 함께 출력한다.

사용 예:
	initctl start cups
	initctl stop cups
	initctl list
```
  
#### service - 기존 init 스크립트 제어 
   
- `service` 명령은 &lt;span style=&quot;color:magenta&quot;&gt;**init**&lt;/span&gt; 스크립트를 **실행하기 위한 명령**!
	- 서브 명령에 따라 서비스 시작/ 정비
 
```c
$ service 스크립트 [서브 명령]

서브 명령:
	start		스크립트에 지정한 start 부분을 실행한다.
	stop		스크립트에 지정한 stop 부분을 실행한다.
	reload		스크립트에 지정한 reload 부분을 실행한다.
	restart		스크립트에 지정한 restart 부분을 실행한다.
	status		스크립트에 지정한 status 부분을 실행한다.

사용 예:
	service cups start
	service cups stop
```
  
### init 프로세스와 런레벨
---
- 기존의 &lt;span style=&quot;color:magenta&quot;&gt;**init**&lt;/span&gt;프로세스는 &lt;span style=&quot;color:firebrick&quot;&gt;**런 레벨(Run level)**&lt;/span&gt;이라는 개념을 사용했다.
	- **시스템의 단계**를 **일곱 개로 구분**하여 정의하고 **각 단계에 따라 &lt;U&gt;쉘 스크립트를 실행&lt;/U&gt;**, **이 단계**들을 &lt;span style=&quot;color:firebrick&quot;&gt;**런레벨**&lt;/span&gt;이라고 한다.

&lt;span style=&quot;color:blue&quot;&gt;**Fedora 런레벨**&lt;/span&gt;  
  
**런 레벨**|**의미**|**관련 스크립트 위치**
0|시스템 종료|/etc/rc0.d
1,S,s|단일 사용자 모드|/etc/rc1.d
2|다중 사용자 모드(NFS를 실행하지 않음)|/etc/rc2.d
3|다중 사용자 모드(NFS 포함)|/etc/rc3.d
4|사용하지 않음(예비 번호)|/etc/rc4.d
5|시스템 종료(페도라는 GUI 모드로 부팅)|/etc/rc5.d
6|시스템 재시작|/etc/rc6.d

&lt;br&gt;
&lt;span style=&quot;color:magenta&quot;&gt;**Ubuntu 런레벨**&lt;/span&gt; 
  
**런 레벨**|**의미**|**관련 스크립트 위치**
0|시스템 종료|/etc/rc0.d
1,S,s|단일 사용자 모드|/etc/rc1.d, /etc/rcS.d
2|그래피컬 다중 사용자 모드+네트워킹(기본 값)|/etc/rc2.d
3|런레벨 2와 동일|/etc/rc3.d
4|런레벨 2와 동일|/etc/rc4.d
5|런레벨 2와 동일|/etc/rc5.d
6|시스템 재시작|/etc/rc6.d
 
- 런레벨 3,4,5 번에 2번과 같다는 것을 통해 &lt;U&gt;rc2.d 디렉터리&lt;/U&gt;와 &lt;U&gt;rc3.d, rc4.d, rc5.d 디렉터리의 내용&lt;/U&gt;이 모두 같음을 알 수 있다. 
  
&lt;img src=&quot;img5.png&quot;&gt;
  
- 위 표에서 런레벨별로 실행하는 스크립트 파일은 **/etc/init.d** 디렉터리에 있는 파일에 대한 심벌릭 링크 이다.  

#### 런레벨 변경하기
---
- &lt;span style=&quot;color:red&quot;&gt;**init**&lt;/span&gt;은 1번 프로세스의 이름이기도 하지만 &lt;span style=&quot;color:red&quot;&gt;**init 프로세스의 런레벨을 바꾸는 명령**&lt;/span&gt;으로 사용되기도 한다.
	- **init**을 **명령으로 사용**하면, 실제로는 **/sbin/**`telinit` 이 실행된다.
	- **init**로 런레벨을 변경하기 위해서는 바꾸려는 런레벨을 숫자로 지정하면 된다.
		- 예: 단일 사용자 모드로 전환하려면 ***init 1*** 이라고 하면 된다.  
		```c
		$ sudo init 1
		```
		- 위 명령을 실행하면 현재 그래픽 환경이었던 Console이 터미널 환경으로 바뀌면서 프롬프트가 출력되어야 한다.&lt;br&gt;&lt;span style=&quot;color:red&quot;&gt;**그러나!!**&lt;/span&gt; 현재 우분투는 **init 1**을 실행하면 아래 스플래시 화면이 출력되고 정지 상태가된다(bug)
		- 원래 시스템에 문제가 있을 경우 시스템을 **런레벨 1(런레벨 S)**로 변경하여 점검해야한다. (윈도우 안전모드)&lt;br&gt;다중 사용자 모드에서 시스템 관리자만 사용할 수 있는 단일 사용자 모드로 전환하는 것이다.&lt;br&gt;따라서 이 모드로 변환하기 전에 다른 사용자들이 로그아웃하도록 해야 한다.

##### 기본 런레벨 지정
---
- 우분투에서 부팅할 때 동작할 기본 런레벨은 **/etc/init/rc-sysinit.conf** 파일의 **DEFAULT_RUNLEVEL**변수에 지정되어 있다.
  
```bash
$ cat /etc/init/rc-sysinit.conf
(생략)
# Default runlevel, this may be overriden on the kernel command-line
# or by faking an old /etc/inittab entry
env DEFAULT_RUNLEVEL=2
(생략)
$
```

##### 현재 런레벨 확인
---
  
- `runlevel` 명령  
&lt;img src=&quot;img6.png&quot;&gt;
- **N 5** 라는 뜻은 부팅 때 런레벨 5로 부팅했음을 뜻한다.</content><author><name>Dong-Heyon Yang</name><email>markyang920413@gmail.com</email></author><category term="[&quot;linux-system&quot;]" /><summary type="html">initctl, runlevel</summary></entry><entry><title type="html">M1 Mac 로제타2 설치, 로제타 사용 brew 설치, M1용 jekyll설치</title><link href="https://markyang920413.github.io//mac/m1_rosetta2/" rel="alternate" type="text/html" title="M1 Mac 로제타2 설치, 로제타 사용 brew 설치, M1용 jekyll설치" /><published>2021-03-06T00:00:00+09:00</published><updated>2021-03-06T00:00:00+09:00</updated><id>https://markyang920413.github.io//mac/m1_rosetta2</id><content type="html" xml:base="https://markyang920413.github.io//mac/m1_rosetta2/">## M1 Rosetta2 설치
- **command line**
  
```c
// 1. 라이센스 동의 필요
$ softwareupdate --install-rosetta

// 2. 라이선스 자동 동의
$ /usr/sbin/softwareupdate --install-rosetta --agree-to-license
```
  
- 응용프로그램 -&gt; Iterm 정보 가져오기 -&gt; **로제타를 사용하여 열기** 옵션 활성화

- **command line**
  
```c
$ arch -x86_64 /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;

# ~/.zshrc에 추가
export PATH=/opt/homebrew/bin:/Users/yangdonghyeon/.rbenv/shims:/opt/homebrew/bin:/Users/yangdonghyeon/.rbenv/shims:/opt/homebrew/bin:/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Apple/usr/bin:/opt/homebrew/bin:$PATH

$ alias ibrew='arch -x86_64 /usr/local/bin/brew'
```
  
- x86_64용으로 파일을 열기 위해선 실행파일 앞에 &lt;span style=&quot;color:red&quot;&gt;**arch -x86_64**&lt;/span&gt;를 붙인다.

&lt;br&gt;&lt;br&gt;
- **x86_64용 brew 설치확인**
  
```c
$ ibrew config
HOMEBREW_VERSION: 3.0.4
ORIGIN: https://github.com/Homebrew/brew
HEAD: ee52b19179d056f3dd2fdf9c52214d3d51dbb9d9
Last commit: 2 days ago
Core tap ORIGIN: https://github.com/Homebrew/homebrew-core
Core tap HEAD: 6559768c37c501716601f18362d1abf55479fe29
Core tap last commit: 16 minutes ago
Core tap branch: master
HOMEBREW_PREFIX: /usr/local
HOMEBREW_CASK_OPTS: []
HOMEBREW_MAKE_JOBS: 8
Homebrew Ruby: 2.6.3 =&gt; /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/bin/ruby
CPU: octa-core 64-bit westmere
Clang: 12.0 build 1200
Git: 2.24.3 =&gt; /Library/Developer/CommandLineTools/usr/bin/git
Curl: 7.64.1 =&gt; /usr/bin/curl
macOS: 11.2.2-x86_64			# x86_64 확인
CLT: 12.4.0.0.1.1610135815
Xcode: 12.4
Rosetta 2: true				# Rosetta 2: true 확인
```
  
- **ibrew**로 이제 x86_64용 brew를 실행한다.

## M1 Mac용 jekyll 설치

&lt;span style=&quot;color:red&quot;&gt;**주의!**&lt;/span&gt; ***jekyll***은 로제타2를 사용한 brew 커맨드를 사용하여 설치해야한다.
따라서, 위 처럼 로제타2 설치를 필요로한다.

- **specific ruby사용을 위한 rbenv 사용**
	- **rbenv 설치**  
  
```c
$ ibrew install rbenv
..install complete

# 혹시 brew메세지가 아래 처럼 해라하면 ~/.zshrc에 넣기
export RUBY_CONFIGURE_OPTS=&quot;--with-openssl-dir=$(brew --prefix openssl@1.1)&quot;

$ rbenv init

# ~/.zshrc에 추가
eval &quot;$(rbenv init -)&quot;

$ rbenv install 2.7.2
$ rbenv global 2.7.2
$ ruby -v
ruby 2.7.2p137 (2020-10-01 revision 5445e04352) [x86_64-darwin20]	# x86_64 확인!!!
```

- **jekyll 설치**
  
```c
# 블로그 디렉터리로 가서
$ arch -x86_64 gem install --user-install bundler jekyll
$ arch -x86_64 bundle update
$ arch -x86_64 bundle install
```

- **local hosting**
  
```c
$ arch -x86_64 bundle exec jekyll serve
```</content><author><name>Dong-Heyon Yang</name><email>markyang920413@gmail.com</email></author><category term="[&quot;mac&quot;]" /></entry><entry><title type="html">시험에서 입출력, STL</title><link href="https://markyang920413.github.io//algorithm/algorithm-algorithm-IO_STL/" rel="alternate" type="text/html" title="시험에서 입출력, STL" /><published>2021-03-02T00:00:00+09:00</published><updated>2021-03-02T00:00:00+09:00</updated><id>https://markyang920413.github.io//algorithm/algorithm-algorithm-IO_STL</id><content type="html" xml:base="https://markyang920413.github.io//algorithm/algorithm-algorithm-IO_STL/">## scanf(), printf()

### 특정 자료형 거르기
---
&lt;span style=&quot;color:red&quot;&gt;
&lt;img src=&quot;img1.jpg&quot;&gt;

### 특정 갯수만큼만 받기
---

```c
scanf(&quot;%1d&quot;, &amp;a);
```
- **%**&lt;span style=&quot;color:red&quot;&gt;**1**&lt;/span&gt;**d** 와 같이 중간에 숫자를 넣은 만큼 입력을 받는다.
	- 12345 입력 시, 1 2 3 4 5 따로 받을 수 있다.


```c
scanf(&quot;%5s&quot;, str);
```
- **%**&lt;span style=&quot;color:red&quot;&gt;**5**&lt;/span&gt;**s** 와 같이 &lt;span style=&quot;color:navy&quot;&gt;**string**&lt;/span&gt;도 중간에 숫자를 넣은 만큼 입력을 받는다.
	- &lt;span style=&quot;color:green&quot;&gt;&quot;hello world&quot;&lt;/span&gt; &gt;&gt; &quot;%&lt;span style=&quot;color:red&quot;&gt;**3**&lt;/span&gt;s&quot; &gt;&gt; &lt;span style=&quot;color:green&quot;&gt;&quot;hel&quot;&lt;/span&gt;


### scanf 로 끝까지 받기
---
- **scanf**의 **리턴 값**은 **성공적으로** &lt;span style=&quot;color:red&quot;&gt;**입력 받은 인자 개수**&lt;/span&gt;이다.
- **파일의** &lt;span style=&quot;color:red&quot;&gt;**끝**&lt;/span&gt;까지 받아야 하는 경우 
```c
while( scanf(&quot;%d %d&quot;, &amp;a, &amp;b) == 2);
```


## 한줄 입력

- ***scanf(), cin &gt;&gt;***으로는 &lt;span style=&quot;color:red&quot;&gt;**한 줄**&lt;/span&gt;입력 불가!

```c
fgets(s, 100, stdin);	&quot;fgets()는 줄 바꿈까지 입력 받음!! 주의!!&quot;
getline(cin, s);
```</content><author><name>Dong-Heyon Yang</name><email>markyang920413@gmail.com</email></author><category term="[&quot;algorithm&quot;]" /></entry><entry><title type="html">Time complexity</title><link href="https://markyang920413.github.io//algorithm/algorithm-algorithm-time_complexity/" rel="alternate" type="text/html" title="Time complexity" /><published>2021-03-02T00:00:00+09:00</published><updated>2021-03-02T00:00:00+09:00</updated><id>https://markyang920413.github.io//algorithm/algorithm-algorithm-time_complexity</id><content type="html" xml:base="https://markyang920413.github.io//algorithm/algorithm-algorithm-time_complexity/">## Time Complexity
- **O(1)**: 단순 계산(a+b, 배열 접근 연산)
- **O(logN)**: N개를 **절반**으로 계속 나눔
- **O(N)**: 1중 for문
- **O(NlogN)**
- **O(N&lt;sup&gt;2&lt;/sup&gt;)**: 2중 for문
- **O(N&lt;sup&gt;3&lt;/sup&gt;)**: 3중 for문
- **O(2&lt;sup&gt;N&lt;/sup&gt;)**: 크기가 N인 집합의 부분 집합
- **O(N!)**: 크기가 N인 순열
  
&lt;br&gt;
**대략 1억 = 1초**(2000*s* 컴)
&lt;br&gt;
  
**1 초**가 걸리는 **입력의 크기**
- ~~**O(1)**~~
- ~~**O(logN)**~~
- **O(N)** = &lt;span style=&quot;color:red&quot;&gt;**1억**&lt;/span&gt;
- **O(NlogN)** = &lt;span style=&quot;color:magenta&quot;&gt;**5백만**&lt;/span&gt;
- **O(N&lt;sup&gt;2&lt;/sup&gt;)** = &lt;span style=&quot;color:steelblue&quot;&gt;**1만**&lt;/span&gt;
- **O(N&lt;sup&gt;3&lt;/sup&gt;)** = &lt;span style=&quot;color:navy&quot;&gt;**500**&lt;/span&gt;
- **O(2&lt;sup&gt;N&lt;/sup&gt;)** = &lt;span style=&quot;color:firebrick&quot;&gt;**20**&lt;/span&gt; (2&lt;sup&gt;20&lt;/sup&gt; = 1048576)
- **O(N!)** = &lt;span style=&quot;color:red&quot;&gt;**10**&lt;/span&gt; (10! 단 10개만 넣어도.. 1초)  
&lt;img src=&quot;img1.jpeg&quot; width=&quot;50%&quot;&gt;</content><author><name>Dong-Heyon Yang</name><email>markyang920413@gmail.com</email></author><category term="[&quot;algorithm&quot;]" /></entry><entry><title type="html">리눅스 파일 시스템 구조, inode, mount 명령, fdisk로 파티션 생성, mkfs mke2fs 파일 시스템 생성</title><link href="https://markyang920413.github.io//linux-filesystem/linux-linux_filesystem-filesystem_architecture/" rel="alternate" type="text/html" title="리눅스 파일 시스템 구조, inode, mount 명령, fdisk로 파티션 생성, mkfs mke2fs 파일 시스템 생성" /><published>2021-02-27T00:00:00+09:00</published><updated>2021-02-27T00:00:00+09:00</updated><id>https://markyang920413.github.io//linux-filesystem/linux-linux_filesystem-filesystem_architecture</id><content type="html" xml:base="https://markyang920413.github.io//linux-filesystem/linux-linux_filesystem-filesystem_architecture/">## 리눅스 파일 시스템 구조
- 파일은 ***inode***로 관리한다.
- 디렉터리는 단순히 파일의 목록을 가지고 있는 파일일 뿐이다.
- 특수 파일을 통해 장치에 접근할 수 있다.

- **ext4 파일 시스템의 구조**
	- ext4 파일 시스템은 `효율적으로 디스크를 사용하기 위해` 저장 장치를 `논리적인 블록의 집합(블록 그룹)`으로 `구분`한다.
	- 일반적으로 **블록은 4KB**이고 실제 크기는 시스템의 설정에 따라 달라질 수 있다.  
	&lt;img src=&quot;img1.jpeg&quot; width=&quot;70%&quot;&gt;

- **블록 그룹 0**: 파일 시스템의 ***첫 번째 블록 그룹***으로 특별하게 `그룹 0 패딩`과 `수퍼블록, 그룹 디스크립터`를 가지고 있다.  
	- **그룹 0 패딩**: 블록 그룹 0의 첫 1024Byte는 특별한 용도로 사용, ***x86 부트 섹터와 부가 정보 저장***
	- **수퍼블록**: 파일 시스템에 대한 다양한 정보가 저장된다.
		- 전체 inode 개수, 할당되지 않은 블록(free block) 개수, 첫 번째 데이터 블록의 주소, 그룹당 블록의 개수,&lt;br&gt;파일 시스템의 생태, 전체 블록의 개수, 할당되지 않은 inode(free inode)개수, 블록의 크기, 마운트 시간,&lt;br&gt; 그룹 디스크립터의 크기
		- 수퍼 블록에 문제가 생길 경우 전체 파일 시스템을 사용할 수 없게된다. 따라서 수퍼 블록을 다른 블록 그룹에 복사하고, 블록 그룹 0의 수퍼블록을 읽을 수 없는 경우 복사본을 사용하여 복구한다.
	- **그룹 디스크립터**
		- 블록 비트맵의 주소, inode 비트맵의 주소, inode 테이블의 주소, 할당되지 않은 블록의 개수, 할당되지 않은 inode의 개수, 디렉터리의 개수, 블록 비트맵, inode 비트맵 체크섬
		- 이 것도 copy되어 블록 그룹0이 문제가 있을 때 복구하는 데 사용된다.
	- **GDT 예약 블록**
		- 그룹 디스크립터의 확장을 위한 예비공간
	- **데이터 블록 비트맵**
		- 블록 그룹에 포함된 데이터 블록의 사용 여부 확인하는데 사용됨
	- **inode 비트맵**
		- inode 테이블의 항목(inode)가 사용 중인지를 표시한다.
		- 비트맵에서 각 데이터 블록과 inode 테이블 항목은 1bit로 표시한다.
	- **inode 테이블**
		- inode에 파일 정보를 저장한다.
	- `데이터 블록`
		- `실제 데이터`가 저장된다.
		- 일반적인 파일: 데이터 블록에 실제 파일 내용 저장
		- 디렉터리: 해당 디렉터리에 있는 파일이나 서브 디렉터리의 이름과 inode를 저장한다.
  
&lt;img src=&quot;img2.jpg&quot; width=&quot;70%&quot;&gt;
- **블록 그룹 a**: 그룹 0 패딩이 없지만 수퍼블록과 그룹 디스크립터에 대한 복사본을 가지고 있다.
- **블록 그룹 b**: 데이터 블록 비트맵 ~ 데이터 블록 copy본

## inode 구조
&lt;img src=&quot;img3.jpg&quot;&gt;
- inode는 `파일 정보 저장 부분`, `데이터 블록`&lt;sub&gt;(파일 내용 실제 저장)&lt;/sub&gt; `주소 저장` 부분 나뉨
- **데이터 블록 주소 저장**
	- 직접 블록(direct block): 데이터 블록에 대한 주소를 '직접 가지고 있음'
	- 간접 블록(indirect block): 데이터 블록에 대한 주소를 가지고 있는 블록에 대한 주소를 저장한다.
	- 이중 간접 블록(double indirect block)
	- 데이터 블록의 크기는 시스템 설정에 따라 ***1KB ~ 8KB***까지 정의

## 파일 시스템과 디렉터리 계층 구조
  
&lt;img src=&quot;img4.jpeg&quot; width=&quot;40%&quot;&gt;
1. 한 파일 시스템으로 구성하기
  
&lt;img src=&quot;img5.jpeg&quot; width=&quot;40%&quot;&gt;
2. 여러 파일 시스템으로 구성하기
	- 파일 시스템1: **/** 디렉터리에 연결
	- 파일 시스템2: **/usr** 디렉터리에 연결
	- 파일 시스템3: **/home** 디렉터리에 연결
	- 윈도우에서 파티션 C, D로 나누는 것과 유사

## 파일 시스템 마운트
- 파일 시스템이 디렉터리 계층 구조와 연결되지 않으면 사용자가 해당 파일 시스템에 접근할 수 없다.
- 파일 시스템을 디렉터리 계층 구조의 특정 디렉터리와 연결하는 것을 `마운트`라고 한다.

- **마운트 포인트**
	- 디렉터리 계층 구조에서 `파일 시스템이 연결되는 디렉터리`를 `마운트 포인트`라고 한다.
- **파일 시스템 마운트 설정 파일**
	- 리눅스에서 `자동으로 파일 시스템 마운트` 하려면 ***/etc/fstab*** 파일에 설정해야한다.
- **/etc/fstab** 파일의 구조
	- /etc/fstab 파일은 아래와 같이 여섯 항목으로 구성되어 있다.
		- **장치명**
		- **마운트 포인트**
		- **파일 시스템의 종류**
		- **옵션**
		- **덤프 관련 설정**
		- **파일 점검 옵션**
 
&lt;img src=&quot;img6.jpg&quot;&gt;
- 장치명
	- /etc/fstab 파일의 첫 번째 항목에는 파일 시스템 장치명을 설정한다.
	- 예를들어 /dev/hda1, /dev/sda1과 같이 특정 디스크를 지정하는 것이다.
	- UUID(Universally unique identifier), 로컬 시스템과 다른 시스템에서 파일 시스템을 유일하게 구분해주는 128비트 숫자
		- UUID는 시스템의 HW 정보와 시간 정보를 조합하여 랜덤으로 생성된다.
		- 디스크가 추가될 때 부트 로더를 가지고 있는 부트 장치의 이름이 바뀌는 것을 방지하기 위해 사용된다.
		- UUID로 지정된 장치는 `/dev/disk/by-uuid` 디렉터리에서 찾을 수 있다.
		```c
		$ ls -l /dev/disk/by-uuid
		합계 0
		lrwxrwxrwx	1	root	root	10	2월 22	10:30	0c662594-1f44-4da5-a063-fe4da3219ad1 -&gt; ../../sda5
		lrwxrwxrwx	1	root	root	10	2월 22	10:30	4c270aab-6780-4f53-87a9-b8824b6d8b50 -&gt; ../../sda1
		```
		UUID로 지정한 부트 장치가 /dev/sda1 장치의 심볼릭 링크임을 알 수 있다. (**/**는 **/dev/sda1**의 `심볼릭 링크`)
- 마운트 포인트
	- 어디에 마운트 시킬 것인가?
- 파일 시스템의 종류
	- ext2, ext3, ext4외에 [**지원 파일 시스템**](https://markyang920413.github.io/linux-filesystem/linux-linux_filesystem-filesystem/#%EB%A6%AC%EB%88%85%EC%8A%A4-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C) 사용 가능
- 옵션
	- 파일 시스템의 속성 지정
	  
	**속성**|**의미**
	***defaults***|일반적인 파일 시스템에서 지정하는 속성. rw, nouser, auto, exec, suid 속성을 모두 포함한다.
	***auto***|부팅 시 자동으로 마운트 된다.
	***exec***|실행 파일이 실행되는 것을 허용한다.
	***suid***|setuid, setgid의 사용을 허용한다.
	***ro***|읽기 전용 파일 시스템
	***rw***|읽기, 쓰기가 가능한 파일 시스템
	***user***|일반 사용자도 마운트가 가능하다.
	***nouser***|일반 사용자의 마운트가 불가능하다. root 계정만 마운트할 수 있다.
	***noauto***|부팅 시 자동으로 마운트하지 않는다.
	***noexec***|실행 파일이 실행되는 것을 허용하지 않는다.
	***nosuid***|setuid, setgid의 사용을 금한다.
	***usrquota***|사용자별로 디스크 쿼터 설정이 가능하다.
	***grpquota***|그룹별로 디스크 쿼터 설정이 가능하다.
	
	***errors=remount-ro***는 &lt;span style=&quot;color:red&quot;&gt;**오류 발생 시, 읽기 전용으로 다시 마운트**&lt;/span&gt;해라
  
- 덤프 관련 설정
	- **0/1** 을 설정한다. 
	- **0**: dump 명령으로 파일 시스템의 내용이 덤프되지 않는 파일 시스템
	- **1**: 데이터 백업 등을 위해 dump명령의 사용이 가능한 파일 시스템
- 파일 점검 옵션
	- **0/1/2** 지정한다.
	- **0**: 부팅 시, fsck 명령으로 파일 시스템을 점검하지 않도록 하는 설정
	- **1**: 부팅 시, fsck 명령으로 루트 파일 시스템 점검
	- **2**: 부팅 시, fsck 명령으로 루트 파일 시스템 이외의 파일 시스템 점검

	여기 옵션이 1이므로, 루트 파일 시스템으로 부팅할 때 파일 시스템을 점검해야함

## mount: 마운트 명령
  
&lt;img src=&quot;img7.jpg&quot;&gt;

- **mount 명령만 사용하는 경우**
	- 현재 마운트되어 있는 정보가 출력된다.  
	&lt;img src=&quot;img8.png&quot;&gt;
	- **/etc/mtab** 파일 내용과 동일하다.
		- 현재 시스템에 마운트된 파일 시스템에 대한 정보가 저장되어 있다.
		- **/proc/mounts**에 대한 심볼릭 링크로서, 읽기 전용 파일이다.
		- 여기도 **/etc/fstab** 처럼 구조로 이루어져있다.
		- \&lt;장치명\&gt; \&lt;마운트 포인트\&gt; \&lt;파일 시스템 종류\&gt; \&lt;마운트 옵션\&gt; \&lt;사용하지 않는 항목 두개 0 0\&gt;
			- 마지막 사용하지 않는 항목 두 개는 /etc/fstab과 호환성을 위해 추가한 것
&lt;br&gt;&lt;br&gt; 
- **mount 명령으로 장치를 연결하는 방법**  
```c
$ mount /dev/sdb1 /mnt
```
	- **/dev/sdb** 장치이고 **1**이 파티션 번호
	- /mnt 가 장치의 마운트 포인트

- **다양한 mount 명령의 예**
  
	**장치**|**mount 명령**
	**ext2**|mount -t ext2 /dev/sdb1 /mnt
	**ext3**|mount -t ext3 /dev/sdb1 /mnt
	**ext4**|mount -t ext4 /dev/sdb1 /mnt&lt;br&gt;mount /dev/sdb1 /mnt
	**CD-ROM**|mount -t iso9660 /dev/cdrom /mnt/cdrom
	**윈도 디스크**|mount -t vfat /dev/hdc /mnt
	**USB 메모리**|mount /dev/sdc1 /mnt (리눅스용 USB 메모리)&lt;br&gt;mount -t vfat /dev/sdc1 /mnt(윈도우용 USB 메모리)
	**읽기 전용 마운트**|mount -r /dev/sdb1 /mnt
	**읽기/쓰기 마운트**|mount -w /dev/sdb1 /mnt
	**원격 디스크 마운트**|mount -t nfs 서버주소:/NFA 서버측 디렉터리 /mnt
  
### USB 메모리 연결하기
---
- 기존에 사용하던 USB 메모리면 자동으로 디렉터리에 마운트될 수 있다.&lt;br&gt;mount명령을 실행해보면 `마지막`에 장치가 추가되어 있음을 확인할 수 있다.  
```c
$ mount
(생략)
/dev/sdb1 on /media/user1/5255-B26B type vfat (rw,nosuid,nodev,uid=1000,gid=1000,shortname=mixed,dmask=0077,utf8=1,showexec,flush,uhelper=udisk2)
```

- &lt;span style=&quot;color:red&quot;&gt;**리눅스에서 사용하는 USB 메모리가 아니라면, 마운트 해제하고 파일 시스템 생성 작업**&lt;/span&gt;해야한다.
- **마운트 해제**  
&lt;img src=&quot;img9.jpeg&quot; width=&quot;40%&quot;&gt;
 
#### USB 메모리 파티션 생성
----
- **fdisk -l**(소문자 L)
	- ***fdisk***: 리눅스 시스템에 `연결된 저장 장치의 장치명 확인`
		- fdisk 명령은 하드디스크의 파티션을 나눌 때 사용하는 것으로, root 권한 필요
  
	```c
	$ sudo fdisk -l
	(생략)
	Disk /dev/sdb: 2056 MB, 2056257536 bytes
	16 heads, 32 sectors/track, 7844 cylinders, total 4016128 sectors
	Units = sectors of 1 * 512 = 512 bytes
	Sector size (logical/physical): 512 bytes / 512 bytes
	I/O size (minimum/optimal): 512 bytes / 512 bytes
	Disk identifier: 0x4595dc7f
	
	Device Boot	Start	End	Blocks	Id	System
	/dev/sdb1	32	4016127	2008048	6	FAT16
	```
	- USB 장치 명: /dev/sdb1 확인
  
- **fdisk 로** `새로운 파티션 생성`
	```c
	$ sudo fdisk /dev/sdb

	Command (m for help):	# 여기서 fdisk는 커맨드를 기다린다.
		a	toggle a bootable flag
		b	edit bsd disklabel
		c	toggle the dos compatibility flag
		d	list known partition types
		l	list known partition types
		m	print this menu
		n	add a new partition
		o	create a new empty DOS partition table
		p	print the partition table
		q	quit without saving changes
		s	create a new empty Sun disklabel
		t	change a partition's system id
		u	change display/entry units
		v	verify the partition table
		w	write table to disk and exit
		x	extra functionality (experts only)

	Command (m for help):
	```
- `새로운 파티션`을 생성하려는 것이므로 `n`을 입력한다.
	- **n을 입력하면** 파티션을 `기본(primary) 파티션`으로 할 것인지, `확장(extended) 파티션`으로 할 것인지를 선택한다.
	- 기본 값은 **기본(p) 파티션**이다.
  
	```c
	Command (m for help): n
	Partition type:
		p	primary (1 primary, 0 extended, 3 free)
		e	extended
	Select (default p):
	```
- 다음으로 생성할 `파티션 번호`를 지정한다.
	- 아래와 같이 1번을 선택했는데 `이미 사용중이라면`, USB 메모리가 새것이 아니라 이미 파티션이 생성되어 있다는 뜻이므로 `삭제 후 다시 생성`해야한다.
  
	```c
	Select (default p): p
	Partition number (1-4, default 2): 1
	Partition 1 is already defined. Delete it before re-adding it.

	Command (m for help):
	```
- `d`를 선택하면 `파티션 삭제`
  
	```c
	Command (m for help): d
	Selected partition 1

	Command (m for help):
	```
- 다시 `n` 입력하여 `새로운 파티션`을 생성한다.
	- 파티션 번호: 1
	- 시작 섹터와 마지막 섹터를 지정한다. 특별한 이유가 없는 한 기본 값 사용
  
	```c
	Command (m for help): n
	Partition type:
		p	primary (1 primary, 0 extended, 3 free)
		e	extended
	Select (default p):	# 걍 엔터
	Using default response p
	Partition number (1-4, default 1):	# 걍 엔터
	Using default value 1
	First sector (2048-4016127, default 2048):
	Using default value 2048
	Last sector, +sectors or +sizeK,M,G (2048-4016127, default 4016127):
	Using default value 4016127

	Command (m for help):
	```

- `p`명령을 사용하여 `파티션이 제대로 설정`되었는지 확인
  
	```c
	Command (m for help): p
	
	Disk /dev/sdb: 2056 MB, 205625736 bytes
	16 heads, 32 sectors/track, 7844 cylinders, total 4016128 sectors
	Units = sectors of 1 * 512 = 512 bytes
	Sector size (logical/physical): 512 bytes / 512 bytes
	I/O size (minimum/optimal): 512 bytes / 512 bytes
	Disk identifier: 0x4595dc7f

	Device Boot	Start	End	Blocks	Id	System
	/dev/sdb1	2048	4016127	2007040	83	Linux

	Command (m for help)
	```

- `w`를 입력하여 `파티션 설정 정보를 파티션 테이블에 기록`한다.
	- 파티션 테이블에 기록되면 이전에 있던 정보는 없어진다.
	- 이제 USB메모리에 파티션이 생성되었다.
  
	```c
	Command (m for help): w
	The partition table has been altered!

	Calling ioctl() to re-read partition table.

	WARNING: Re-reading the partition table failed with error 16: 장치나 자원이 동작 중.
	The kernel still uses the old table. The new table will be used at
	the next reboot or after you run partprobe(8) or kpartx(8)
	Syncing disks.
	```
  
- `생성한 파티션을 포맷`하여 `파일 시스템 생성`
	- 파티션을 만든 후에 바로 USB메모리에 파일을 저장할 수 없다.
	- 먼저 포맷을 통해 파일 시스템을 생성해야 한다.
	- **파일 시스템을 생성**하는 데는 `mke2fs` 명령을 사용
  
	```c
	$ sudo mke2fs -t ext4 /dev/sdb1
	mke2fs 1.42.8 (20-Jun-2013)
	Filesystem label=
	OS type: Linux
	.....(생략)
	```

- `마운트` 한다.
  
	```c
	$ sudo mount /dev/sdb1 /mnt 	# 마운트!

	$ mount			# 마운트 확인
	..(생략)..
	/dev/sdb1 on /mnt type ext4 (rw)
	```

- `장치 해제`
  
	&lt;img src=&quot;img10.jpeg&quot;&gt;
  
### CD-ROM 연결
---
- CD-ROM 장치를 USB로 연결하여 리눅스 시스템에 인식시킨다.
- CD-ROM을 마운트한다. CD-ROM의 장치명은 기본적으로 `/dev/cdrom`을 사용한다.
- 파일 시스템 종류는 `iso9660`이며, 기본적으로 읽기 전용으로 마운트된다.
  
	```c
	$ sudo mount -t iso9660 /dev/cdrom /mnt
	mount: block device /dev/sr0 is write-protected, mounting read-only
	$ ls -l /dev/cdrom
	lrwxrwxrwx	1	root	root	3	2월 22 10:30 /dev/cdrom -&gt; sr0
	```
- 메시지에 /sr0로 표시 된 것은 /dev/cdrom이 /sr0에 대한 심벌릭 링크

## 디스크 추가 설치
- HDD를 추가 장착 해보자!
- **새 디스크 장착 -&gt; 디스크 파티션 나눔 -&gt; 포맷 -&gt; 마운트**

- 디바이스 인터페이스
	- **IDE, SATA, SCSI**
		- **SCSI**: 서버급 장치
	- 현재 가상머신에서 현재 디스크는 &lt;span style=&quot;color:steelblue&quot;&gt;**SCSI 0번 컨트롤러**&lt;/span&gt;의 &lt;span style=&quot;color:magenta&quot;&gt;**첫 번째 슬롯**&lt;/span&gt;에 연결 (**SCSI** &lt;span style=&quot;color:steelblue&quot;&gt;**0**&lt;/span&gt;**:**&lt;span style=&quot;color:magenta&quot;&gt;**0**&lt;/span&gt;), CD-ROM은 SATA에 연결
	&lt;img src=&quot;img11.jpg&quot;&gt;
	- 여기서 SCSI 디스크 세개 추가
	&lt;img src=&quot;img12.png&quot;&gt;

### 디스크 파티션 나누기
---
- 새로운 디스크 장착이 완료되었으므로 이제 디스크의 **파티션을 생성**해야한다.
	- 디스크 하나를 하나의 파티션으로 사용할 수도 있고, 여러 개의 파티션으로 나눌 수도 있다.
  
#### 디스크 장치 이름
  
- IDE 컨트롤러: `/dev/hd`XXX
- SCSI/SATA : `/dev/sd`XXX
	- 최근 추세는 구분 없이 /dev/sdXXX 로 넣는 추세
- `sd`**a**(첫 번째), `sd`**b**(두 번째) ...
	- **sda0** 첫 번째 디스크의 첫째 파티션
	- **sda1** 첫 번째 디스크의 두번째 파티션

## fdisk명령
**fdisk**: 디스크의 파티션 생성
  
```c
$ fdisk [option] 장치명

option:
	-b &lt;크기&gt;	: 섹터 크기를 지정한다(512, 1024, 2048, 4096).
	-l		: 파티션 테이블을 출력한다.

사용 예:
	fdisk /dev/sdb
	fdisk -l
```
  
**fdisk 내부 명령**
  
**내부 명령**|**기능**
***a***|부팅 파티션 설정
***b***|BSD 디스크 라벨을 편집
***c***|도스 호환성 설정
***d***|파티션 삭제
***l(소문자 L)***|사용 가능한 파티션의 종류 출력
***m***|도움말을 출력
***n***|새로운 파티션 추가
***o***|새로운 빈 DOS 파티션 생성
***p***|파티션 테이블 출력
***q***|작업 내용을 저장하지 않고 출력한다.
***s***|새로운 빈 Sun 디스크 라벨을 출력한다.
***t***|파티션의 시스템 ID를 변경한다(**파일 시스템 종류 변경**).
***u***|항목 정보를 변경/출력 한다.
***v***|파티션 테이블을 검사한다.
***w***|파티션 정보를 디스크에 저장하고 종료한다.
***x***|실린더 갯수 변경 등 정문가를 위한 부가적 기능이다.

### fdisk로 파티션 정보보기
---
- ***fdisk -l***(소문자 L)을 사용하면 **전체 디스크의 파티션 정보**를 볼 수 있다.
	- 현재 시스템에 장착된 디스크의 정보를 확인하면, 아래와 같다.  
	&lt;img src=&quot;img13.png&quot; width=&quot;60%&quot;&gt;

### fdisk로 파티션 나누기
---
- ***fdisk***명령 실행한다.  
  
```c
$ sudo fdisk /dev/sdb		# sdb 디바이스를 파티션 나눌 것이다.
Device contains neither a valid DOS partition table, nor Sun, SGI or OSF
disklabel
Building a new DOS disklabel with disk identifier 0x2fa4c807.
Changes will remain in memory only, until you decide to write them.
After that, of course, the previous content won't be recoverable.

Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)

Command (m for help):
```

- 새로운 파티션을 생성한다. `새로운 파티션을 생성`하기 위해서는 `n`을 입력해야 한다.  
n을 입력하면 파티션의 종류를 선택하는 메뉴가 출력된다.
  
```c
Command (m for help): n
Partition type:
	p	primay (0 primary, 0 extended, 4 free)
	e	extended
Select (default p):
```
  
- 파티션의 종류를 선택한다. 파티션은 `기본 파티션`과 `확장 파티션`이 있는데,   
기본 파티션을 선택하면 **파티션의 번호를 선택**하는 **메뉴가 출력**된다.
  
```c
Select (default p): p
Partition number (1-4, default 1):
```

- 첫 번째 파티션이므로 1을 선택한다.  
파티션 번호를 입력하면 `용량` 설정하기 위한 메뉴가 출력된다.
  
```c
Partition number (1-4, default 1): 1
First sector (2048-2097151, default 2048):
```

- 파티션의 `크기`를 설정한다.  
시작 섹터는 기본 값을 사용하고, 마지막 섹터를 설정하는 메뉴에서는 크기를 500MB로 할 것이므로 +500M를 입력한다.  
이제 파티션의 정보가 설정되었다.
  
```c
First sector (2048-2097151, default 2048):
Using default value 2048
Last sector, +sectors or +sizeK,M,G (2048-2097151, default 2097151): +500M

Command (m for help):
```

- 파티션 `설정 정보`를 확인한다.
`p`를 입력하면 **현재 설정된 파티션의 정보**가 출력되는데, `/dev/sdb1`이 설정되었음을 알 수 있다.
  
```c
Command (m for help): p

Disk /dev/sdb: 1073MB, 10737741824 bytes
255 heads, 63 sectors/track, 130 cylinders, total 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x2fa4c807

Device Boot	Start	End	Blocks	Id	System
/dev/sdb1	2048	1026047	512000	83	Linux

Command (m for help):
```
  
- **n**을 선택하면 두 번째 파티션을 생성한다.  
1번 파티션과 동일하게 기본 파티션(p), 파티션 번호는 2, 용량은 +500M으로 한다.
  
```c
Command (m for help): n
Partition type:
	p	primary (1 primary, 0 extended, 3 free)
	e	extended
Select (default p): p
Partition number (1-4, default 2):
Using default value 2
First sector (1026048-2097151, default 1026048):
Using default value 1026048
Last sector, +sectors or +sizeK,M,G (1026048-2097151, default 2097151): +500M

Command (m for help):
``` 

- 파티션 설정 정보를 확인한다.  
**p**를 입력하면 현재 설정된 파티션의 정보가 출력되는데 /dev/sdb1과 /dev/sdb2가 모두 설정 되었음을 알 수 있다).
  
```c
Command (m for help): p

Disk /dev/sdb: 1073MB, 10737741824 bytes
255 heads, 63 sectors/track, 130 cylinders, total 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x2fa4c807

Device Boot	Start	End	Blocks	Id	System
/dev/sdb1	2048	1026047	512000	83	Linux
/dev/sdb2	1026048	2050047	512000	83	Linux

Command (m for help):
```

- `w`를 입력하면 `파티션 설정 정보를 디스크에 기록`하고 fdisk를 종료한다. 
  
```c
Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disk.
```

디스크 파티션 작업이 끝나면 파티션에 **파일 시스템**을 생성해야한다.

## mkfs, mke2fs 파일 시스템 생성
- 리눅스에서 파일 시스템을 생성할 때 사용하는 명령은 `mkfs`와 `mke2fs`가 있다.
  
```c
$ mkfs [option] 장치명

option:
	-t &lt;종류&gt;	: 파일 시스템의 종류를 지정한다(기본 값은 ext2).

사용 예:
	mkfs /dev/sdb1
	mkfs -t ext4 /dev/sdb1
```
- `mkfs` : 리눅스 파일 시스템을 만든다.

```c
$ mke2fs [option] 장치명

option:
	-t &lt;종류&gt;		: 파일 시스템의 종류를 지정한다. 기본 값은 ext2이다.
	-b &lt;블록 크기&gt;		: 블록 크기를 바이트 수로 지정한다.
	-c			: 배드 블록을 체크한다.
	-f &lt;프래그먼트 크기&gt;	: 프래그먼트 크기를 바이트 수로 지정한다.
	-i &lt;inode당 바이트 수&gt;	: inode당 바이트 수를 지정한다. 기본 값은 4,096byte.
	-m &lt;예약 블록 퍼센트&gt;	: 슈퍼유저에게 예약해둘 블록의 퍼센트를 지정한다. 기본 값은 5이다.

사용 예:
	mke2fs /dev/sdb1
	mke2fs -t ext4 /dev/sdb1
```
- `mke2fs` : 리눅스 개정판 확장 파일 시스템(ext2, ext3, ext4)를 만든다.  
mke2fs명령은 **별도의 설정 파일**이 있다. 이는 **/etc/mke2fs.conf** 파일로 **파일 시스템의 종류**에 따라 **기본적으로 설정할 값들을 정의**하고 있다.
  
```c
$ cat /etc/mke2fs.conf
[defaults]
        base_features = sparse_super,large_file,filetype,resize_inode,dir_index,ext_attr
        default_mntopts = acl,user_xattr
        enable_periodic_fsck = 0
        blocksize = 4096
        inode_size = 256
        inode_ratio = 16384

[fs_types]
        ext3 = {
                features = has_journal
        }
        ext4 = {
                features = has_journal,extent,huge_file,flex_bg,metadata_csum,64bit,dir_nlink,extra_isize
                inode_size = 256
        }
        small = {
                inode_size = 128
                inode_ratio = 4096
        }
        floppy = {
                inode_size = 128
                inode_ratio = 8192
        }
        big = {
                inode_ratio = 32768
        }
        huge = {
                inode_ratio = 65536
        }
        news = {
                inode_ratio = 4096
        }
        largefile = {
                inode_ratio = 1048576
                blocksize = -1
        }
        largefile4 = {
                inode_ratio = 4194304
                blocksize = -1
        }
        hurd = {
             blocksize = 4096
             inode_size = 128
        }

[options]
        fname_encoding = utf8
``` 

- **mkfs, mke2fs** 명령은 `/sbin` 디렉터리에 있다.
	- 여기서 **mkfs.ext3** 명령은 **mkfs -t ext3** 명령과 동일하다.
  
```c
$ ls /sbin/mk*
/sbin/mkdosfs      /sbin/mkfs.ext2   /sbin/mkfs.minix  /sbin/mkhomedir_helper  /sbin/mkswap
/sbin/mke2fs       /sbin/mkfs.ext3   /sbin/mkfs.msdos  /sbin/mkinitramfs
/sbin/mkfs         /sbin/mkfs.ext4   /sbin/mkfs.ntfs   /sbin/mklost+found
/sbin/mkfs.bfs     /sbin/mkfs.fat    /sbin/mkfs.ubifs  /sbin/mkntfs
/sbin/mkfs.cramfs  /sbin/mkfs.jffs2  /sbin/mkfs.vfat   /sbin/mksmbpasswd
```

### mkfs 명령으로 파일 시스템 생성
---
- `mkfs` 명령으로 /dev/sdb 파티션에 파일 시스템을 생성한다.
  
&lt;img src=&quot;img14.jpg&quot;&gt;
- **mkfs**명령으로 파일 시스템을 만들 때 출력되는 정보를 볼 수있다.
- 블록의 크기, inode의 개수, 블록의 개수, 블록 그룹의 개수, 그룹당 블록과 inode의 개수, 수퍼블록의 백업 위치 등 정보

이제 `mount`만 하면 **바로 사용할 수 있다.**

- mkfs.ext3 명령을 /dev/sdb2 파티션에 ext3 파일 시스템을 생성한다.
	- **mkfs.ext3 = mkfs -t ext3**
  
```c
$ sudo mkfs.ext3 /dev/sdb2
mke2fs 1.42.8 (20-Jun-2013)
Filesystem label=
OS type: Linux
Block size=1024 (log=0)
Fragment size=1024 (log=0)
Stride=0 blocks, Stripe width=0 blocks
128016 inodes, 512000 blocks
25600 blocks (5.00%) reserved for the super user
First data block=1
Maximum filesystem blocks=67633152
63 block groups
8192 blocks per group, 8192 fragments per group
2032 inodes per group
Superblock backups stored on blocks:
	8193, 24577, 40961, 57345, 73729, 204801, 221185, 401409

Allocating group tables: done
Writing inode tables: done
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done

$
```
- 위 메시지를 살펴보면, ext2와 ext3의 차이가 **저널링**기능임을 살펴볼 수 있다.
	- ext3 파일 시스템을 생성하는 과정의 끝부분에 저널을 저장하는 부분을 별도로 생성한다.

## mke2fs 명령으로 파일 시스템 생성하기
- mke2fs 명령으로 /dev/sdc 파티션에 ext3 파일 시스템을 생성해보자.

```c
$ sudo mke2fs -t ext3 /dev/sdc1
mke2fs 1.42.8 (20-Jun-2013)
Filesystem label=
OS type: Linux
Block size=1024 (log=0)
Fragment size=1024 (log=0)
Stride=0 blocks, Stripe width=0 blocks
128016 inodes, 512000 blocks
25600 blocks (5.00%) reserved for the super user
First data block=1
Maximum filesystem blocks=67633152
63 block groups
8192 blocks per gorup, 8192 fragments per group
2032 inodes per group
Superblock backups stored on blocks:
	8193, 24577, 40961, 57345, 73729, 204801, 221185, 401409

Allocating group tables: done
Writing inode tables: done
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done

$
```

- mke2fs 명령으로 /dev/sdc2 파티션에 ext4 파일 시스템을 만든다.
	- 블록 크기를 4096 바이트로 지정한다.
  
```c
$ sudo mke2fs -t ext4 -b 4096 /dev/sdc2
mke2fs 1.42.8 (20-Jun-2013)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
128000 inodes, 128000 blocks
6400 blocks (5.00%) reserved for the super user
First data block=1
Maximum filesystem blocks=1234217728
4 block groups
32768 blocks per gorup, 32768 fragments per group
32000 inodes per group
Superblock backups stored on blocks:
	32768, 98304

Allocating group tables: done
Writing inode tables: done
Creating journal (4096 blocks): done
Writing superblocks and filesystem accounting information: done

$
```

## 디스크 마운트
- 파티션 나누기 -&gt; 파일 시스템 생성 -&gt; **디렉터리 계층 구조에 마운트!**

- **마운트 포인트 준비하기**
   
```c
$ sudo mkdir /mnt/hdd1
```

- **파일 시스템 마운트하기**
	- **/dev/sdb** 디스크의 파일 시스템을 마운트 해보자.
    
```c
$ sudo mount /dev/sdb1 /mnt/hdd1
```</content><author><name>Dong-Heyon Yang</name><email>markyang920413@gmail.com</email></author><category term="[&quot;linux-filesystem&quot;]" /><summary type="html">inode, mount, fdisk(파티션 생성), mkfs, mke2fs(파일 시스템 생성)</summary></entry><entry><title type="html">리눅스 파일 시스템 종류, 지원하는 파일 시스템 확인,스왑 파티션 관리</title><link href="https://markyang920413.github.io//linux-filesystem/linux-linux_filesystem-filesystem/" rel="alternate" type="text/html" title="리눅스 파일 시스템 종류, 지원하는 파일 시스템 확인,스왑 파티션 관리" /><published>2021-02-25T00:00:00+09:00</published><updated>2021-02-25T00:00:00+09:00</updated><id>https://markyang920413.github.io//linux-filesystem/linux-linux_filesystem-filesystem</id><content type="html" xml:base="https://markyang920413.github.io//linux-filesystem/linux-linux_filesystem-filesystem/">## 리눅스 파일 시스템
1. **ext(ext1)**, Extended File System, extfs
- 1992년 4월 리눅스 0.96c 발표
- 파일 시스템 최대 크기: 2GB
- 파일 이름 길이: 255Byte
2. **ext2**
- 1993년 1월 발표
- 리눅스 커널 2.6.17이전 파일 시스템 최대 크기: 2TB
- 현재 파일 시스템 최대 크기: 32TB
- 현재도 부팅 가능한 USB flash, SSD 사용
3. **ext3**
- 2001년 11월 리눅스 2.4.15에 추가
- ext2 파일을 별도 변경없이 `이식가능`
- 2~32TB
- &lt;span style=&quot;color:red&quot;&gt;**journaling**&lt;/span&gt;: 데이터의 `복구 기능`강화
		- 디스크 기록 전 `먼저 저널에` 수정 사항 `기록`
		- 기록 전에 갑자기 전원 나가거나 충돌 시, 이 저널의 기록을 보고 재빨리 복구
- 단점
		- inode 동적 할당이나 다양한 블록 크기와 같은 최신 파일 시스템 기능이 부족
		- 온라인 조각 모음 기능이 없다.
4. **ext4**
- 2008년 12월 25일 리눅스 커널 2.6.28에 포함되어 공개
- 1EB이상의 볼륨과 16TB 이상의 파일 지원, &lt;span style=&quot;color:red&quot;&gt;**ext2, ext3 호환**&lt;/span&gt;
 
&lt;br&gt;
- **다른 기타 파일 시스템**
  
**파일 시스템**|**기능**
**msdos**|MS-DOS 파티션을 사용하기 위한 파일 시스템
**iso9660**|CD-ROM, DVD의 표준 파일 시스템, 읽기 전용으로 사용
**nfs**|Network File System으로 원격 서버의 디스크를 연결할 때 사용
**ufs**|Unix File System으로 유닉스의 표준 파일 시스템
**vfat**|윈도 95, 98, NT를 지원하기 위한 파일 시스템
**hpfs**|HPFS를 지원하기 위한 파일 시스템
**ntfs**|윈도의 NTFS를 지원하기 위한 파일 시스템
**sysv**|유닉스 시스템 V를 지원하기 위한 파일 시스템
**hfs**|맥의 hfs 파일 시스템을 지원하기 위한 파일 시스템
  
&lt;br&gt;
  
- **특수 용도의 가상 파일 시스템**
	- 디스크가 아니라 `메모리에서 생성`되어 사용하는 `가상 파일 시스템`
		- 생겼다 없어졌다.
  
**파일시스템**|**기능**
**swap**|스왑영역을 관리하기 위한 스왑 파일 시스템
**tmpfs**|**Temporary File System**으로 `메모리에 임시 파일`저장 위한 파일 시스템&lt;br&gt;재부팅 시 기존 내용 없어진다.&lt;br&gt;**/run**
**proc**|`커널의 현재 상태`를 나타내는 파일 가지고 있음&lt;br&gt;proc 파일 시스템&lt;br&gt;**/proc**
**ramfs**|램 디스크를 지원하는 파일 시스템
**rootfs**|**/** 루트 파일 시스템
  
## 시스템 지원 파일 시스템 확인
- `/proc/filesystems` 파일 내용에서 현재 커널이 지원하는 파일 시스템 종류 알려줌  
&lt;img src=&quot;img1.png&quot; width=&quot;50%&quot;&gt;
	- &lt;span style=&quot;color:red&quot;&gt;**nodev**&lt;/span&gt;은 해당 파일 시스템이 `블록 장치(예: 디스크)`에 `연결되어 있지 않다.` = `가상 파일 시스템`

## 스왑 파티션 관리
- 스왑 파티션: **스왑**으로 쓰기위한 디스크의 파티션을 일부 `스왑 파티션`으로 둠
  
### 현재 스왑 영역 확인
  
```c
$ swapon -s
```
&lt;img src=&quot;img2.png&quot;&gt;  
  
### 새로운 디스크 파티션을 스왑 영역으로 추가
- fdisk 명령으로 디스크에 `스왑 파티션을 생성`한다.
```c
$ sudo fdisk /dev/sdd
```
- mkswap 명령으로 스왑 파티션을 `포맷`하여 스왑 파일 시스템을 생성한다.  
```c
$ sudo mkswap /dev/sdd1
```
- 스왑 파티션을 `활성화`한다.
```c
$ sudo swapon /dev/sdd1
```
- 스왑 영역이 추가되었는지 확인
```c
$ swapon -s
Filename	Type		Size		Used		Priority
/dev/sda5	partition	1046524		7284		-1
/dev/sdd1	partition	307196		0		-2
```
- 재부팅 시에도 새 스왑 영역을 활성화하려면 `/etc/fstab` 파일에 정보를 추가한다.
```c
/dev/sdd1 swap swap defaults 0 0
```
  
### 기존 파티션에 스왑 파일 추가하기
- 생성할 스왑 파일의 크기를 정한 후, `1024 X 블록 개수`를 산정한다.  
	- 128MB = 1024 x 131,072 
- 빈 파일을 dd 명령으로 생성한다. count 다음에는 위에서 계산한 블록 개수를 지정한다.  
```c
$ sudo dd if=/dev/zero of=/swapfile bs=1024 count=131072
```
- mkswap 명령으로 위에서 생성한 파일을 스왑 파일로 만든다.
```c
$ sudo mkswap /swapfile
```
- 스왑 파일을 활성화한다.
```c
$ sudo swapon /swapfile
```
- 스왑 파일이 추가되어있는지 확인한다.
```c
$ swapon -s
Filename	Type		Size		Used		Priority
/dev/sda5	partition	1046524		11520		-1
/dev/sdd1	partition	307196		0		-2
/swapfile	file		131068		0		-3
```
- 재부팅 시에도 새 스왑 영역을 활성화하려면 /etc/fstab 파일에 정보를 추가한다.
```c
/swapfile swap swap defaults 0 0
```</content><author><name>Dong-Heyon Yang</name><email>markyang920413@gmail.com</email></author><category term="[&quot;linux-filesystem&quot;]" /></entry><entry><title type="html">프로세스 종류, ps 명령, kill, top, jobs, 작업 전환하기(bg, fg), nohup</title><link href="https://markyang920413.github.io//process/system_programming-process-process/" rel="alternate" type="text/html" title="프로세스 종류, ps 명령, kill, top, jobs, 작업 전환하기(bg, fg), nohup" /><published>2021-02-24T00:00:00+09:00</published><updated>2021-02-24T00:00:00+09:00</updated><id>https://markyang920413.github.io//process/system_programming-process-process</id><content type="html" xml:base="https://markyang920413.github.io//process/system_programming-process-process/">&lt;h2 id=&quot;프로세스의-종류&quot;&gt;프로세스의 종류&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;daemon&lt;/strong&gt; 프로세스
    &lt;ul&gt;
      &lt;li&gt;특정 &lt;span style=&quot;color:red&quot;&gt;&lt;strong&gt;서비스를 제공하기 위해&lt;/strong&gt;&lt;/span&gt; 존재&lt;/li&gt;
      &lt;li&gt;&lt;span style=&quot;color:magenta&quot;&gt;&lt;strong&gt;커널&lt;/strong&gt;&lt;/span&gt;에 의해 실행&lt;/li&gt;
      &lt;li&gt;평소 &lt;span style=&quot;color:steelblue&quot;&gt;&lt;strong&gt;대기 상태&lt;/strong&gt;&lt;/span&gt; -&amp;gt; &lt;strong&gt;서비스 요청&lt;/strong&gt; -&amp;gt; daemon이 &lt;span style=&quot;color:magenta&quot;&gt;&lt;strong&gt;해당 서비스 제공&lt;/strong&gt;&lt;/span&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;sshd&lt;/strong&gt;: ssh 서버 대몬, 원격 접속 서비스를 제공하기 위해 동작&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;고아&lt;/strong&gt;&lt;sub&gt;(orphan)&lt;/sub&gt; &lt;strong&gt;프로세스&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;부모가 자식보다 먼저 종료되었을 때,
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;&lt;del&gt;부모 프로세스&lt;/del&gt;&lt;/strong&gt;&lt;sub&gt;(killed)&lt;/sub&gt; &lt;span style=&quot;color:firebrick&quot;&gt;&lt;strong&gt;자식 프로세스&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;span style=&quot;color:firebrick&quot;&gt;&lt;strong&gt;자식 프로세스&lt;/strong&gt;&lt;/span&gt;는 &lt;strong&gt;고아&lt;/strong&gt; 프로세스가 된다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;1번&lt;/strong&gt;&lt;sub&gt;(UNIX, Ubuntu: init, Fedora 14: systemd)&lt;/sub&gt; 대몬 프로세스가 이런 고아프로세스 &lt;strong&gt;자원을 회수&lt;/strong&gt;한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;span style=&quot;color:magenta&quot;&gt;&lt;strong&gt;Zombie&lt;/strong&gt;&lt;/span&gt;프로세스
    &lt;ul&gt;
      &lt;li&gt;&lt;span style=&quot;color:firebrick&quot;&gt;&lt;strong&gt;자식 프로세스&lt;/strong&gt;&lt;/span&gt;의 &lt;span style=&quot;color:steelblue&quot;&gt;&lt;strong&gt;자원&lt;/strong&gt;&lt;/span&gt;이 회수 되지 않고 계속 프로세스 테이블에 존재할 때
        &lt;ul&gt;
          &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;&lt;strong&gt;자식이 종료되었는 데도 남아 있을 수 있음!!!&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;defunct&lt;/strong&gt; 프로세스라고 나온다.&lt;/li&gt;
      &lt;li&gt;&lt;span style=&quot;color:magenta&quot;&gt;&lt;strong&gt;kill&lt;/strong&gt;&lt;/span&gt; 명령으로 제거할 수 없다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;해결법&lt;/strong&gt;
        &lt;ol&gt;
          &lt;li&gt;&lt;span style=&quot;color:magenta&quot;&gt;&lt;strong&gt;&lt;em&gt;SIGCHLD&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt; &lt;strong&gt;&lt;em&gt;-&amp;gt; 부모 프로세스&lt;/em&gt;&lt;/strong&gt;로 보내 &lt;span style=&quot;color:firebrick&quot;&gt;&lt;strong&gt;자식프로세스&lt;/strong&gt;&lt;/span&gt; 정리&lt;/li&gt;
          &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;&lt;strong&gt;&lt;em&gt;부모 프로세스 종료&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;span style=&quot;color:firebrick&quot;&gt;&lt;strong&gt;자식 프로세스&lt;/strong&gt;&lt;/span&gt;는 &lt;strong&gt;고아 프로세스&lt;/strong&gt;가 되고 1번 프로세스가 이를 처리&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;pid-0-번은-무슨-프로세스&quot;&gt;PID 0 번은 무슨 프로세스?&lt;/h3&gt;
&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;init 대몬 프로세스의 PID가 1인데 PPID가 0이다. 0번 프로세스는 무엇인가?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swapper&lt;/code&gt;: 프로세스 스케줄링 담당하는 스케줄러 &lt;strong&gt;(0번 프로세스)&lt;/strong&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;CPU가 프로세스를 실행할 수 있도록 메모리에 올렸다가, 할당된 시간이 끝나면 디스크로 잠시 스왑 했다가, 다시 실행할 순서가 되면 다시 메모리에 올리는 일을 한다.&lt;/li&gt;
      &lt;li&gt;스와퍼만이 부팅 과정에서 별도로 실행되어 부모프로세스가 없다. 사실 OS 그자체!!?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;프로세스-관리-명령&quot;&gt;프로세스 관리 명령&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;프로세스 목록 조회:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;option&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;description&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;-e&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;시스템에서 실행 중인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;모든 프로세스&lt;/code&gt;의 정보를 출력한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;-f&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;프로세스의 자세한 정보를 출력한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;-u UID&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;특정 사용자&lt;/code&gt;에 대한 모든 프로세스의 정보를 출력한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;-p PID&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;pid로 지정한 특정 프로세스의 정보를 출력한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;a&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;터미널에서 실행한&lt;/code&gt; 프로세스의 정보를 출력한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;u&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;프로세스 소유자의 이름, CPU Usage, 메모리 사용량 등 상세 정보 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;x&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;시스템에서 실행 중인 모든 프로세스 정보 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;--pid PID&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;지정한 특정 PID의 정보를 출력한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;&lt;strong&gt;&lt;em&gt;UID&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;: 프로세스를 실행한 사용자 ID
&lt;img src=&quot;img1.jpg&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;항목&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;UID&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;프로세스를 실행한 사용자ID&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;PID&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;프로세스 ID&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;PPID&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;이 프로세스의 부모 PID&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;C&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;CPU 사용량(%값)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;STIME&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;프로세스의 시작 날짜나 시간&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TTY&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;프로세스가 실행된 터미널의 종류와 번호&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TIME&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;프로세스 실행 시간&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;CMD&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;실행되고 있는 프로그램의 이름(명령)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;img2.jpg&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;STAT&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;R&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt;unning 실행 중&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;S&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S&lt;/code&gt;leep 상태 (인터럽트가 가능한 대기)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;세션 리더 프로세스&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;T&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;s&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;opped 상태 (작업 제어에 의해 정지)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;Z&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Z&lt;/code&gt;ombie 상태(&lt;strong&gt;&lt;em&gt;defunct&lt;/em&gt;&lt;/strong&gt;)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;STIME&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;프로세스의 시작 날짜나 시간&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;+&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;포 그라운드 프로세스 그룹&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;l&lt;/em&gt;&lt;/strong&gt;(소문자 L)&lt;/td&gt;
      &lt;td&gt;멀티 스레드&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;항목&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;USER&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;사용자 계정 이름&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;%CPU&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;CPU 사용량을 퍼센트로 표시&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;%MEM&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;물리적 메모리 사용량을 퍼센트로 표시&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;VSZ&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;사용하고 있는 &lt;span style=&quot;color:magenta&quot;&gt;&lt;strong&gt;가상&lt;/strong&gt;&lt;/span&gt; 메모리의 크기(KB)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;RSS&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;사용하고 있는 &lt;span style=&quot;color:steelblue&quot;&gt;&lt;strong&gt;물리&lt;/strong&gt;&lt;/span&gt; 메모리 크기(KB)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;START&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;프로세스 시작 시간&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;img3.jpg&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;프로세스-종료하기&quot;&gt;프로세스 종료하기&lt;/h2&gt;
&lt;h3 id=&quot;kill-명령을-이용해-프로세스-종료&quot;&gt;kill 명령을 이용해 프로세스 종료&lt;/h3&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kill&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;시그널&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;번호&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;시그널&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;보낼&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;시그널 번호&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;-2&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;인터럽트 시그널(Ctrl + C)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;-9&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;프로세스 강제 종료 시그널&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;-15&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;프로세스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;관련된 파일 정리하고&lt;/code&gt; 프로세스 종료 시그널.&lt;br /&gt;종료되지 않는 프로세스가 있을 수 있다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;pkill-이용해-프로세스-이름으로-종료&quot;&gt;pkill 이용해 프로세스 이름으로 종료&lt;/h3&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pkill&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;시그널&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;번호&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;시그널&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;보낼&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;프로세스&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;이름&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;top&quot;&gt;top&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;top&lt;/strong&gt;: 현재 실행 중인 프로세스 정보 주기적 출력&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;top의 출력정보&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;항목&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;의미&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;PID&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;프로세스 ID&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;USER&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;사용자 계정(owner)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;PR&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;우선 순위&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;NI&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;Nice 값&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;VIRT&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;프로세스가 사용하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가상 메모리&lt;/code&gt; 크기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;RES&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;프로세스가 사용하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;메모리&lt;/code&gt; 크기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;SHR&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;프로세스가 사용하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;공유 메모리&lt;/code&gt; 크기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;%CPU&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;CPU 사용량&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;%MEM&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;메모리 사용량(%)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;TIME+&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;CPU 누적 이용 시간&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;COMMAND&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;명령 이름&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;img4.png&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;top의 내부 명령&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;의미&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;enter키, space bar&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;갱신&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;h, ?&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;도움말 화면 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;k&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;프로세스를 종료하는데, 종료할 PID 물어봄&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;n&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;출력할 프로세스 개수를 바꾼다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;u&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;User(사용자)로 정렬하여 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;M&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;사용하는 메모리의 크기에 따라 정렬하여 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;p&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;CPU 사용량에 따라 정렬하여 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;q&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;top 명령 종료&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;jobs&quot;&gt;jobs&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;현재 실행 중인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;백그라운드&lt;/code&gt; 작업을 보여준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jobs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;작업번호&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;작업번호&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;번호&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;해당&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;번호의&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;작업&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;정보를&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;출력한다&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;%+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;작업&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;순서가&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;인&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;작업&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;정보를&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;출력한다&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;%-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;작업&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;순서가&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;인&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;작업&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;정보를&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;출력한다&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;사용 예&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;img5.jpg&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;항목&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;예&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;의미&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;작업 번호&lt;/td&gt;
      &lt;td&gt;[1]&lt;/td&gt;
      &lt;td&gt;작업 번호로서 백그라운드로 실행할 때마다 순차적으로 증가한다.&lt;br /&gt;[1], [2], [3]…&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;작업 순서&lt;/td&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;작업 순서를 나타낸다.&lt;br /&gt;&lt;strong&gt;+&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가장 최근&lt;/code&gt;에 접근한 작업&lt;br /&gt;&lt;strong&gt;-&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+ 작업 보다 바로 전&lt;/code&gt;에 접근한 작업&lt;br /&gt;공백: 그 외의 작업&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;상태&lt;/td&gt;
      &lt;td&gt;실행중&lt;/td&gt;
      &lt;td&gt;작업 상태&lt;br /&gt;Running: 현재 실행 중&lt;br /&gt;Done: 완료 됨, 작업이 정상적으로 종료된다.&lt;br /&gt;Terminated: 종료 됨, 작업이 비정상적으로 종료된다.&lt;br /&gt;Stopped: 작업이 잠시 중단된다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;작업-전환하기&quot;&gt;작업 전환하기&lt;/h2&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;작업 전환 명령&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;의미&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;Ctrl + z&lt;/em&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;em&gt;stop [%작업번호]&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;포 그라운드 작업을 중지(종료가 아니라 잠시 중단!!)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;bg [%작업번호]&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;작업 번호가 지시하는 작업을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;백 그라운드로 전환&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;fg [%작업번호]&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;작업 번호가 지시하는 작업을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;포 그라운드로 전환&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;nohup-로그아웃-후에도-백그라운드-작업-계속-실행&quot;&gt;nohup: 로그아웃 후에도 백그라운드 작업 계속 실행&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;로그아웃한 다음에도 작업이 완료될 때까지 백그라운드 작업 실행한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nohup&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;명령&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;nohup로 실행한 명령은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;반드시 백그라운드로&lt;/code&gt; 실행해야 한다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Dong-Heyon Yang</name><email>markyang920413@gmail.com</email></author><category term="[&quot;process&quot;]" /><summary type="html">ps, kill, pkill, top, jobs, Ctrl+z, bg, fg, nohup</summary></entry><entry><title type="html">Samba 셋팅</title><link href="https://markyang920413.github.io//linux-system/linux-linux_system-samba/" rel="alternate" type="text/html" title="Samba 셋팅" /><published>2021-02-20T00:00:00+09:00</published><updated>2021-02-20T00:00:00+09:00</updated><id>https://markyang920413.github.io//linux-system/linux-linux_system-samba</id><content type="html" xml:base="https://markyang920413.github.io//linux-system/linux-linux_system-samba/">## samba
1. Host: Mac OS
2. Remote: Ubuntu 20.04 LTS

## samba install
### samba install(Remote)
--- 
```bash
$ sudo apt install samba
```
- 삼바 계정을 추가하고, 계정에서 접근 가능한 디렉터리를 정한다.
  
```
$ sudo useradd -d [share directory] -m [삼바 계정]
$ sudo useradd -d /home/pllpokko/share -m share_pllpokko
```

- 삼바 계정의 패스워드를 정한다.
  
```bash
$ sudo passwd [삼바 계정]
$ sudo passwd share_pllpokko
```

- 삼바 공유 폴더에 접근할 아이디와 비밀번호를 설정
  
```bash
$ sudo smbpasswd -a [삼바 계정]
$ sudo smbpasswd -a share_pllpokko
```
  
&lt;img src=&quot;img2.jpeg&quot;&gt;
  
- 삼바 공유용 디렉터리 **권한**지정
  
&lt;img src=&quot;img3.png&quot;&gt;

### samba configure 파일 설정
---
  
- 삼바서버 설정을 위한 `/etc/samba/smb.conf` 파일 수정
  
```bash
$ sudo vi /etc/samba/smb.conf

# smb.conf ----아래 맨 마지막 줄에 추가 -------------
[삼바 계정]
 comment = samba directory
 path = /home/pllpokko/share
 writeable = yes
 valid users = pllpokko
-------------------저장 후 종료----------------------
```

&lt;img src=&quot;img1.jpeg&quot;&gt;
  
```bash
$ sudo /etc/init.d/smbd restart
```



- ip 얻기
  
```bash
$ ifconfig
# eth0의 ip 구하기
```

### host side
---
1. finder -&gt; Command + K -&gt; 서버 주소에 `smb://[ip]` 입력</content><author><name>Dong-Heyon Yang</name><email>markyang920413@gmail.com</email></author><category term="[&quot;linux-system&quot;]" /></entry></feed>