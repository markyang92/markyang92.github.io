var store = [{
        "title": "linux directory",
        "excerpt":"linux structure  Directory     FHS(Filesystem Hierarchy Standard)  디렉터리 트리표준 규격 3.0   /bin     부팅할 때 필요한 시스템의 기본 명령어 및 실행파일   /usr/bin            일반 사용자를 위한 명령어 및 실행파일       최근에는 /usr/bin에 심볼릭 링크되어 있어 구별하지 않는 경우도 있다       /bin과/usr/bin은 배포판이 관리하는 디렉터리           /usr/local/bin            사용자가직접 설치하는 파일은 여기에!           /sbin     부팅할 때 필요한 관리자 용 명령어   /usr/sbin            평상 시 사용하는 시스템 관리 명령어, 서버 프로그램           /lib     /lib, /lib64            부팅 시 필요한 라이브러리(libxxx.a, libxxx.so)       C용 외에도 펄, 루피  파이썬 등의 라이브러리 보관       배포판에 따라 /lib, /lib64 사용법이 다르다.                    Ubuntu                            /lib64: 거의 사용하지 않음               /lib/x86_64-linux-gnu 처럼 /lib 디렉터리 밑에 한 단계 디렉터리를 만들어 각종 라이브러리 배치                                   CentOs                            /lib64: 64bit 라이브러리               /lib: 32bit 라이브러리나 아키텍처 독립적인 파일                                                   /usr/local/lib에 직접 설치하는 라이브러리   /usr     /usr의 특징은 여러 컴퓨터에서 공유할 수 있는 파일, 일반 사용자를 위한 파일            공유?                    네트워크 파일 시스템: 대학과 기업 등 구성원들이 사용하는 복수의 머신이 네트워크 파일 시스템을 통해 특정 컴퓨터의 파일 시스템을 네트워크를 통해 마운트하여 사용하는 경우           NFS, SAMBA                            중앙 서버에서 /usr에 필요한 파일을 두고, 복수의 시스템이 원격으로 /usr을 마운트해서 사용하게 한다.               복수의 컴퓨터에서 동일한 프로그램이나 라이브러리를 사용할 수 있다               따라서, /usr 에는 공유할 수 있는 것으로만!               공유할 수 없는 것은 /var 에!                                                   */src     시스템에서 사용되는 명령어의 소스 코드나 리눅스 커널 소스 코드   */include     시스템의 헤더 파일   커널의 헤더 파일: /usr/include/linux   */share     아키텍처에 의존하지 않아 서로 다른 아키텍처에서도 공유할 수 있는 파일들            ex) 도큐먼트 류(man, info…)                    man1, man2, … 뒤 숫자는 섹션 번호           /usr/share/man/man1/cp.1 ‘도큐먼트 이름.섹션’                       배포판에 따라, /usr/man에 보관하기도 한다.           /usr/local     각 시스템의 User에게 책임이 있는 디렉터리들   */var     자주 바뀌는 파일을 저장            ex) 서버 로그, 메일 박스 등..                공유하는 파일은 부적합!       /var/log: 프로세스가 쓰는 로그 파일 저장   /var/spool: 사용자 메일(/var/spool/mail)이나 프린트 입력(/var/spool/cups) 저장   /var/run: 실행 중인 서버 프로세스의 PID가 저장(PID 파일)            서버 가동 시, 이 디렉터리에 PID 기록, 종료할 때는 제거해야함(매너)       ex) inetd 서버                    /var/run/inetd.pid에 자신의 프로세스 ID를 기록한다.               cat /var/run/inetd.pic   76                                   이를 응용해서 다음과 같이 inetd에 HUP 시그널을 보내, 설정 파일을 다시 읽도록 할 수 있다.               $ kill -HUP `cat /var/run/inetd.pid`                                               최근에는 /var/run이 /run으로 이동하고, /var/run은 단지 /run에 심볼릭 링크    분리 이유는, 운영체제 재부팅 시 사라져도 좋은 디렉터리를 /var에서 부터 분리하기 위해서다.           /etc     /etc는 각 시스템의 설정 파일이 보관   /etc/fstab, /etc/hosts   /dev     /dev에는 디렉터리 파일   리눅스 2.4 이후엔, 시스템에 존재하는 디바이스 파일만을 그때마다 작성하는 devfs(Device File System)도입            devfs는 USB와 같은 동적 디바이스 대응이 잘 이루어지지 않는 문제           리눅스 2.6 이후, udev 도입   devfs는 커널의 일부로 구현되어 있지만, udev는 커널 밖에 구현되어 있다.   /proc     /proc에는 일반적으로 프로세스 파일 시스템(Process File System, procfs)이 탑재            프로세스를 파일 시스템에 표현한 것       pid 1인 프로세스의 정보를 얻고 싶다면, /proc/1을 보면 된다.           $ cat /proc/1/statm   46339\t1110\t709\t0\t37310\t0                       ps 명령어, 프로세스 정보 이외에도 커널의 정보 실시간 출력 용도                    /proc/partitions: 시스템에 존재하는 파티션 목록           /proc/scsi: 시스템에 연결된 SCSI 디바이스 정보           /proc/sys/kernel/hostname: 현재 호스트 이름                       커널에 무언가를 지정하는 데 사용할 수도 있다.                    echo -n 'host name' &gt; /proc/sys/kernel/hostname: 여기서 호스트 이름을 write 하면, 반영                       프로세스 파일 시스템의 각 파일의 역할과 형식은 man 5 proc에서 확인           /sys     리눅스 2.6부터 sysfs라는 새로운 파일 시스템 추가. 이 파일 시스템을 탑재하는 디렉터리 ‘/sys’  시스템에 존재하는 디바이스나 디바이스 드라이버의 정보를 얻을 수 있다.   procfs에서 프로세스와 관계없는 정보들이 탑재되기 시작하면서 시스템 관련 정보들을 별도로 제공하기 위해 만들어짐   /boot     커널 프로그램 저장   리눅스 커널은 vmlinuz 파일에 담겨 있다.            UNIX: unix       BSD: vmunix       LINUX: vmlinux -&gt; 압축 -&gt; vmlinuz           /root     슈퍼 사용자 홈 디렉터리   */tmp     임시 파일 저장 공간   /tmp: 리부팅 시 삭제   /var/tmp: 리부팅해도 삭제되지 않는다.   정리                  관점       O       X                       복수의 호스트에서 공유?       /usr       /var                 Read Only?       /usr       /var                 아키텍처 의존?       /usr/lib       /usr/share                 배포자가 관리 여부?       /usr       /usr/local                 리부팅 해도 남아 있음?       /var/tmp       /tmp           ","categories": ["linux-system"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-system/linux_directory/",
        "teaser": null
      },{
        "title": "Pipe <2> fifo()",
        "excerpt":"Named pipe(FIFO)     Uni-directional byte stream: 그냥 주면 받아야함   파일 경로가 ID            unrelated process(Child 아닌 것도) 간에도 사용 가능           FIFO 생성과 open이 분리되어 있음   open()시 read-side와 write-side가 동기화됨            즉, 양쪽 모두 open시도가 있어야 성공!       open시 O_NONBLOCK이 유용하게 사용될 수 있음                    하나만 open시 block되지만, open(...,O_NONBLOCK) 옵션하면 block안걸림           하지만, 한 쪽만 fifo open후, O_NONBLOCK이면 에러                              #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt;  int mkfifo(const char *pathname, mode_t mode);     역할: named pipe 파일을 생성                  return value       describe                       0       성공                 -1       실패                          parameter       describe                       *pathname       생성할 named pipe 파일 경로                 mode       permission           named PIPE(fifo) example    ","categories": ["ipc"],
        "tags": [],
        "url": "https://markyang920413.github.io//ipc/system_programming-ipc-fifo/",
        "teaser": null
      },{
        "title": "Message Queue - SysV",
        "excerpt":"Message Queue 분류       Message는 byte stream과 다르게 쪼갤 수 없다. 메세지 자체가 최소 전송 단위        POSIX, SysV API 기능이 다르다.       메시지 큐 특징            메시지 기반 통신                    바이트 스트림이 아니다.           하나의 메시지는 하나의 덩어리                       Unrelated process 사용 가능            SysV MQ vs POSIX MQ                  항목       SysV MQ       POSIX MQ       비고                       Identifer       Special Key       File Descriptor       I/O multiplexing 가능                 Management tool       ipcs,ipcrm       mount on virtual file system       일반 파일에서 사용하는 방법/tool로 조작 가능                 Message priority       미지원       지원                         Notification Mechanism       미지원       지원                         Multi-thread safe       미지원       지원                         Message type       지원       미지원       1-writer/n-reader 구현이 용이           SysV Message Queue     메시지 type 지원(SysV에서만 지원)            이 메시지는 1번이고, 저 메시지는 2번.. type 정하고 send       receiver는 난 1번만 받을거야! 가능함           IPC Key 기반으로 Identify (fd x)            fd가 아니므로!                    select, epoll I/O Multiplexing IPC 키 값 사용 불가           read, write, open, close 시스템 콜 사용 불가                           Management tool(shell에서 사용 가능한 툴)            ipcs: IPC 사용 중인 것 정보 조회       ipcrm: IPC 오브젝트 삭제              메시지 큐가 key에 따라 구분하고, 메시지 타입부여 가능한 것 Focus!   SysV MQ API     데이터 송수신            msgsnd(): 메시지 전송       msgrcv(): 메시지 받음           기타            msgctl(): 메시지 컨트롤       msgget(): 메시지 큐의 ID를 구한다.       ftok(): 키 값 생성           msgget() - 메시지 큐 ID 구하기   #include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/msg.h&gt;  int msgget(key_t key,int msgflg);     기능: 메시지 큐 ID를 구한다. 옵션에 따라 큐 생성도 가능                  return value       description                       메시지 큐 ID       성공                 -1       실패                          parameter       description                       key       IPC Key || IPC_PRIVATE  - IPC_PRIVATE 지정 시, 새로운 메시지 큐 ID 생성!  - 수신자는 ID 얻기 어려움                 msgflg       Permission + mask  - IPC_CREAT: key에 매치되는 MSGQ ID 없으면 생성   - IPC_EXCL: key에 매치되는 MSGQ ID가 있으면 에러 발생              자세한 옵션은 ‘man msgget’   ftok() - key값 구하기  #include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt;  key_t ftok(const char *pathname, int proj_id);     기능: file path와 proj_id를 조합해서 key값 구한다.  best effort. but unique 보장 안됨                  return value       description                       IPC Key       성공                 -1       실패                          parameter       description                       *pathname       조합할 파일 경로  파일이 존재해야 하고, readable해야 함 임의의 project ID                 proj_id       임의의 project ID ex) ‘a’              Key값 하드 코딩하지 말고, 통신해야 하는 프로세스끼리 약속을 정함   msgsnd() - 전송   #include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/msg.h&gt;  int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);     기능: 메세지 전송                  return value       description                       0       성공                 -1       실패                          parameter       description                       msgid       메세지 큐 ID                 *msgp       전송할 메시지 버퍼                 msgsz       전송 메시지 사이즈(mtext의 길이 Byte)                 msgflg       IPC_NOWAIT: non-blocking I/O 자세한 옵션은 man msgsnd           struct msgbuf{ \tlong mtype; /* Message Type, must be &gt; 0 &amp;&amp; long type */ \tchar mtext[1]; /* 크기는 임의 지정. imgsnd의 msgsz 파라미터엔 이 것의 길이가 들어가야함! */ };   msgrcv() - 수신   #include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/msg.h&gt;  ssize_t msgrcv(int msgqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);     기능: 메세지 수신                  return       Description                       성공       실제로 받은 데이터 길이(mtext의 길이, Byte)                 실패       -1                          parameter       Description                       msgid       메세지 큐 ID                 *msgp       메시지 수신 버퍼                 msgsz       최대 수신 길이(mtext의 길이 Byte)                 msgtyp       리시브할 메세지 타입. 만약 다음 파라미터인 msgflg를 0으로 하면 막 받는다는 것인데, 그럼 여기도 0 넣으면 됨                 msgflg       내가 수신할 메시지 타입 0: 첫 번째 메시지 수신, 메시지 타입 안보고 수신! 양수: msgtype에 매치되는 첫 번째 메시지 수신(큐니까!), 메시지 타입 중에서!! 첫 째  음수: 지정된 절대 값보다 작거나 같은 msgtype에 매치되는 첫 번째 메시지 수신  IPC_NOWAIT: non-blocking I/O  MAG_COPY: n 번째 메시지를 복사해서 수신(msgtyp이 idx로 사용 됨) 반드시 IPC_NOWAIT와 같이 사용해야함 원래는 수신 후 메시지 큐에서 pop되어야 하지만, pop안시키고 copy를 해버림  MSG_EXCEPT: msgtyp과 매치되지 않는 메시지를 수신  MSG_NOERROR: 메시지 사이즈가 msgsz보다 크면 truncate 시킴           msgctl() - 큐 제어   #include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/msg.h&gt;  int msgctl(int msqid, int cmd, struct msqid_ds *buf);     기능: 메세지 큐 제어                  return       Description                       성공       0                 실패       -1                          parameter       Description                       msgqid       메세지 큐 ID                 cmd       IPC_STAT: kernel의 msgid_ds 정보 획득 IPC_SET: kernel의 msgid_ds에 설정 IPC_RMID: 메세지 큐 제거                 *buf       -           msqid_ds 구조체 - man msgctl   struct msqid_ds {    struct ipc_perm msg_perm;     /* Ownership and permissions */    time_t          msg_stime;    /* Time of last msgsnd(2) */    time_t          msg_rtime;    /* Time of last msgrcv(2) */    time_t          msg_ctime;    /* Time of last change */    unsigned long   __msg_cbytes; /* Current number of bytes in \t\t\t\t\tqueue (nonstandard) */    msgqnum_t       msg_qnum;     /* Current number of messages \t\t\t\t\tin queue */    msglen_t        msg_qbytes;   /* Maximum number of bytes \t\t\t\t\tallowed in queue */    pid_t           msg_lspid;    /* PID of last msgsnd(2) */    pid_t           msg_lrpid;    /* PID of last msgrcv(2) */ };   ex1. 메세지 타입 없이 주고 받기     messageQ_simple.c      ipcs를 쳐보면, ipc를 사용 중인 목록이 뜬다.   아직 남아 있다. ipcrm 커맨드를 이용해 없애자  $ ipcrm -h # 옵션을 모르면, -h로 찾아보기 $ ipcrm -q 0 # 메세지 큐 아이디로 삭제하는 옵션 -q와 id 0      다시 확인해보면 제거되어 있음   ex2. mtype 지정한 메세지 주고 받기     messageQ_specific_mtype.c           recv에 메시지 타입 3을 지정하니, send에서 1,2 등 같은 메시지 타입 아니면  받지 않는 것 확인   ","categories": ["ipc"],
        "tags": [],
        "url": "https://markyang920413.github.io//ipc/system_programming-ipc-message_queue_sysV/",
        "teaser": null
      },{
        "title": "Pipe <1> pipe(), popen()",
        "excerpt":"IPC     IPC(Inter Process Communication)   Linux IPC의 종류     Pipe     Uni-directional byte stream: 그냥 주면 받아야함   Name, ID가 없음   related process간에 사용 가능(e.g. fork())   fd[0]은 read만 가능   fd[1]은 write만 가능    #include &lt;unistd.h&gt;  int pipe(int fd[2]);                    return value       describe                       0       성공                 -1       실패              pipe가 full일 때, write 시도 -&gt; blocking   pipe가 empty일 때, read 시도 -&gt; blocking   write size가 PIPE_BUF 보다 작으면 atomic, 크면 interleaved 될 수 있음            Linux PIPE_BUF: 4KB       multiple writer 환경에서 주의!           fork PIPE example    dup():2, dup2():2   #include &lt;unistd.h&gt;  int dup(int oldfd); int dup2(int oldfd, int newfd);     기능: oldfd를 복제한다.            dup()은 oldfd를 복제해, 아직 사용하지 않은 제일 작은 값의 fd로 반환한다.       dup2()는 파일 디스크립터 oldfd를 지정한 파일 디스크립터 newfd에 복제한 뒤 그것을 반환한다.       이렇게 copy한 fd는 서로 락, 파일위치, 플래그등을 서로 공유       즉, redirection을 사용하기 위해!!!!!           $ cat &lt; test.txt                                          return       value                       성공       newfd                 실패       -1 errno set                이렇게 복제(duplicate)하면, fd6(new)에 작업하면, fd5(old)에 작업을 하는 것과 동일한 효과        파일 디스크립터를 관리해 파이프를 연결해보자. 셸을 만든다면 표준 입력 출력 파이프로 연결할 필요가 있다.       복제한다는것은 그림처럼 하나의 스트림을 커널 안에서 두 개로 분기하는 것을 의미한다.            fd6(new)에 read()하면, fd5(old)에도 똑같이 읽은 것으로 간주된다.       lseek()과 같은 파일 오프셋 작업을 하는경우에도 동일하게 적용       close()할 때, 양쪽 모두 close()           특정 fd에 파이프를 연결 해보자   fd3old &lt;-connected-&gt;  PIPE를 fd0new으로 옮기고 싶다.     close(0): newfd를 혹시나 해서 닫는다.   dup2(3,0); : oldfd -&gt; newfd duplicate   close(3): oldfd를 닫기   더 다루기 쉬운 popen()도 있다.   dup을 이용한 redirection 예제   #include &lt;vector&gt; #include &lt;string&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #include &lt;algorithm&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  using namespace std; vector&lt;string&gt; makearg(string);  int main(){ \tchar *buf; \tvector&lt;string&gt; arg; \tint pid=0; \tint fd; \tint redirect = 0;  \t// SIGCHLD 시그널을 무시한다. \tsignal(SIGCHLD, SIG_IGN); \tbuf=(char *)malloc(sizeof(char)*255); \twhile(1){ \t\tredirect=0; \t\tmemset(buf, 0x0, 255);  \t\t// 사용자 입력대기용 프롬프트를 띄운다. \t\twrite(1, \"# \", 3); \t\tif(read(0, buf, 255) &gt; 1){ \t\t\tbuf[strlen(buf)-1]='\\0'; \t\t\tprintf(\"read: %s size(exclude '\\\\0'): %lu\\n\",buf,strlen(buf)); \t\t\tif(strncmp(buf,\"exit\",4)==0) \t\t\t\texit(0); \t\t\t \t\t\t/* 만약 읽어들인 문자열중 \"&lt;\" 이 있다면, \t\t\t * redirection으로판단하고 makearg 함수를호출하여 \t\t\t * 명령부분과 파일부분을 나눈 후, 파일을 open 한다.  \t\t\t */ \t\t\tif(strstr(buf,\"&lt;\")!=NULL){ \t\t\t\targ=makearg(buf); \t\t\t\tfd=open(arg[1].c_str(), O_RDONLY); \t\t\t\tif(fd&lt;0){ \t\t\t\t\tfprintf(stderr, \"file not found: %s\\n\", arg[1].c_str()); \t\t\t\t\texit(0); \t\t\t\t} \t\t\t\tredirect=1; \t\t\t\tstrcpy(buf, arg[0].c_str()); \t\t\t\tpid=fork(); \t\t\t\tif(pid==0){ \t\t\t\t\t// 만약 재지향이 사용되었다면, 열린 파일을 표준입력으로 복사한다. \t\t\t\t\tif(redirect) \t\t\t\t\t\tdup2(fd,0); \t\t\t\t\t \t\t\t\t\t// 명령부분을 execl 계열 함수를 이용해서  \t\t\t\t\t// 실행시킨다. \t\t\t\t\texeclp(buf, buf, NULL); \t\t\t\t} else if (pid&gt;0){ \t\t\t\t\tif(redirect) \t\t\t\t\t\tclose(fd); \t\t\t\t\twait(0); \t\t\t\t} \t\t\t} \t\t} \t} }  /*   * 문자열을 \"&lt;\"를 기준으로 나누고 공백문자를 제거한 뒤에   * vector로 되돌려준다.   */ vector&lt;string&gt; makearg(string str){ \tint num; \tvector&lt;string&gt; return_str;  \tstring::iterator mi; \tmi=str.begin(); \twhile(mi!=str.end()){ \t\tif(*mi==' ') \t\t\tstr.erase(mi); \t\t*mi++; \t} \tnum=str.find(\"&lt;\"); \treturn_str.push_back(str.substr(0,num)); \treturn_str.push_back(str.substr(num+1));  \treturn return_str; }      popen():3   #include &lt;stdio.h&gt;  FILE *popen(const char *command, const char *mode);     기능: command로 지정한 프로그램 가동 + 거기에 파이프를 연결해 해당 스트림에 반환                  return       value                       성공       파이프에 read혹은 write가능한 open stream 포인터 get                 실패       NULL errno set                          mode       Description                       “r”       읽기용으로 열기                 “w”       쓰기용으로 열기           주의!: 읽고 쓰기 동시 불가  주의!: popen()에서는 프로그램이 셸을 거쳐 실행되므로 첫 번째 인자의 command는 PATH에서 찾을 수 있고, 리다이렉션이나 파이프도 사용할 수 있다.   pclose():3    #include &lt;stdio.h&gt;  int pclose(FILE *stream);     기능: pclose()는 popen()으로 fork()한 자식 프로세스를 wait()하고 그 후에 스트림을 닫는다. popen()을 사용해 연 FILE*는 반드시 pclose()로 끌 것!                  return       value                       성공       exit status of command                 실패       -1 errno set          ","categories": ["ipc"],
        "tags": [],
        "url": "https://markyang920413.github.io//ipc/system_programming-ipc-pipe/",
        "teaser": null
      },{
        "title": "컴파일 <1> Build, 컴파일 옵션",
        "excerpt":"빌드 시스템의 용도     컴파일            C/C++ 같은 컴파일형 언어(Compiled Lang)           패키지와 테스트            Perl, Python 같은 인터프리트 언어(Interpreted Lang) SW 패키지, 테스트           웹 애플리케이션 컴파일, 패키지            정적 HTML, JSP, ASP, PHP …           PDF, HTML 문서 생성   정적 분석(static analysis) 수행            소스코드로 부터 버그 찾기       빌드 시스템의 출력물은 버그 리포트 문서           단위 테스트(unit test)            SW의 전체 소스코드에서 작은 부분을 분리해 독립적 검증           빌드 트리(build tree) 클리닝(clean)            컴파일할 때 생성된 모든 파일 제거           실행 파일 설치(install)            표준 바이너리 경로로 실행 파일 복사           빌드 시스템      C/C++, 자바, C# 같은 컴파일형 언어를 위한 빌드 시스템        생성된 결과는 머신에 install할 수 있는 릴리스 패키지(Release Package)       주요 구성요소            소스 트리 - 오브젝트 트리 - (단위 테스트 스위트, 문서 생성)  　　 ㄴ(결합 리포트)              소스 및 오브젝트 트리   각 클래스        - 외부 행동(external behavior): 프로그래머가 항상 명심 해야하는 것 들       - 내부 행동(internal implementation): 클래스의 복잡도를 외부 관점에게서 숨김   소스 트리     릴리스 패키징과 타겟 머신     최종 패키징단계에선 사용자 머신에 실제로 설치할 수 있는 무언가를 만들어야 한다.   불필요한 디버그 정보 삭제   아카이브 파일, 패키지 관리 도구(.rpm, .deb), GUI 도구   소스 파일들 —–&gt; 오브젝트 파일 ——&gt; 실행 바이너리 ——–&gt; 릴리스 패키지  　　　　　링크　　　　　　　　데이터 이미지 파일 ——-┘   빌드 과정     빌드: C언어 작성한 프로그램을 기계어로 변환해 실행가능한 파일로 만드는 작업   빌드 내에서 수행되는 작업            전처리(preprocess) .i 파일                    #include, #ifdef, #define 등을 처리해 C코드로 변환한다.           gcc -E 옵션을 붙여 실행하면 전처리 수행한 결과를 출력                       컴파일(compile) .s 파일                    *.c를 어셈블리어로 변환한다.           gcc에서 컴파일은 ccl 프로그램이 컴파일을 담당한다.           gcc -S 옵션을 붙여 실행하면 .s 어셈블리 파일 출력                       어셈블(assemble) .o 파일                    *.s파일을 오브젝트 파일 *.o로 변환           gcc가 아닌 binutils 라는패키지에 포함된 as라는 명령어가 담당한다.           오브젝트 파일은 아래와 같이 3가지 종류가 있다.                            ELF(Executable and Linking Format)               COFF(Common Object File Format)               a.out(assembler output)                                               링크(link)                    *.o -&gt; bin, *.a, *.so                            bin: 그 자체가 하나의 오브젝트 파일, 리눅스에서 ELF 포맷 사용                                                   Toolchain Program                  명령       설명                       addr2line       실행 파일 안의 디버그 심볼을 읽어서 프로그램 주소를 파일 이름과 행 번호로 변환한다. 시스템 크래시 리포트에 출력된 주소를 해독할 때 매우 유용하다.                 ar       아카이브 유틸리티 static 라이브러리를 만들 때쓰인다.                 as       GNU 어셈블러                 c++filt       C++와 자바 심볼을 복원(demangle)할 때 쓰인다.                 cpp       C 전처리기, #define #include 등의 지시자를 확장할 때 쓰인다.                 ld       GNU 링커                 nm       오브젝트 파일의 심볼 나열                 strip       오브젝트 파일의 디버그 심볼 테이블을 없애 파일 크기를 줄여준다. 흔히 타깃에 복사할 모든 실행 코드에 적용한다.                 elfedit       ELF 파일의 ELF 헤더를 업데이트할 때 쓰인다.                 g++       GNU C++                 gcc       GNU C                 gconv       코드 커버리지 도구                 gdb       GNU 디버거                 gprof       프로그램 프로파일링 도구                 objcopy       오브젝트 파일 복사 및 번역                 objdump       오브젝트 파일 정보 출력시 사용                 ranlib       static 라이브러리 안의 인덱스를 만들거나 수정해 링크 단계를 더 빠르게 한다.                 readelf       ELF 오브젝트 형식의 파일에 정보를 출력한다.                 size       섹션 크기와 전체 크기를 나열한다.                 strings       파일 안의 인쇄 가능 문자열들을 출력한다.           C/C++ 컴파일 차이     g++를 이용한 C++은 함수 심볼을 mangled한다.   #include &lt;stdio.h&gt; void dbg(const char *s){ \tprintf(\"Log: %s\\n\", s); }  $ gcc -c dbg.c $ nm dbg.o 00000000 T dbg\t\"함수 dbg의 심볼\" \t U printf  $ g++ -c dbg.c $ nm dbg.o 00000000 T _Z3dbgPKc\t\"mangled된 함수 dbg의 심볼\" \t U __gxx_personality_v0 \t U printf     g++에선 함수 심볼을 mangled시키기 때문에 C컴파일로 컴파일한 main.o(gcc C)는 링킹 시,  dbg.o(g++ C++)에서 dbg 심볼을 찾지 못한다.   gcc 옵션 적용 규칙  -f, -fno-   -[f|W|m][옵션]은 설정  -[f|W|m]no-[옵션]은 해제   -fcse-skip-blocks\t: ‘cse-skip-blocks’ 옵션 설정한 것  -fno-cse-skip-blocks : ‘cse-skip-blocks’ 옵션을 해제   동일 종류의 옵션은 최종 옵션만 옵션 변수에 값이 설정  -Wunused-function : 소스 파일 내에 사용되지 않은 함수가 있을 때 경고 출력   $ gcc -o like like.c -Wunused-function -Wno-unused-function   최종 옵션인, -Wno-unused-function 옵션에 의해 저 옵션이 해제된다.   그룹 옵션이 존재한다 -fdump-tree-all 옵션은 아래 옵션들을 동시에 준 것과 동일    -fdump-tree-original[-n] -fdump-tree-optimized[-n] -fdump-tree-inlined[-n] ….   플래그                  플래그       뜻       예제                       -f       플래그       -fdump-tree-original                 -W       경고       -Wunused-function                 -m       아키텍처 종속       -mcpu=armv7-a           gcc 옵션   gcc -v -I/usr/local/include -DDEBUG -W -Wall -O2 -L/usr/local/lib -o like like.c -lm      -E: 전처리 과정의 결과를 화면에 보이는 옵션            gcc -E like.c           -S: 어셈블리 파일만 생성하고 컴파일 과정을 멈춘다.            gcc -S like.c -&gt; like.s           -c: 오브젝트 파일까지만 생성            gcc -c like.c -&gt; like.o           -v: gcc가 컴파일하는 과정을 화면에 자세히 출력한다.        –save-temps: 컴파일하는 과정중, 전처리 파일(*.i), 어셈블리 파일(*.s), 오브젝트 파일(*.o)를 지우지 않는다.       -o: 출력 파일 명을 정하는 옵션            gcc hello.c -o hello           CPP: 전처리기  -D   -D[macro]: 전처리기한테, macro를 넘겨 define 시킨다.   CC\t= gcc CPP\t= -DDEBUG  $(CC) $(CPP) like.c -o like =&gt;gcc -DDEBUG like.c -o like   like.c 파일에 #define DEBUG 를 삽입한 것과 같다.      왜 쓰나?   like.c 파일에   #ifdef DEBUG \tprintf(\"%d...\"); #endif  처럼 디버그용으로 쓰고, file path넘길 때도 쓰고..   CFLAGS  -O0 ~ -O3      -O0            어떠한 것도 최적화하지 않는다.       inline 키워드를 써도 인라인 확장이 일어나지 않는다.       컴파일 시 최적화 옵션을 쓰지 않았다면, -O0 셋       time 명령어로 실험해본다.           $ time ./test real 0m5.209s user 0m2.475s sys  0m0.002s  총 5.209s가 걸렸고, 유저에서는 2.475s 걸렸다.      -O1            -O 옵션과 동일하다.       gcc에서 수행하는 효과가 큰 몇 가지 기본 최적화를 수행한다.                  잠시 위 표에 있는 -floop-optimize 옵션을 알아보자.   int y=1+2; for(i=0;i&lt;n;i++){ \tj=j+2; \tk=y+3; \tz=k+1; }  루프에서 변하지 않는 코드를 밖으로 unrolling한다.  int y=1+2; k=y+3; z=k+1; for(i=0;i&lt;n;i++) \tj=j+2;      -O1 옵션을 넣고 컴파일 한 후, 시간 측정   $ time ./test real 0m3.155s user 0m1.767s sys  0m0.002s  user에서 확 줄었다.      -O2            가장 많이 사용한다. App, kernel compile시 주로 사용한다.       수행 속도와 사이즈 간에 트레이드오프가 존재하지 않는 거의 모든 최적화 수행       -O1 옵션 최적화 + 아래 표의 최적화도 더함                 위에서 공통 부분식 제거(Common Subexpression Elimination)을 알아보자   x=a-b; w=c+a-b; y=c*d; x=d+c;  Optimize..  t0=a-b; x=t0; w=c+t0; y=c*d; x=d+c;   $ time ./test real 0m3.194s user 0m1.621s sys  0m0.002s  user에서 0.1초 줄었다.   하지만 -O1 결과가 -O2 보다 빠를 수 있고, -O2가 -O3보다 더 빠를 수도 있다      -O3            가장 높은 레벨의 최적화       단순한 함수들의 인라인 과정이 일어나 바이너리 사이즈가 커진다.       O0 + O1 + O2 + 아래 표의 최적화              $ time ./test real 0m1.177s user 0m0.696s sys  0m0.002s      -Os            사이즈 최적화       -O2 옵션 중에서 사이즈를 늘리는 최적화만 제거하고 나머지 최적화는 다 수행한다.       -O2 옵션에서 아래와 같은 옵션이 비활성화              $ time ./test real 0m3.020s user 0m1.473s sys  0m0.004s     O2 옵션보다 오히려 속도는 잘나왔다.            사이즈가 작아짐으로 인해 캐시 히트가 더 자주 발생했을 수도 있다.       바이너리 사이즈가 작으면 캐시에 들어가는 inst 비율이 증가해 수행 속도가 향상될 수 있다.           -march, -mtune, -mcpu      -march=[cpu-type]            -march=armv7-a       지정하는 ISA코드를 생성한다.       -march=pentium4 시, pentium4에서 지원하는 ISA로 코드를 생성한다.       -march는 -mtune을 내부적으로 포함한다.                    -march=pentium4 지정 시, -mtune=pentium4 지정 안해도 무방                           -mtune=[cpu-type]            인스트럭션을 스케줄링 하거나 정렬할 때 -mtune 옵션으로 지정해 준 cpu에 최적화되게 스케줄링하고 정렬       이 때 고려되는 것은 각 CPU의 파이프라인 단계와 각 인스트럭션을 수행하는 데 걸리는 사이클 버스와 캐시의 크기 등이 있다.       Pen3는 파이프라인이 10개, Pen4는 20개, CPU stall을 줄이기 위해 인스트럭션 순서를 섞을 때 -mtune 옵션으로 지정한 CPU에 최적화되게 인스터럭션을 섞는다.       인스트럭션 스케줄링이란 CPU내부의 특정 자원이 사용 가능치 않아 CPU stall을 줄이기 위해 인스트럭션 수행 순서를 바꾸는 것이다.       인스트럭션 정렬이란 함수나 레이블이 시작하는 주소를 해당 CPU의 버스 너비와 캐시의 크기에 최적화한다.       CPU 특성을 반영해 최적화된 코드를 생성하는 역할만 담당한다. ISA에 영향을 주는 것은 아니다.                    -mtune=pentium4 옵션으로 컴파일 해도, i386 ISA를 사용했다면 오래된 펜티엄에서도 동작           -mtune=athlon-xp 해도 ISA를 펜티엄으로 하면 펜티엄에서 돌아간다. 단지 좀 비효율적                       -march 옵션은 주지 않고, -mtune 옵션만 주어 ISA는 모든 x86 아키텍처에 공통된 것을 사용하게 하고, 스케줄링과 코드 정렬만 특정 프로세서에서 최적화할 수 있다.           -mcpu=[cpu-type]            -mtune과 거의 동일하다.           -march 종류       x86 아키텍처에서 -march와 -mtune -mcpu에서 지정할 수 있는 cpu-type은 generic만 제외하고 동일하다.   generic은 -march에서 사용할 수 없다.   generic은 현재 가장 보편적인 프로세서를 의미하고 gcc-4.1.2에서는 i686로 지정되어 있다.      arm-[vendor]-linux-gnueabi-[gcc/g++/ld] -march=armv7-a   프로파일 결과를 이용한 최적화   사용법 및 다양한 플래그     like.c 파일을 -fprofile-generate 옵션을 주어 컴파일한다.   $ gcc -O2 -o like like.c -fprofile-generate      like bin파일을 한번 수행한다. 그러면, 프로파일 결과들이 있는 파일들(like.gcda, like.gcno)가 생성됨   like.c 파일을 -fprofile-generate 옵션을 빼고 -fprofile-use옵션을 추가해 like.c를 다시 컴파일한다.            gcc는 like.gcda, like.gcno를 이용해 좀 더 최적화한 like bin 파일을 만든다.           $ gcc -O2 -o like like.c -fprofile-use      -fprofile-use: 프로파일 정보를 이용해 할 수 있는 모든 최적화를 수행한다. 이 옵션에 의해 선택되는 최적화 옵션은 다믕과 같다.            -fbranch-probabilities 분기 최적화                    분기문이 있을 때, 프로그램이 주로 어떤 쪽으로 분기하는지 파악하고 이를 적용해 파이프라인이 최대한 깨지지 않게 하는 코드 생성                       -funroll-loops 루프 최적화                    루프가 몇 번 도는지 알고, 최적화 할 수 있다면 언롤링                       -fpeel-loops 루프 최적화                    프로파일 정보로 부터 루프가 그다지 많이 돌지 않는다면 사용, 루프 필링이란 루프 내에 인덱스와 인접하지만 다른 값을 가지면서 인덱스 범위 내에서 인덱스의 증감과 같이 변하는 연산을 루프 밖으로 빼는 것                       -ftracer 베이직 블록을 슈퍼 블록으로 만든다.                    프로파일 결과를 토대로 베이직 블록을 슈퍼 블록으로 만든다. 베이직 블록의 개념은 다음과 같다.                           CTest.c   #include &lt;stdio.h&gt;  int main(void){ \tint i,j,k; \tj=0; \tk=0; \tfor(i=0; i&lt;10; i++){ \t\tif(i%2!=0) \t\t\tj+=1; \t\telse \t\t\tk+=1; \t\tprintf(\"j=%d,k=%d\\n\",j,k); \t} \treturn 0; }   위 코드를  $ gcc -o CTest CTest.c -fdump-tree-all =&gt; CTest.c.t21.cfg 파일 생성   CFG: Control Flow Graph 제어 흐름 분석을 통해 생성된 결과 파일         베이직 블록: 제어 흐름 단위로 나눠진 블록            블록 내에서는 제어 흐름이 변치 않고 순차적으로 진행       제어 흐름이 바뀌는 단위로 나눈 소스 코드으 ㅣ블록       베이직 블록 내에는 베이직 블록이 끝나는 시점이나 시작되는 시점이 아니고서는 브랜치 문과 같이 제어 흐름을 바꿀 수 있는 Inst는 존재하지 않는다.           이 제어 흐름을 그래프로 그린 것이 CFG이다.   슈퍼 블록: CFG에서 인접한 베이직 블록들을 합쳐 좀더 크게 만든 블록            베이직 블록 -&gt; 슈퍼 블록, 꼬리 복제(tail duplication)이라는 기법 사용       베이직 블록 -&gt; 슈퍼 블록, inst scheduling 효율 향상           instruction scheduling            베이직 블록 단위로 수행하는데, 스케줄링할 inst 개수가 적으면 스케줄링 효율이 감소한다.       지연이 발생되는 구간에 끼워 넣을 inst 갯수가 적기 때문       베이직을 슈퍼로 만들면 블록 크기가 훨씬 커져 스케줄링할 대상이 되는 inst 개수가 많아져 스케줄링 효율 향상           fvpt: 조건식의 값에 대한 정보를 수집하는 코드 추가            컴파일러가 조건식의 값에 대한 정보를 수집하는 코드를 추가하게 한다. 그 정보를 바탕으로 최적화 수행                 함수 프레임 포인터 제거      $ gcc -o exp exp.c --save-temps      -fomit-frame-pointer: 프레임 포인터 설정이 필요 없는 함수에 대해 프레임 포인터 설정을 제거     rbp 레지스터는 x86_64 아키텍처에서 프레임 포인터로 사용되는 레지스터   add()와 sub() 최상위 보면 이전 레지스터의 값(rsb)를 스택에 push 후, ‘rsp’ 스택 포인터를 rbp 레지스터에 설정하는 것 보일 것임        함수의 시작 부분에서 rbp 레지스터의 값을 현재 rsp(스택 포인터)의 값으로 변경하는 것을 함수의 프레임 포인터를 설정한다고 한다.       각 함수 마지막 부분을 보면 저장했던 rbp 레지스터를 다시 popq 명령으로 복구하는 것이 보인다.            이는 이전 함수의 프레임 포인터로 복구하는 과정                 prefetch를 이용한 최적화  -fprefetch-loop-arrays: 루프에 진입하기 전에 컴파일러는 루프 내에서 사용할 메모리 영역을 캐시에 미리 가져다 놓음     현대 모든 아키텍처는 프로세서 매우 빠름, 메모리 아주 느림            load 명령에 많은 클록 사이클 소모           큰 배열이 있을 때 루프를 돌면서 배열을 순차적으로 액세스 하면서, 어떤 명령을 수행한다 -&gt; 배열 값이 캐시에 없다 -&gt; load 발생 증가 -&gt; 성능 하락   Prefetch는 이런 값을 미리 캐시에 가져다 둠         레지스터를 활용한 최적화          -fforce-mem: 메모리에 있는 값을 레지스터에 로드해 연산 수행. GCC 4.2에서 제거된 옵션이지만 이전 버전에서 사용 가능            -fforce-addr: 메모리 주소 값을 레지스터에 로드 후 연산을 수행             gcc 컴파일 속도 최적화     -pipe: 컴파일 속도 상승            gcc는 컴파일 시 /tmp에 임시 파일을 생성하고, 각 과정의 바이너리는 이런 임시 파일을 입력으로 받아 다음 과정 수행       -pipe 사용 시, 컴파일 과정에서 임시 파일을 생성해 전달하지 않고 파이프로 전달해 컴파일 속도 향상                 환경 변수(env)를 사용한 gcc설정          COMPILER_PATH            CC, CPP, AS, LD를 호출할 때, COMPILER_PATH에 등록된 디렉터리에서 먼저 찾는다.       export COMPILER_PATH=/opt/arm-:root   C_INCLUDE_PATH, CPLUS_INCLUDE_PATH, OBJC_INCLUDE_PATH     전처리할 때, 헤더 파일을 찾을 디렉터리를 지정하는 환경 변수   설정 해두면, -I(대문자 i) 옵션으로 참조할 path 안해줘도 됨   각각 C, C++, Objective-C 소스에 대한 Include Path 지정   LIBRARY_PATH     라이브러리 찾을 디렉터리 지정   ld에게 LIBRARY_PATH에 등록된 디렉터리들을 -L 옵션으로 넘긴다         specs 파일을 이용한 gcc설정  -v     제일 처음에 다음과 같은 메시지가 출력된다.   $ gcc -o test test.c -v Using built-in specs...      -dumpspecs     내장된 specs파일을 보는 옵션   $ gcc -dumpspecs &gt; specs\t\t\t\t\t# gcc $ arm-starfishmllib32-linux-gnueabi-gcc -dumpspecs &gt; specs\t# arm gcc     gcc -dumpspecs &gt; specs 명령을 사용해 gcc에 내장된 specs 파일을 덤프해 보면 다음과 같은 specs 파일을 볼 수 있다.   specs 파일은 컴파일러 드라이버(gcc, g++..)가 수행될 때 읽고 specs 파일에 적힌 각 바이너리(CPP, CC, AS, LD)들을 호출하게 되어 있다.   specs파일을 수정해 원하는 형태로 각 바이너리들을 호출할 수 있다.   $ vi specs ```일    &lt;img src=\"img11.png\"&gt;  ```bash %{pg:%{formit-frame-pointer:%e-pg and -fomit-frame-pointer are in compatible}}   -pg 옵션이 있고 동시에 -formit-frame-pointer 옵션이 있다면, 오류(%e)로 “pg and -fomit-frame-pointer are incompatible”문자열 출력하라.   %{!Q:-quiet}  -Q 옵션이 없다면, -quiet 옵션을 추가하라는 의미      ARM과 같은 크로스 컴파일 환경에서는 프로파일 정보를 어떻게 수집하는가?            시뮬레이터 사용 Simit-ARM 시뮬레이터 사용           http://simit-arm.sourceforge.net 에서 simit-arm release 3.0 설치   www.falinux.com/zdownload/toolchain.php 에서 arm-toolchain-3.3.4.tar.gz 받아서 ARM 크로스 컴파일러 설치(3.3.4)   소스 파일을 arm-linux-gcc 컴파일러로 컴파일 할 때 -O2 -static -fprofile-generate 옵션을 주고 컴파일   simit [바이너리] 명령으로 실행하면 프로파일 정보가 들어있는 파일들이 생성된다.   O2 -static -fbranch-probabilities 옵션 등으로 재 컴파일한다.      그냥 ARM 보드에서 직접 수행   -g: 디버깅   -g: 디버깅 옵션     디버거에 제공하는 디버깅 정보를 바이너리에 삽입   디버깅 옵션시, 최적화 금지   디버깅 옵션시, 삽입한 바이너리는 용량이 매우 커짐. 개발 초기에만 사용할 것.   디버깅 정보: 변수 타입, 전역 심볼명과 주소, 소스 라인 정보등이 DWARF2라는 디버깅 정보 포맷으로 되어있음   -g 바이너리 컴파일시, DWARF2 디버깅 포맷이 ELF 바이너리에 섹션 형태로 삽입된다.            $ readelf -a [bin]으로 바이너리를 읽으면, .debug_*로 시작하는 섹션들이 DWARF2를 구성하는 섹션들임           -g 미 옵션 시, 어셈블리 코드로 디버깅할 수 밖에       -g0: 디버깅 정보를 삽입하지 않는다.   -g2: = -g   -g3: 디버깅 정보 가장 많이 삽입   odjdump -S로 덤프 떠보기     test.c   #include &lt;stdio.h&gt;  int main(){ \tprintf(\"hello world!\\n\"); \treturn 0; }   $ gcc -g -o test test.c $ odjdump -S test   …    -pg: 프로파일   -pg     컴파일한 프로그램이 종료하면, 프로파일 정보가 gmon.out 파일에 저장된다.   gprof로 gmon.out 파일의 내용을 분석해 어떤 함수가 얼마나 호출되었고, 시간은 얼마나 걸렸는지 확인가능   1. $ gcc -pg -o test test.c 2. $ ./test 3. $    &lt;--- gmon.out 생성 4. $ gprof ./test   -shared: shared 라이브러리 사용 우선, shared 만들기   -shared     2가지용도, shared 우선 사용, shared 만들기    $ gcc -fPIC -c test1.c $ gcc -fPIC -c test2.c $ gcc -shared -o libtest.so test1.o test2.o  $ gcc -L. -shared -o test test.c -ltest      -ltest 로 링크 걸었는데, libtest.a, libtest.so 둘다 있다.            -shared 옵션 시, libtest.so 링크       근데, 기본적으로 아무 옵션을 안줘도 shared라이브러리를 우선 링크           -fPIC   -fPIC     -f: set!   PIC: Positino-Independent Code 생성하라      Shared library는 메모리 어느 위치에 로딩되는지가 컴파일 타임에 결정되지 않기 때문에, 절대 주소가 아닌 상대 주소를 주는 옵션   다른 바이너리에서 이 라이브러리의 함수를 호출할 때 PLT와 GOT를 사용하도록 하는 옵션   library의 mapping 주소 + offset = 해당 Symbol의 주소            mapping 주소는 ldd로 확인       offset은 nm으로 확인           -static: static 라이브러리 사용 우선   -static     static라이브러리 우선 사용   PLT, GOT 사용하지 않고 바로 call libcaddr   dynamic linking 사용 안하기 때문에, 라이브러리 종속성 제거   $ gcc -static -o like like.c   -nostdlib   -nostdlib     링크 시, 표준 C 라이브러리 사용 안함   OS, bootloader, Device Driver 같은 표준 C 라이브러리를 사용하지 않는 프로그램을 컴파일할 때 사용   -nostartfiles   -nostartfiles     crt1.o, crti.o, crtbegin.o, crtend.o, crtn.o 등과 같은 crt 오브젝트 파일들을 링크하지 않는다.   OS, bootloader 같은 프로그램을 컴파일할 때 사용   LDFLAGS  -L: 라이브러리 path   -L[path]     path에 라이브러리를 찾을 디렉터리 지정   shared, static 모두 찾음      기본적으로 찾아보는 디렉터리            /usr/lib, /usr/local/lib, /lib                .so파일 못찾을 땐, export LD_LIBRARY_PATH=path:$LD_LIBRARY_PATH       -L 옵션 사용 예   $ /opt/lib/libclsched.a &lt;-- 라이브러리 파일 위치  $ gcc -o like like.c -L/opt/lib -lclsched      -L 여러 곳 필요시   $ gcc -L${HOME}/lib -L${HOME}/other main.c -lmylib1 -lmylib2 -o main      따로 따로 지정   -Wl,[링커 옵션]   -Wl,[링커 옵션]     -Wl류 옵션은 gcc를 거치지 않고 바로 링커에 옵션을 전하려 할 때 사용   $ gcc -o like like.c -Wl,-M,-s     gcc 스킵, collect2에 -M, -s 옵션이 전달된다.   collect2는 링커인 ld를 찾아서 위 옵션으로 호출   -rpath, -rpath-link   -Wl,-rpath,[path]     rpath는 shared 라이브러리 검색 path만 추가        -rpath와 -L이 동시에 사용되면, -L은 무시됨       사용 예   $ gcc -Wl,-rpath,/usr/local/lib hello.c -lmylib      바이너리에 rpath 먹혀 있는지 체크   $ readelf -d a.out | grep RPATH  0x000000000000000f (RPATH)                  Library rpath: [/usr/local/lib]   -Wl,-rpath-link=[path1]:[path2]     rpath-link는 shared라이브러리 검색 패스를 추가한다.   -rdynamic   -rdynamic     dynamic linking   링커에게 -export-dynamic을 넘기는 것, -Wl,-export-dynamic과 동일   링커가 dynamic symbol table에 모든 symbol을 추가하도록 하는 옵션   dlopen man page에는 쓰라고 나오는데, -ldl만 보통 써도 된다   -Xlinker [f링커 옵션]   -Xlinker [f링커 옵션]     gcc가 인식하지 못하는 특정 링커에 대해 옵션을 지정할 때 사용된다.   $ gcc -o like like.c -Xlinker -M -Xlinker -s      collect2에 -M -s 옵션이 전달되고 진짜 링커인 ld 호출시 -M -s 옵션으로 ld가 호출된다.   -Wl -Xlinker에서 사용가능한 링커 옵션      -s: 실행 파일에서 심볼 테이블 제거   -x: 출력 파일에 로컬 심볼 제거   -e[name]: 시작 심볼을 name 심볼로 사용한다.     $ gcc -Wl,-emain -o like like.c          위 명령 시, 시작 심볼로 main 심볼을 사용한다. 기본적으로 시작 심볼은 _start 심볼이다.       -M: 링커 스크립트와 메모리 맵을 자세하게 출력한다.            프로그램의 메모리 구조를 자세하게 알 수 있다.           LIBS  -l : 라이브러리 링크   -l[library]     링크할 라이브러리   반드시 소스 뒤에 위치, 특히 main 함수 있는 파일보다 무조건 뒤   # libclsched.so 링크 1. $ gcc -o like like.c -lclsched  2. $ gcc like.c -lclsched -o like   -ldl : 동적 라이브러리   -ldl     동적 라이브러리용(shared 아님!!)   dlopen() 사용하려면 꼭 써줘야한다.   -ldl은 libdl.so를 로딩하는데, 속에 dlopen()이 있다.   ","categories": ["linux-compile"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-compile/compile_1_build/",
        "teaser": null
      },{
        "title": "Message Queue - POSIX",
        "excerpt":"Message Queue POSIX  Feature     Message기반의 커뮤니케이션            Partial read 없음       Multiple message read 없음                즉, 한 번에 하나의 메시지 통으로 읽음. Byte 쪼개기 이런 것 없음!       하나의 큐로 R/W 가능   Multi-reader/ Multi-writer 가능   File I/O기반 동작 = I/O multiplexing 가능!(System V와 차이)   메세지 우선순위 지정 가능(높을 수록 High Priority)   메세지 Notification 기능(Blocking하지 않고 메시지가 도착했을 때 알려주는 기능)   컴파일 시, -lrt 링크   POSIX MQ API      mq_open() - MQ를 생성하거나 열기   #include &lt;fcntl.h&gt; #include &lt;sys/stat.h&gt; #include &lt;mqueue.h&gt;  mqd_t mq_open(const char *name, int oflag); // MQ 열기(큐가 존재할 경우 oflag에 O_CREAT (X)) mqd_t mq_open(const char *name, int oflag, mode_t mode, struct mq_attr *attr);     기능: POSIX MQ를 열거나 생성 후 열기                  return       value                       성공       MQ descriptor                 실패       -1                          parameter       option       description                       *name       MQ이름       ex) “/tmp/testmq” 반드시 ‘/’로 시작해야 한다                 oflg       O_RDONLY       MQ를 receive only로 open                 -       O_WRONLY       MQ를 send only로 open                 -       O_RDWR       MQ를 receive &amp; send 가능하게 open                 -       O_CLOEXEC       close-on-exec Set. open(2) man을 보면 왜 유용한지 알 수 있음   이 옵션부터 아래로, ‘|’ 로 다중 사용 가능                 -       O_EXCL       O_CREAT가 set 되어 있고, *name의 queue가 이미 존재한다면, EEXIST 에러                 -       O_NONBLOCK       큐를 Non-Blocking으로 Open                 mode       permission       -                 attr       속성 지정       NULL일 경우 기본 값 설정, 자세한 건 아래!           attribute                    return       value                       성공       0                 실패       -1                          parameter       description                       mqdes       메시지 큐 디스크립터                 attr       attribute           mq_receive() - 메시지 수신  ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned int *msg_prio);     기능: 메시지 수신                  return       value                       성공       읽은 바이트 수 리턴                 실패       -1                          parameter       description                       mqdes       메시지 큐 디스크립터                 *msg_ptr       전송받은 것을 담을 포인터(받을 버퍼)                 msg_len       전송받은 길이 (반드시 attr.mq_msgsize 보다 크거나 같아야함)                 *msg_prio       받은 우선순위 기록할 ptr           mq_close()   int mq_close(mdq_t mqdes);     기능: 메시지 큐 닫기(삭제는 mq_unlink())                  return       value                       성공       0                 실패       -1                          parameter       description                       mqdes       메세지 큐 Descriptor           mq_unlink()   int mq_unlink(const char *name);     기능: 메시지 큐 삭제                  return       value                       성공       0                 실패       -1                          parameter       description                       *name       메세지 큐 Descriptor Name           mq_send()   int mq_send(mqd_t mqdes,const char *msg_ptr, size_t msg_len, unsigned int msg_prio);     기능: 메시지 전송                  return       value                       성공       0                 실패       -1                          parameter       description                       mqdes       메세지 큐 Descriptor                 *msg_ptr       전송할 포인터(전송 버퍼)                 msg_len       전송 길이                 msg_prio       우선 순위(0:lowest ~ 32768:highest)           mq_notify()   int mq_notify(mqd_t mqdes, const struct sigevent *sevp);     기능: 메시지 수신                  return       value                       성공       0                 실패       -1                          parameter       description                       mqdes       메세지 큐 Descriptor                 sevp       notification 설정           sigevent struct      POSIX MQ 제어     SysV는 ipcs, ipcrm 등으로 제어 가능   POSIX MQ는 가상 파일 시스템으로 컨트롤 한다.      ex.1 attr 확인     print_attr_error_code.c      $ gcc print_attr_error_code.c -lrt -o print_attr_error_code $ ./print_attr_error_code  # Error 발생      이 코드는 에러난다!      ex2. Priority 메세지 주고 받기     msgq_priority.c   Priority는 메세지 줄 때 set!!            sender가 1,2,3,4,5 순으로 send   recv는 Priority가 높은(숫자가 높은)것 부터 Pop!            넣은 순서랑 상관 없이, 큐에 5개가 들어가 있다면, Priority 높은 것 부터 Pop!       같은 priority만 있다면, 당연히 FIFO           ","categories": ["ipc"],
        "tags": [],
        "url": "https://markyang920413.github.io//ipc/system_programming-ipc-message_queue_posix/",
        "teaser": null
      },{
        "title": "컴파일 <2> Makefile",
        "excerpt":"Makefile 작성법  C 컴파일     3개의 c 소스코드와, 1개의 h 파일이 있다고 가정한다.         노가다로 하나씩 컴파일 한다면?   $ gcc -c calendar.c diary.h $ gcc -c main.c diary.h $ gcc -c memo.c diary.h  calendar.o main.o memo.o # object파일 생성  $ gcc main.o memo.o calendar.o -o diary  diary # diary binary file 생성     .o파일을 일일히 만드는 이유는?            Make는 파일의 타임스탬프를 만든다.       소스 파일이 수정됬다면 해당 파일의 타임스탬프가 갱신된다.       오브젝트 파일이 더는 최신이 아니며, 갱신할 필요가 있다고 판단해 재컴파일한다.       소스 파일이 수정되지 않았다면 오브젝트 파일을 또 만들지 않는다. 중복 피함           Makefile 작성  쌩기초 Makefile      파일명은 Makefile 할 것        타겟 커맨드: 소스1 소스2 \\t명령어 1 \\t명령어 2   기본 문법      =: 대입, 사용하기 직전까지 대입문내 매크로 갱신                사용직전까지 매크로를 갱신 시켜줌           :=: 대입, 딱 여기 라인까지만! 아래는 신경안씀              사용 이후 매크로를 갱신 X           ?= : 이 매크로가 정의되지 않았을 경우에만 반영  Makefile  1: CXX\t= hello1  2: CXX\t?= hello2 # &lt;- 이미 위에 CXX가 정의되어 있으므로, 무시된다.  3: CC\t?= hello3            CXX: hello1, CC: hello3                make -p : make파일 내부에 미리 정의되어 있는 매크로 출력       NAME=\"string\" 따옴표로 묶으면, 문자열로 인식            \" \" 신경 잘 써야함       \"&lt;- 자체도 문자로 넣고 싶다면 \\\" 사용           매크로 변수 사용            $(매크로변수)           ifeq endif   ifeq ($(매크로1), 비교 값)  \t- 매크로1이 비교 값과 같다면 실행  else  \t- 아니라면 else문 실행  endif   ifneq ($(매크로1), 비교 값)  \t- 매크로1이 비교 값과 다르면!! 실행  else  \t- else문 실행  endif   ifeq ($(매크로), 비교 값)  \t- 매크로가 비교 값과 같다면 실행  else ifeq ($(매크로), 비교 값)  \t- 매크로가 비교 값과 같다면 실행  endif      미리 지정되어 있는 매크로들       C 컴파일러를 gcc가 아닌 clang을 사용하고 싶다면  Makefile내에서 CC를 재정의 할 것  CC = clang  내부 매크로 $? $^ $@ …                   macro       description                       $?       현재의 타겟보다 최근에 변경된 종속 항목 리스트 (확장자 규칙에서 사용 불가)                 $^       현재 타겟의 종속 항목 리스트, 한 마디로 재료! (확장자 규칙에서 사용 불가)                 $@       현재 타겟 이름                 $&lt;       현재의 타겟보다 최근에 변경된 종속 항목 리스트 (확장자 규칙에서만 사용 가능)                 $*       현재의 타겟보다 최근에 변경된 현재 종속 항목의 이름(확장자 제외) (확장자 규칙에서만 사용 가능)                 $%       현재의 타깃이 라이브러리 모듈일 때, .o 파일에 대응되는 이름 %.o: %.c &lt;– .o 확장자를 제외한 파일명이 .c에 대응하는 것을 만났을 때                 -M       소스코드 파일에 상응하는 오브젝트 파일을 생성하는데 필요한 규칙을 얻는다.                 -MM       소스코드 파일에 상응하는 오브젝트 파일을 생성하는데 필요한 규칙을 얻되, 시스템 헤더 파일을 생략한다. gcc -MM calc.c calc.o: calc.c numbers.h 결과를 얻는다.  단 gcc 커맨드에 의해서!           다음과 같이 엄청 자주 쓰인다.   %.o: %.c    %.o: %.c \tcommand   a.o b.o: %.o: %.c \tcommand for a.o b.o  c.o d.o: %.o: %.c \tcommand for c.o d.o   SRCS\t= memo.c main.c calendar.c OBJS\t= $(SRCS:.c=.o)     SRCS내 .c 파일 =&gt; .o로 OBJS에 대입   .PHONY           Makefile 커맨드에서 어떠한 선행 파일 X 경우, 허위 타겟을 만들어야한다.            .PHONY 역할             허위 타겟역할을 한다.                    make help를 입력하면 help라는 파일이 존재치 않아 셸은 그 파일을 만들려고 하지 않는다.           이때 PHONY는 허위 타겟 역할을 한다.           허위 타겟 명령은 타임스탬프 정보가 없다.                            따라서 help 명령이 호출될 때 마다 실행                                                      wildcard    SRCS\t= memo.c main.c calendar.c &lt;- 이거도 귀찮다  SRCS\t= $(wildcard *.c) OBJS\t= $(SRCS:.c=.o)      wildcard는 *, ? 등 shell의 wildcard를 사용할 수 있는 makefile 함수   SRCS = *.c 로 하면 진짜 *.c 파일을 검색함   만약 src 폴더 내의 .c 로 검색한 파일을 다 가져 오고 싶다면?   SRCS\t= $(wildcard src/*.c) OBJS\t= $(SRCS:%.c=%.o)   patsubst    dst = $(patsubst 패턴, 변경 문자열, 소스 문자열)  dst = $(patsubst %.c, %.o, $(wildcard *.c))           wildcard로 *.c 파일을 검색해 %.c에 매칭이되는 것은 %.o로 치환            sub directory에 있는 경우       SRCS\t= $(patsubst %.c, $(SRCDIR)/%.c, $(wildcard $(SRCDIR)/\\*.c)) OBJS\t= $(SRCS:%.c=%.o)   filter      리스트에서 특정 패턴만족 단어 반환   SRCS\t= calc.c main.c math.h lib.c C_SRCS\t= $(filter %.c, $(SRCS))  # C_SRCS = calc.c main.c lib.c   addprefix      리스트에서 서두에 문자열 추가            다음 예제는 $(OBJECTS) 리스트의 각 요소 서두에 objs/를 추가한다.           OBJECTS\t\t= calc.o main.o lib.o OBJ_LIST\t= $(addprefix objs/, $(OBJECTS))  # OBJ_LIST = objs/calc.o objs/main.o objs/lib.o   shell      컴파일 중 shell 명령을 사용할 때 $(shell 쉘 명령) 으로 사용     target: src   $(shell echo \"hello world!\")                원래 $HOME 이라고 쓸 shell 명령을 Makefile 내에선 $(shell $${쉘변수})사용한다.       따라서, $(shell $${HOME}) 같이 사용하면된다.     target: src   $(shell echo $${HOME})                 예를 들어, 환경변수에 $SYSROOT=/opt/cross-compile 로 되있다면,         CFLAGS\t= --sysroot=$(shell echo $$SYSROOT))                       쉘에 echo $SYSROOT 쳐서 나온 값이 --sysroot 로 정의된다.           명령 사용 규칙  기본 규칙    TARGET: hello  all: \techo $(TARGET)   위 명령 실행 시, Makefile은 실행 전 명령어를 그대로 쉘에 띄움 그래서 실행 시,   echo hello\t# Makefile이 실행 직전 실행할  명령어 그대로 띄움 hello\t\t# echo \"hello\"에 의해 출력된 hello      @명령은 에코 기능을 끈다   원래 Makefile은 자기가 실행하려고 하는 명령어를 그대로 쉘에 띄운다. 이 기능을 금지 시킨다.   끄지 않으면, 셸에 띄워진 커맨드가 실행 완료 됬다고 착각 하기 때문   all: \t@echo $(TARGET)   hello\t# echo \"hello\"에 의해 출력된 hello   명령어 한 줄은 새로운 셸이다.   clean: \tcd ./backup \trm -rf *      의도: ./backup 디렉터리의 모든 파일을 지운다.   실제 실행: 현재 디렉터리의 모든 파일이 지워짐   이유: 두 명령어가 서로 다른 쉘에서 실행되기 때문이다.   그래서… 아래처럼 고친다.   clean: \tcd ./backup &amp;&amp; rm -rf *   오류가 나도 계속 실행 시키고 싶다           Makefile은 한 줄씩 실행 하면서, 하나라도 return 0가 안된 명령이 있으면 실행 종료한다.            딱히 중료한 명령이 아니면 -를 붙여서 명령이 실패해도 계속 실행하게 한다.       cat: \t-cat file.txt \t@echo done      ’-‘ 때문에 file.txt를 cat명령어로 못 읽어도, 계속 실행된다.   재귀적 Makefile 사용       다음과 같이 최상위 디렉터리에 Makefile이 있고, 서브 디렉터리마다 소스코드가 있는 경우   각 디렉터리의 Makefile은 다음과 같이 작성한다.   TARGET\t= buildt-in.o OBJS\t= $(patsubst %.c, %.o, %(wildcard *.c) CFLAGS\t= -I../include  all: $(OBJS) \t$(LD) -r $(OBJS) -o $(TARGET)  clean: \trm -rf *.o $(TARGET)   최상위 Makefile은 아래와 같다.   TARGET\t= diary SUBDIRS\t= calendar main memo OBJS\t= carlendar/built-in.o main/buildt-in.o memo/built-in.o  all: compile $(OBJS) \t$(CC) $(OBJS) -o $(TARGET)  compile: \t@for dir in $(SUBDIRS); do \\ \tmake -C $$dir || exit $?; \tdone  clean: \t@for dir in $(SUBDIRS); do \\ \tmake -C $$dir clean; \tdone \trm -rf *.o *.i *.s $(TARGET)   문장이 이해가 안가면, 쉘 스크립트 공부하자   VPATH를 이용하면, 좀 더 간결하게 할 수 있다.   VPATH\t= calendar main memo OBJS\t= calendar.o main.o memo.o CFLAGS\t= -I./include  all: clean diary  diary: $(OBJS) \t$(CC) -o $@ $^  clean: \trm -rf *.o calendar/*.o main/*.o memo/*.o diary   VPATH 지정 시, make가 소스 파일들을 찾을 때 VPATH도 보고 찾아감   서브 makefile에 대한 매크로 전달  최상위 Makefile에서 $(CC)를 다른 걸로 바꿔도 서브 디렉터리의 Makefile에는 영향을 끼치지 않는다. 서브 디렉터리에게 영향을 끼치고 싶으면 export로 환경변수를 줘야함   $ export CC=clang   Makefile example1: 단일 디렉터리 컴파일   SRCS\t= add.c calc.c mult.c sub.c PROG\t= calculator CC\t\t= clang CFLAGS\t= -W -Wall OBJS\t= $(SRCS:.c=.o)  all: clean $(PROG)  $(PROG): $(OBJS) \t$(CC) $(CFLAGS) $^ -o $@  $(OBJS): number.h  clean: \t@rm -rf *.o   Makefile example2   SRCS\t= add.c calc.c mult.c sub.c PROG\t= calculator CC\t\t= gcc CFLAGS\t= -W -Wall OBJS\t= $(SRCS:.c=.o)  all: clean $(PROG)  $(PROG): $(OBJS) \t$(CC) $(CFLAGS) $^ -o $@  -include $(SRCS:.c=.d)  %.d: %.c \t@$(CC) -MM $(CPPFLAGS) $&lt; | sed 's#\\(.\\*\\)\\.o: #\\1.o\\1\\.d: #g' &gt; $@  clean: \t@rm -rf *.o   재귀 Makefile example3        4개의 Makefile            1개의 상위 Makefile, 나머지 libmath, libprint, calc 하위 Makefile       각 Makefile 현 디렉터리에 있는 파일만 기술하면 된다.               libmath/Makefile  SRCS\t= clock.c letter.c number.c LIB\t= libmath.a CC\t= gcc CFLAGS\t= -g OBJS\t= $(SRCS:.c=.o)  $(LIB): $(OBJS) \t$(AR) cr $(LIB) $(OBJS)  $(OBJS): math.h  .PHONY: clean clean: \trm -f $(OBJS) $(LIB)       libprint/Makefile   SRCS\t= banner.c center.c normal.c LIB\t= libprint.a include lib.mk $(OBJS)\t= printers.h  .PHONY: clean clean: \trm -f $(OBJS) $(LIB)     libprint/Makefile은 libmath/Makefile과 비슷하므로 간략하게 작성한다.       calc/Makefile   SRCS\t= calc.c PROG\t= calculator LIBS\t= ../libmath/libmath.a ../libprint/libprint.a CC\t= gcc CFLAGS\t= -g OBJS\t= $(SRCS:.c=.o)  $(PROG): $(OBJS) $(LIBS) \t$(CC) -o $@ $^  .PHONY: clean clean: \trm -f $(OBJS) $(PROG)       상위 Makefile   .PHONY: all all: \t$(MAKE) -C libmath \t$(MAKE) -C libprint \t$(MAKE) -C calc  .PHONY: clean clean: \t$(MAKE) -C libmath clean \t$(MAKE) -C libprint clean \t$(MAKE) -C calc clean  ","categories": ["linux-compile"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-compile/compile_2_makefile/",
        "teaser": null
      },{
        "title": "인라인 어셈블리(inline assembly)",
        "excerpt":"Inline Assembly  Feature     인라인 어셈블리: C 소스 내에서 어셈블리 코드를 사용하는 방법            해당 CPU에서만 동작하게 되므로, 주의!           #include &lt;stdio.h&gt;  int main(void){ \t__asm__ __volatile__(\"nop\"); \t \treturn 0; }      __asm__: 인라인 어셈블리 시작의 필수   __volatile__: 변수 앞 volatile은 해당 변수를 컴파일러가 최적화를 수해앟지 않도록 함(쓰고 싶을 때만 씀)   (\"nop\"): “nop”이라는 CPU instruction. no operation이라는 뜻으로 아무것도 하지마라는 명령어   #include &lt;stdio.h&gt;  int main(void){ \t__asm__ __volatile__( \t\t\"mov1 $3, %eax\\n\" \t); \t \treturn 0; }      $3: 어셈블리 언어에서, 상수를 표현시 $   위 커맨드의 뜻은, eax 레지스터에 3을 넣어라!   ","categories": ["c"],
        "tags": [],
        "url": "https://markyang920413.github.io//c/inline_assembly/",
        "teaser": null
      },{
        "title": "라이브러리의 종류 및 컴파일",
        "excerpt":"Library     linker(collect2)..?      source.c가 printf()함수를 사용한다.   printf()의 사용법은 #include &lt;stdio.h&gt;를 통해  extern int printf(const char *fmt, …) 라는 것을 알았다.   사용자는 일단 사용법만 알면 코드를 작성할 수 있다.            printf()가 내부에선 어케 동작하는진 모르겠고.. return 값, argument 값만 제대로 쓰지 뭐~           사용자는 코드를 완성하고 컴파일한다.     $ gcc -L/usr/lib -I/usr/include foo.c -lc -o bar                 -lc : printf()는 libc 라는 라이브러리에 있다. 링커는 -lc를 보고 libc 라이브러리를 찾아본다.       -L/usr/lib : 그래서 libc의 위치가 어딨는데? -L 옵션으로 지정한다.       -I/usr/include: printf()의 사용법이 있는 stdio.h 파일의 위치          물론 -lc, -L/usr/lib, -I/usr/include는 컴파일러가 default로 보는 곳이라 평소 생략           gcc 컴파일러는 .c -&gt; .i -&gt; .s -&gt; .o 를 거쳐왔다. .o파일까지 왔는데, 이제 진짜 printf()가 어떻게 작동하는지 알아야한다.            컴파일 옵션 정보를 통해 libc라는 라이브러리속에 printf() symbol을 찾았다.       링커는 내 source의 함수 symbol을 라이브러리와 링크하는 역할을 한다.           링크가 끝나고 최종적으로 바이너리 bar가 완성되었다.   Library 종류            정적 라이브러리(Static library) - (static linking) *.a            .a 파일들이 스태틱라이브러리이다.       컴파일 타임에 링크되어 (static linking) 바이너리에 같이 적재 된다.       장점: 바이너리 속도가 다소 더 빠르다. 바이너리 배포에 제한이 없다.       단점: 바이너리 사이즈가 커진다. 라이브러리만 업데이트하고 싶어도, 프로그램을 다시 전부 빌드해야 한다.          라이브러리 이름                    lib[라이브러리_이름].a 형식                       응용 프로그램에서 사용 예                    라이브러리 이름: OpenCL, 파일 명: libOpenCL.a           gcc -static -L[libOpenCL.a 위치] like.c -lOpenCL -o like                              공유 라이브러리(Shared library 中 Dependent libary) - *.so            Shared library 중에서 Dependent library이다. 그냥 공유라이브러리라고 하겠다.       프로그램과 따로 존재       프로그램 시작 할 때(dynamic linking) 적재된다.                 프로그램 바이너리가 시작 시 마다 찾아서 메모리에 적재해야 하면 너무늦다.                    /etc/ld.so.conf 파일에 적힌 기반으로 ldconfig 프로그램에 의해 생성된, /etd/ld.so.cache를 참고해 공유 라이브러리 로딩때마다 캐시보고 로드                       장점: 바이너리의 사이즈가 작아진다(따로 따로 있으므로). 라이브러리 업데이트 시, 라이브러리만 재 빌드하면된다.                단점: 속도가 약간 느리다(실행시 마다 링킹). 다른 시스템에 바이너리를 이식 시, 같은 메이저 버전을 가지는 shared library가 존재해야한다.                  라이브러리 이름                    lib[라이브러리_이름].so 형식                       응용 프로그램에서 사용 예                    라이브러리 이름: OpenCL, 파일 명: libOpenCL.so           gcc -shared -L[libOpenCL.so 위치] like.c -lOpenCL -o like                           동적탑재 라이브러리(Shared library 中 Runtime loaded library) - *.so            프로그램 동작 중 필요 시 적재되는 동적 탑재 라이브러리       공유 라이브러리랑 똑같으나, 응용 프로그램에서 -ldl -rdynamic 지정 컴파일, 함수 사용법등이 다르다.           static library  static library 만들기    // file.h void func1(); void func2(); void func3(); // ================================================================ //  // file1.c #include &lt;stdio.h&gt; #include \"file.h\"  void func1(){ \tprintf(\"hello fund1\\n\"); } void fund2(){ \tprintf(\"hello func2\\n\"); } // ================================================================ //  // file2.c #include &lt;stdio.h&gt; #include \"file.h\"  void func3(){ \tprintf(\"hello func3\\n\"); } // ================================================================ //   $ gcc -c -o file1.o file1.c file.h\t# .o 파일 만들기 $ gcc -c -o file2.o file2.c file.h $ ar rc libfile.a file1.o file2.o\t# .a static lib만들기     ar: 스태틱 라이브러리 만드는 커맨드(.o -&gt; .a)   r: 라이브러리 아카이브에 새로운 오브젝트를 추가할 것이다라는 옵션   c: 아카이브가 존재하지 않을 경우 생성하라는 옵션   ar 명령                  Command       Description                       ar rus [라이브러리 이름] [O 파일]       기존 아카이브 파일에 오브젝트 추가                 ar ds [라이브러리 이름] [O 파일]       기존 아카이브 파일에서 오브젝터 제거                 ar x [라이브러리 이름]       아카이브에서 오브젝트 파일 추출                 ar t [라이브러리 이름]       아카이브에 잇는 파일 리스트 출력              file1.c, file2.c의 내용을 담은 스태틱 라이브러리 libfile.a가 완성되었다.   static link      static link: 라이브러리를 컴파일 타임에 로드해서 같이 빌드   위 예제에서 만든 libfile.a 스태틱 라이브러리를 사용하는 응용프로그램을 컴파일 한다.   $ gcc -static -L./lib/path main.c -lfile -o main     -L[library path]로 라이브러리 위치 지정, -static 옵션, libfile.a를 링크해라.   shared library  shared libary      그냥 공유라이브러리, shared library라고 칭하겠음   $ gcc -fPIC -c file1.c file.h $ gcc -fPIC -c file2.c file.h $ gcc -shared -Wl,-soname,libmy.so.0 -o libmy.so.0.0.0 file1.o file2.o     -fPIC: -fPIC 옵션 링크 참고   -Wl,-soname,libmyso.0: soname은 libmyso.0 으로 지정        파일 명: libmy.so.0.0.0 soname: libmy.so.0 을 가진 쉐어드 라이브러리가 만들어졌다.       shared 라이브러리는 두 개의 소프트링크가 필요하다. 이유는 symbolic link to library 참조   $ ln -s libmy.so.0.0.0 libmy.so\t\t# 라이브러리 이름까지만! $ ln -s libmy.so.0.0.0 libmy.so.0\t# soname과 똑같은 이름의 소프트링크   shared library의 숫자      쉐어드 라이브러리의 이름은 &lt;lib라이브러리명.so.Major번호.Minor번호.배포번호&gt;의 의미   예: libjpeg.so.8.0.2            라이브러리 이름: jpeg       라이브러리 종류: shared       메이저 번호: 8       마이너 번호: 0       배포 번호: 2           soname   $ gcc -fPIC -c file1.c file.h $ gcc -fPIC -c file2.c file.h $ gcc -shared -Wl,-soname,libmy.so.0 -o libmy.so.0.0.0 file1.o file2.o     만들어진 libmy.so.0.0.0 공유 라이브러리는 soname: libmy.so.0를 가진다.   soname을 사용하는 이유는 파일명과 상관없이 서로 다른 버전의 공유(shared) 라이브러리 사용하기 위해   이 라이브러리에 링크 건 응용 프로그램들은 실행 시, Dynamic loader가 Shared library를 메모리 탑재 하려 하는데, soname을 이용해 라이브러리 파일명을 찾는다.   soname 찾는 법   libjpeg.so.8.0.2의 soname을 찾는다면 아래 커맨드 처럼 사용하자  $ readelf -a /usr/lib/libjpeg.so.8.0.2 | grep SONAME 0x000000000000000e (SONAME) Library soname: [libjpeg.so.8]   symbolic link to library   /usr/lib의 라이브러리들을 보면 한 라이브러리와 여러 심볼릭 링크로 연결 된 것을 볼 수 있다.      libGL.so의 경우의 예:  와 같이 존재한다.    libGL.so.1 -&gt; libGL.so.1.0.0로 심볼릭 링크되어있다.   즉, libGL.so.1는 소프트링크고, 진짜 라이브러리는 libGL.so.1.0.0이다.   여기서 libGL.so.1.0.0의 soname은 libGL.so.1이다.   그렇다면, 왜 soname의 이름을 가진 소프트링크를 만든 것인가? 또한 진짜 라이브러리는 libGL.so.1.0.0인데 심볼릭 링크는 왜 두는 것인가?   보통 하나의 라이브러리를 검색하면 최대 4개까지 뜬다(여기선 libGL을 4개 있다 가정).            libGL.a  GL 라이브러리의 static library       libGL.so  응용 프로그램이 컴파일할 때 -lGL로 링크 사용하는 용도 -&gt; libGL.so.1.0.0에 소프트링크되어 있음 이 소프트 링크 없으면 컴파일 시, -lGL 걸어도 libGL.so.1.0.0을 못찾음 $ gcc test.c -lGL -o test &lt;- 컴파일 할 때, 저 링크 옵션이 이 소프트링크 사용       libGL.so.1  응용 프로그램 실행 시, dynamic loder가 soname보고 라이브러리를 찾아가는 용도 -&gt;libGL.so.1.0.0에 소프트링크되어 있음 위 libGL.so파일이 있어서 응용프로그램이 컴파일은 됬어도 이 파일이 없으면 응용프로그램 실행 시, shared 라이브러리 탑재를 못함! dynamic loader가 soname을 보고 찾는데 soname파일이 없잖아..       libGL.so.1.0.0  리얼 라이브러리 파일           그래서 shared library를 만들면 두 개의 소프트링크도 만들어야한다.   Shared library를 사용하는 응용 프로그램 컴파일   c 파일은 file.c 참조   주의! 간단한 소스코드라도 헤더 파일에 함수 선언 필수!  어짜피 함수 정의는 라이브러리에 있잖아? 하고 함수 사용 선언 안하면 에러!   libmy.so을 사용하는 응용 프로그램을 컴파일 해본다.   $ gcc -L/library/path source.c -lmy -o a.out     -L[path]: libmy.so 라이브러리 위치            라이브러리가 /lib, /usr/lib, /usr/local/lib같은 Default Path에 있으면 -L 생략           -l[라이브러리이름]: -l로 라이브러리 링크     컴파일러는 -L 위치에서 -l로 걸어진 라이브러리를 찾는다.            여기서 libmy.so.0.0.0이 원본이라도, 소프트링크인 libmy.so가 없으면 안된다!           응용 프로그램 실행      위 예제로 바이너리 a.out이 생성 되었다. 하지만 사용 안될 수 있다! 라이브러리의 위치가 Specific path에 있으면 바로 안됨!   ldd, ldconfig, LD_LIBRARY_PATH      의존성 체크 ldd     $ ldd [binary]           ldd 명령어를 치면 바이너리가 의존하는 공유 라이브러리를 볼 수 있다.   예제에서는 libclsched.so.0를 찾을 수 없어서 실행이 안된다.  soname을 보고 라이브러리를 찾기 때문에, libclsched.so.0.0.0이 원본이라도, 소프트링크인 libclsched.so.0가 없으면 안된다!      ldconfig  ldconfig 프로그램은 /etc/ld.so.conf 파일을 기반으로 공유 라이브러리 위치를 등록한다.     $ vi /etc/ld.so.conf # /etc/ld.so.conf 파일 내부=========== /library/path\t# 라이브러리 path 명시 # ==================================== $ ldconfig\t# ldconfig 실행           LD_LIBRARY_PATH를 환경변수 등록     $ export LD_LIBRARY_PATH=/library/path:$LD_LIBRARY_PATH           애초에 컴파일 시, -rpath 등록  응용 프로그램 바이너리 빌드 시, -Wl,-rapth,[path]로 라이브러리 위치 등록     $ gcc -L/library/path -Wl,-rpath,/library/path source.c -lmy -o a.out $ readelf -d a.out | grep RPATH 0x000000000000000f (RPATH)\tLibrary rpath: [/library/path]           Runtime loaded library(Dynamic Library)     Dynamic library 중에서 Runtime loaded library   그냥 동적 탑재라이브러리라고 칭함   *.so 이며, 공유 라이브러리랑 똑같으나 코드와 옵션등이 조금 다름   #include &lt;dlfcn.h&gt;  void *dlopen(const char *filename, int flag); const char *dlerror(void); void *dlsym(void *handle, char *symbol); int dlclose(void *handle);      dlopen()  기능: 동적라이브러리를 적재하기 위해 사용                  return       value                       성공       -                 실패       -                          parameter       Description                       *filename       적재하기 윈하는 라이브러리 이름 ex) /usr/my/lib/libmysum.so 만약 적재시킬 라이브러리의 이름이 절대경로로 지정되어 있지 않으면, LD_LIBRARY_PATH에 등록된 디렉터리에서 찾고, 여기에도 없다면 /etc/ld.so.cache에서 찾는다.                 flag       RTLD_LAZY와 RTLD_NOW 중 하나 정의 RTLD_LAZY: 라이브러리의 코드가 실행 시간에 정의되지 않은 심볼을 해결 RTLD_NOW: dlopen의 실행이 끝나기 전에(return 전) 라이브러리에 정의되지 않은 심볼을 해결                   dlerror  기능: dl관련 함수들이 제대로 작동을 수행하지 않았을 경우 에러메세지 되돌려준다.  dleooro(), dlsym(), dlclose(), dlopen():3 중 마지막 호출된 함수의 에러메시지 돌려줌            dlsym  기능: dlopen():3을 통해서 열린 라이브러리를 사용할 수 있도록 심볼 값을 찾아준다. 심볼은 열린 라이브러리에서 실제 호출할 함수 이름                      return       value                       성공       dlopen()으로 열린 라이브러리의 호출함수를 가르킴 void*형으로 되어 있는데, 호출함수가 리턴하는 형을 직접명시하도록하자! 그러면 유지보수가 훨씬 수월하다.                 실패       -                          parameter       Description                       *handle       dlopen()에 의해 반환된 값                 *symbol       열린 라이브러리에서 실제 호출할 함수 이름           readelf: 어떤 라이브러리와 링크?      readelf 명령으로 이 프로그램이나 다른 프로그램이 어떤 라이브러리와 링크됐는지 확인할 수 있다.   $ arm-starfishmllib32-linux-gnueabi-readelf -a [shared lib] | grep 'Shared library'      shared 라이브러리는 런타임 링커 필요한데, 런타임 링커를 알 수 있다.   $ arm-starfishmllib32-linux-gnueabi-readelf -a [shared lib] | grep 'program interpreter'      readelf 명령으로 프로그램의 다양한 정보를 얻을 수 있다.   $ arm-starfishmllib32-linux-gnueabi-readelf -a [shared library]   ","categories": ["linux-system"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-system/library/",
        "teaser": null
      },{
        "title": "gdb",
        "excerpt":"gdb     The GNU Debugger (GDB) is a portable debugger that runs on many Unix-like systems and works for many programming languages, including Ada, C, C++, Objective-C, Free Pascal, Fortran, Go, and partially others.  - wikipedia    How to use gdb?   가령 example.c와 같은 소스 코드가 있다면   $ gcc -g example.c -o a.out   -g 옵션을 붙이고, 최적화 옵션 사용 금지!   컴파일 후, 다음의 명령어로 gdb를 실행한다.     가장 기초적인 실행 방법     $ gdb [binary]           PID를 이용한 실행 방법     $ gdb [binary] [PID]           gdb with Args     $ gdb --args [binary] [arg1] [arg2] # 혹은 $ gdb [binary]\t\t# 실행 후 (gdb) r [arg1] [arg2]           gdb with LD_PRELOAD     $ LD_PRELOAD=/media/libHybridCL.so gdb [binary] # 혹은 $ gdb [binary]\t\t\t\t\t# 실행 후 (gdb) set env LD_PRELOAD /media/libHybridCL.so\t# SET!          LD_PRELOAD 확인      (gdb) show env LD_PRELOAD\t\t# 명령 LD_PRELOAD=/media/libHybridCL.so\t# 확인            core 파일을 이용한 디버깅      코어 파일: 프로세스에 예외 발생 시 프로세스 이미지   1. core file 허용 size check   $ ulmit -a\t\t# 현재 ulimit 상태 보기 .... -c: core file size (blocks)\t사이즈 ....  # unlimited로 만들어버리자 $ ulimit -c unlimited     너무 작으면 저장이 안되니, unlimited로 만들어버리자   2. Seg Fault 등이 나는 예외 상황 유발 바이너리 디버깅 with core file   # 우선 먼저 바이너리가 예외 상황이 나야 core file이 생성된다. $ ./a.out [1]\t1233 segmentation fault (core dumped) ./a.out # 위 (core dumped) 출력으로 core file 생성 확인   이제 corefile로 gdb 실행한다.   $ gdb [binary] [core_file] ex) $ gdb ./a.out ./core     실행 시, seg fault 상황으로간다.   엔터: 이전 명령어 반복  엔터는 이전 명령어를 반복 입력 해준다  tab: 자동완성  tab 키를 누르면 자동 완성 됨  # num 변수 값을 출력하고 싶다면, $ (gdb) p nu 까지 치고 tab 키 누르면... ... $ (gdb) p num &lt;- 으로 자동완성   l(list): 소스 내용 출력  l(list): 소스 내용 출력     현재 어디까지 실행 됬는지 알고 싶다면 bt를 이용하자   l [행 번호] : 특정 행 보기  l [함수 명] : 특정 함수 코드 보기  l - : 출력된 행 이전 행들 출력  l 1,7 : 1~7 line 소스 출력  l file.c:func : file.c 파일 내, func 함수 소스 코드 출력  l file.c:10 : file.c 파일 내, 10 line 소스 출력  set listsize 20 : l 명령에서 보여주는 코드 20행으로   c: 다음 bp 까지 수행  b : 브레이크 포인트  b [함수명] : 함수에 bp  b main : main 함수에 bp  b 10 : 10행에 bp  b file.c:main : file.c에 main 함수에 bp  b file.c:10 : file.c에 10 line에 bp  b +2 : 현재 행에서 +2 행에 bp  b -2 : 현재 행에서 -2 행에 bp  b 10 if var == 0 : 10 행에 bp 걸되, var이 0 일 때 작동  b 10 if var &gt; 0 : 10 행에 bp 걸되, var &gt; 0 일 때 작동  condition [b번호] var == 1 : b번호 bp 조건을 var == 1 로 바꿈      b 번호는 info b로 얻을 수 있음   condition [b번호] func(i) &gt; 5 : func(i)의 값이 5보다 클 때로 바꿈  info b : 모든 bp 정보 보기  ignore [b번호] 100 : b번호 bp가 100번 지날 때까지 무시      주로 for文 내에 bp가 있는 경우 유용   rb fun* : fun*에 해당하는 모든 심볼에 bp 설정  rb ^fun : fun으로 시작하는 모든 심볼에 bp 설정  rb TestClass:: : TestClass에 해당하는 모든 심볼에 bp 설정   clear : bp 지우기  cl 10 : 10행 bp 제거  cl file.c:func : file.c의 func함수에 있는 bp 제거  cl file.c:10 : file.c의 10행 bp 제거  cl main : main 함수 걸려있는 bp 제거   d : 모든 bp 제거  d 1 : bp 1 제거   disable br : 모든 bp 비활성화  disable br 1 3 : 1, 3번 bp 비활성화  enable br : 모든 bp 활성화  enable br once 1 : 1번 bp 활성화 1번하고 다음 부턴 비활성화  enable br delete 1 : 1번 bp 활성화 하고 제거   r: 재시작  k: 프로그램 종료   s(step) : vs에서 f11     Visual Studio에서 f11은 프로시저 내부로 들어감   s 6 : step 6번 수행  si : assembly inst level f11   n(next) : vs에서 f10     Visual Studio에서 f10은 프로시서 내부로 안들어가고 한줄 씩 실행     n 6 : next 6번 수행      ni : assembly inst level f10       u : for문 빠져 나오기  finish : 함수 끝 시점으로 가기  return : 함수의 나머지 부분 수행하지 않고 바로 return  return 123 : return 123 주고 바로 return   watch [변수] : 변수에 값이 써질 때 브레이크 걸림  rwatch [변수] : 변수가 읽힐 때 브레이크  awatch [변수] : 변수가 읽거나 쓰거나 하면 브레이크   info locals : 지역변수 모두 출력  info variables : 전역변수 모두 출력  info registers : 레지스터 모두 출력  info all-registers : 거의 모든 레지스터 출력  p(print) [변수] : 개별 변수 값 한번 출력  p [함수] : 함수 주소 값 한번 출력  p $[레지스터명] : $레지스터 값 한번 출력  p/출력형식 [변수] : 지정한 출력 형식으로 변수 값 출력      t: 2진수   o: 8진수   d: signed 10진수   u: unsigned 10진수   x: 16진수   c: 최초 1Byte 문자형 출력   f: 부동 소수점 값 형식으로 출력   a: 가장 가까운 심볼의 오프셋 출력   display [변수] : 변수 값 계속 출력  undisplay [display 번호] : 해당 번호 display 띄우지 않음  set variable [변수]=[값] : gdb 실행 중 변수에 값 임의 셋  bt : backtrace  층층히 쌓이는 스택의 변수나 함수 정보가 저장되는 메모리 공간      main함수 내 27번 라인에서 문제가 생긴 것 확인 아래와 같은 명령들이 backtrace와 자주 쓰임   (gdb) bt\t# backtrace 명령 (gdb) frame 3\t# frame 3번 main 함수로 간다. (gdb) f 3 \t# 동일 명령어 (gdb) up\t# 윗 레벨 프레임 이동 (gdb) down\t# 아래 프레임 이동 (gdb) info frame\t# 현재 프레임 정보   멀티스레드 디버깅         break를 pthread_create() 함수에 의해 스레드들이 생성 직후 적당하다.   pthread_join() 이후에는 break 설정 안됨            pthread_join() 함수 호출 시, gdb의 현재 스레드인 main스레드가 잠들어 버리기 때문에 진행 안됨           다음 예시 처럼 한다   $ (gdb) ./a.out $ b pthread_create\t# pthread_create() 함수 브레이크 $ r\t\t\t# start! $ n..n..finish $ info threads\t\t# 스레드 정보 얻기   1번 스레드: main 스레드 2,3 번 스레드는 각자 할 것 하고 있음  # info threads 로 스레드 정보 얻은 후 $ (gdb) b [라인 번호] thread [브레이크 될 스레드 번호] # 스레드 전환 $ (gdb) thread [스레드 번호]   ","categories": ["linux-tools"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-tools/gdb/",
        "teaser": null
      },{
        "title": "configure 파일 셋팅 - Cross compile용",
        "excerpt":"Keyward     build, host, target은 여기참고   Toolchain program                   명령       설명                       addr2line       실행 파일 안의 디버그 심볼을 읽어서 프로그램 주소를 파일 이름과 행 번호로 변환한다. 시스템 크래시 리포트에 출력된 주소를 해독할 때 매우 유용하다.                 ar       아카이브 유틸리티 static 라이브러리를 만들 때쓰인다.                 as       GNU 어셈블러                 c++filt       C++와 자바 심볼을 복원(demangle)할 때 쓰인다.                 cpp       C 전처리기, #define #include 등의 지시자를 확장할 때 쓰인다.                 ld       GNU 링커                 nm       오브젝트 파일의 심볼 나열                 strip       오브젝트 파일의 디버그 심볼 테이블을 없애 파일 크기를 줄여준다. 흔히 타깃에 복사할 모든 실행 코드에 적용한다.                 elfedit       ELF 파일의 ELF 헤더를 업데이트할 때 쓰인다.                 g++       GNU C++                 gcc       GNU C                 gconv       코드 커버리지 도구                 gdb       GNU 디버거                 gprof       프로그램 프로파일링 도구                 objcopy       오브젝트 파일 복사 및 번역                 objdump       오브젝트 파일 정보 출력시 사용                 ranlib       static 라이브러리 안의 인덱스를 만들거나 수정해 링크 단계를 더 빠르게 한다.                 readelf       ELF 오브젝트 형식의 파일에 정보를 출력한다.                 size       섹션 크기와 전체 크기를 나열한다.                 strings       파일 안의 인쇄 가능 문자열들을 출력한다.           설치 디렉터리      --prefix=PREFIX 아키텍처에 독립적인 파일을 _PREFIX_에 설치한다. 기본 값은 /usr/local/에 bin, include, lib이 설치된다. ex) --prefix=$HOME =&gt; $HOME/bin $HOME/lib 등에 파일을 설치한다.   시스템 configure      --build=BUILD 도구를 컴파일하는 시스템의 종류를 지정한다.   --host=HOST 서버를 실행할 시스템의 종류를 지정한다. 기본 값은 BUILD   --target=TARGET  TARGET시스템 종류를 위한 컴파일러를 만들 떄 사용한다. 기본 값은 HOST이다.   toolchain options      --arch=ARCH 아키텍처 선택   --cpu=CPU CPU 선택   --cross-prefix=PREFIX PREFIX를 compilation tools로 사용   --enable-cross-compile 크로스 컴파일러가 사용 됨을 가정함   --sysroot=PATH cross-build tree의 root   --target-os=OS target OS compiler   --target-path=DIR target의 build 디렉터리의 view 로 지정할 path   --toolchain=NAME NAME에 해당하는 디폴트 툴 세팅 (gcc-asan, clang-asan, gcc-msan, clang-msan, gcc-tsan, clang-tsan, gcc-usan, clang-usan, valgrind-massif, valgrind-memcheck, msvc, icl, gcov, llvm-cov, hardened)   --cc=CC C 컴파일러 CC 사용 ex) --cc=gcc   --cxx=CXX C++ 컴파일러 CXX 사용 ex) --cxx=g++   --nm=NM _NM_으로 지정한 툴 사용 ex) --nm=”nm -g”   --ar=AR 아카이브 툴 AR 사용 ex) --ar=ar   --as=AS 어셈블러 AS 사용   --strip=STRIP strip tool STRIP 사용 ex) --strip=strip   --ld=LD 링커 LD 사용 ex) --ld=LD   --pkg-config=PKGCONFIG pkg-config 지정 ex) --pkg-config=/usr/lib/pkg-config   --pkg-config-flags=FLAGS pkgconf에 추가적인 flags 전달   --ranlib=RANLIB ranlib RANLIB 사용   --extra-cflags=CFLAGS CFLAGS 전달 ex)–extra-cflags=”-O2 -DDEBUG”   --extra-cxxflags=_CXXFLAGS CXXFLAGS 전달   --extra-ldflags=LDFLAGS LDFLAGS 전달   --extra-libs=LIBS LIBS 전달   configure tool 사용 예  ex 1   $ export CC=arm-cortex_a8-linux-gnueabihf-gcc \\ ./configure --host=arm-cortex_a8-linux-gnueabihf --prefix=/usr --cc=$CC     결과 Makefile 생성   $ make     소스 코드 컴파일 결과(make의 결과)는 현재 디렉터리에 생성됨            $PWD/usr/bin, $PWD/usr/lib ..           $ make DESTDIR=$(arm-cortex_a8-linux-gnueabihf-gcc -print-sysroot) install     sysroot 명시 경우 sysroot/[_PREFIX_] 위치로 옮겨짐            sysroot/usr/bin, sysroot/usr/lib …           prefix 명시하지 않으면 ’/’ 루트 이하에 install됨     ex2            $ export CROSS_COMPILE=/opt/starfish-sdk-x86_64/5.0.0-20190307/sysroots/x86_64-starfishsdk-linux/usr/bin/arm-starfishmllib32-linux-gnueabi $ export TARGET_ABI=armeabi-v7a $ export HOST=arm-starfishmllib32-linux-gnueabi $ export AR=$CROSS_COMPILE/arm-starfishmllib32-linux-gnueabi-ar $ export AS=$CROSS_COMPILE/arm-starfishmllib32-linux-gnueabi-as $ export CC=$CROSS_COMPILE/arm-starfishmllib32-linux-gnueabi-gcc $ export CXX=$CROSS_COMPILE/arm-starfishmllib32-linux-gnueabi-g++ $ export CPP=$CROSS_COMPILE/arm-starfishmllib32-linux-gnueabi-cpp $ export LD=$CROSS_COMPILE/arm-starfishmllib32-linux-gnueabi-ld $ export NM=$CROSS_COMPILE/arm-starfishmllib32-linux-gnueabi-nm $ export STRIP=$CROSS_COMPILE/arm-starfishmllib32-linux-gnueabi-strip $ export OBJCOPY=$CROSS_COMPILE/arm-starfishmllib32-linux-gnueabi-objcopy $ export OBJDUMP=$CROSS_COMPILE/arm-starfishmllib32-linux-gnueabi-objdump $ export SYSROOT=/opt/starfish-sdk-x86_64/5.0.0-20190307/sysroots/ca9v1-starfishmllib32-linux-gnueabi \\ ./configure \\ --enable-cross-compile \\ --cc=$CC --cxx=$CXX --strip=$STRIP --nm=$NM --ld=$LD --target-os=linux \\ --sysroot=$SYSROOT --prefix=/usr --arch=armv7-a --cpu=cortex-a9 \\ --extra-ldflags='-lt -lpthread -lm -pipe'  $ make  ","categories": ["linux-compile"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-compile/configure_file/",
        "teaser": null
      },{
        "title": "cross compile",
        "excerpt":"Keyward     EABI: 임베디드 응용 프로그램 이진 인터페이스   Toolchain Program                   명령       설명                       addr2line       실행 파일 안의 디버그 심볼을 읽어서 프로그램 주소를 파일 이름과 행 번호로 변환한다. 시스템 크래시 리포트에 출력된 주소를 해독할 때 매우 유용하다.                 ar       아카이브 유틸리티 static 라이브러리를 만들 때쓰인다.                 as       GNU 어셈블러                 c++filt       C++와 자바 심볼을 복원(demangle)할 때 쓰인다.                 cpp       C 전처리기, #define #include 등의 지시자를 확장할 때 쓰인다.                 ld       GNU 링커                 nm       오브젝트 파일의 심볼 나열                 strip       오브젝트 파일의 디버그 심볼 테이블을 없애 파일 크기를 줄여준다. 흔히 타깃에 복사할 모든 실행 코드에 적용한다.                 elfedit       ELF 파일의 ELF 헤더를 업데이트할 때 쓰인다.                 g++       GNU C++                 gcc       GNU C                 gconv       코드 커버리지 도구                 gdb       GNU 디버거                 gprof       프로그램 프로파일링 도구                 objcopy       오브젝트 파일 복사 및 번역                 objdump       오브젝트 파일 정보 출력시 사용                 ranlib       static 라이브러리 안의 인덱스를 만들거나 수정해 링크 단계를 더 빠르게 한다.                 readelf       ELF 오브젝트 형식의 파일에 정보를 출력한다.                 size       섹션 크기와 전체 크기를 나열한다.                 strings       파일 안의 인쇄 가능 문자열들을 출력한다.           build, host, target      build: 현재 플랫폼   host: 설치될 플랫폼   target: 실행될 플랫폼                  Types       Set Keyword                       native build, install       build = host = Target                 native build, cross-compile       build != host = target                 libc for cross-compiler       build = host != target                 libc for a cross-compiler, cross-compile       build != host != target              x86에서 컴파일러 빌드, arm에서 eabi쓰는 임베디드 환경에서 바이너리 실행 할 것            build=i686-pc-linux-gnu host=arm-none-linux-gnueabi &lt;Native Compiler&gt;           x86 linux에서 컴파일러 빌드, ARM용 바이너리를 putty로 내 x86컴퓨터에서 디버깅            (“gdbserver:1234 a.out”, to start debugging and listen on port 1234)       build=i686-pc-linux-gnu host=i686-pc-linux-gnu target=arm-none-gnu           compiler vendor      arch-vendor-os-toolsupport-cmd 형식   arm 32bit -march=armv7-a            arm-linux-gnueabi-gcc       arm-starfishmllib32-linux-gnueabi-g++       arm-unknown-android-gnueabihf-ld           arm 64bit -march=armv8-a            aarc64-linux-gnueabihf-gcc       aarc64-linux-android28-clang           cross compile option for ARM  NEON, VFP 지원 유무      NEON            ARM SIMD Extension NEON 기술       ARM에서 개발한 64/128bit 복합 SIMD Architecture       Single precision       프로세서의 일부지만, 자체 실행 파이프라인 가짐       ARM 레지스터 배읔와는 별개의 레지스터 뱅크를 가짐       NEON 명령어는 ARM, Thumb-2에서 모두 사용 가능       ARMv7-A, ARMv8-A 등 Cortex-A 계열은 모두 지원           VFP            부동 소수점을 위한 HW 가속기       Double precision 지원       NEON과 달리 병렬 아키텍처 가지지 않는다.       단순히 ARM과 같은 프로세서에서 SW math lib에 의존해 느려지는 부동 소수점 연산의 속도 향상 목적           속도: NEON &gt; VFP   $ arm-none-linux-gnueabi-gcc -O3 -march=armv7-a -mtune=cortex-a8 -mfpu=neon -ftree-vectorize -mfloat-abi=softfp  $ arm-none-linux-gnueabi-gcc -O3 -march=armv7-a -mtune=cortex-a8 -mfpu=vfp -ftree-vectorize -mfloat-abi=softfp      -mfloat-abi=[name] -mfpu=[fpu]  어떤 floating-point ABI를 사용할 것인가? fpu는 neon? vfp?                  name       description       fpu       gnueabi[hf]                       soft       GCC가 floating-point operation에 대한 라이브러리 콜들을 포함하는 아웃풋을 생성한다.       -       gnueabi                 softfp       HW floating-point inst를 사용하는 코드의 생성을 허락 하지만, soft-float 호출 규약 사용       neon vfp       gnueabi                 hard       FPU특화 호출 규약 사용       neon       gnueabihf           ARM toolchian Setting  1. ARM toolchain - linaro      64-bit ARM-v8a   $ sudo apt install binutils-aarch64-linux-gnu gcc-aarch64-linux-gnu g++-aarch64-linux-gnu     32-bit ARM-v7a -mfloat-abi=hard -mpfu=FPU   $ sudo apt install gcc-arm-linux-gnueabihf      32-bit ARM-v7a -mfloat-abi=soft/softfp -mfpu=neon/vfp   $ sudo apt install gcc-arm-linux-gnueabi      Bare-metal ARM   $ sudo apt install gcc-arm-none-eabi   update-alternatives      update-alternatives: 여러 버전의 gcc 선택적 사용 가능   $ update-alternatives --query gcc   등록     여기서 사용하는 여러 gcc 버전들을 설치한 후에 다음과 같은 명령어로 등록할 수 있다.   $ update-alternatives --install &lt;link&gt; &lt;name&gt; &lt;path&gt; &lt;priority&gt;      link: 실행파일 이름으로 /etc/alternatives/ 를 가리킨다.            예: /usr/bin/gcc           name: 해당 링크 그룹의 대표 이름으로, 여러 가지 버전의 패키지들을 대표하는 이름으로 보면 될 것이다.            예: gcc           path: alternatives로 실제 연결할 실행파일 이름으로, 시스템에 설치한 패키지의 실행파일 이름이다.            예: /usr/bin/gcc-4.8           priority: automatic 모드에서 어떤 것을 자동으로 선택해서 사용할지 결정할 때 사용되는 우선순위로, 높은 수가 더 높은 우선순위   1. gcc 등록     만약 gcc-4.8, g++-4.8 사용 중인 경우   $ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 50 --slave /usr/bin/g++ g++ /usr/bin/g++-4.8     master를 gcc로, slave를 g++로 등록해봄   2. 설정된 버전 표기      gcc 버전 보기   $ sudo update-alternatives --list gcc /usr/bin/gcc-4.8 /usr/bin/gcc-5   $ sudo update-alternatives --display gcc   3. gcc 버전 교체하기     –config를 사용해서 교체해서 사용할 수 있다.            gcc 버전을 교체해보자           $ update-alternatives --config gcc There are 2 choices for the alternative gcc (providing /usr/bin/gcc).    Selection    Path              Priority   Status ------------------------------------------------------------ * 0            /usr/bin/gcc-4.8   20        auto mode   1            /usr/bin/gcc-4.8   20        manual mode   2            /usr/bin/gcc-5     10        manual mode  Press &lt;enter&gt; to keep the current choice[*], or type selection number: 2   $ g++ --version g++ (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609 Copyright (C) 2015 Free Software Foundation, Inc.   3. 삭제     설정한 내역을 지워버리고 싶을 때에는 –remove 옵션 사용   $ sudo update-alternatives --remove &lt;name&gt; &lt;path&gt; $ sudo update-alternatives --remove-all gcc\t# gcc 설정내역 전부 제거   Raspberry pi Toolchain 등록하기      라즈베리파이 툴체인 등록하는 경우   $ git clone https://github.com/raspberrypi/tools ~/raspberrypi/tools     다운로드한 tools 밑에 32bit, 64bit 컴파일러가 있다.            32bit: ~/raspberrypi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin       64bit: ~/raspberrypi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin               라즈베리파이용 컴파일러를 등록하자   64bit raspberrypi gcc 등록   $ sudo update-alternatives --install /usr/bin/arm-linux-gnueabihf-gcc arm-linux=gnueabihf ~/raspberrypi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin/arm-linux-gnueabihf-gcc-4.8.3 30 \\ --slave /usr/bin/arm-linux-gnueabihf-g++ arm-linux-gnueabihf-g++ ~/raspberrypi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin/arm-linux-gnueabihf-g++     32bit raspberrypi gcc 등록   $ sudo update-alternatives --install /usr/bin/arm-linux-gnueabihf-gcc arm-linux=gnueabihf ~/raspberrypi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin/arm-linux-gnueabihf-gcc-4.8.3 20 \\ --slave /usr/bin/arm-linux-gnueabihf-g++ arm-linux-gnueabihf-g++ ~/raspberrypi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin/arm-linux-gnueabihf-g++      GNU Tools 그룹 추가   크로스 플랫폼 환경에서 소스를 빌드하다 보면 GNU Tools를 해당 그룹에 추가할 필요가 있다. 여기서 예로든 python 3.6 빌드시 readelf 유틸리티를 요구하는데 우분투 배포본에 arm-linux-gnueabihf-gcc 그룹에 슬레이브로 arm-linux-gnueabihf-readelf 바이너리를 추가해 준다.   이제 arm-linux-gnueabihf- 버전을 교환할 수 있는 환경이 준비됨   $ sudo update-alternatives --display arm-linux-gnueabihf $ sudo update-alternatives --list arm-linux-gnueabihf   $ sudo update-alternatives --list gcc /usr/bin/gcc-4.8 /usr/bin/gcc-5  $ sudo update-alternatives --display gcc   cross-compiler로 교체   $ sudo update-alternatives --config arm-linux-gnueabihf   hello world - C   #include &lt;stdio.h&gt;  int main(void){ \tprintf(\"hello world!\\n\"); \treturn 0; }   $ arm-linux-gnueabihf-gcc hello.c -o hello   hello world - C++   #include &lt;iostream&gt;  using namespace std;  int main(int argc,char *argv[]){ \tcout &lt;&lt; \"hello world!\\n\"; \treturn 0; }   $ arm-linux-gnueabi-g++ hello.cpp -o hello_cpp  2. ARM toolchain - 수동 설치              툴체인 압축풀기 at /opt/starfish-sdk-x86_64/….            환경변수 설정       $ vim ~/.bashrc # ~/.bashrc 파일 ========================================= export PATH=/opt/starfish-sdk-x86_64/5.0.0-20190307/sysroots/x86_64-starfishsdk-linux/usr/bin/arm-starfishmllib32-linux-gnueabi:$PATH export SYSROOT=/opt/starfish-sdk-x86_64/5.0.0-20190307/sysroots/ca9v1-starfishmllib32-linux-gnueabi      build 파일은 x86_64(build 컴퓨터)가 읽을 수 있어야함   sysroot는 크로스 컴파일 때, 루트 ‘/’로 보는 경로            ex) 컴파일시 CFLAGS에 –sysroot=$SYSROOT로 설정 함 그러면, 환경 변수에 지정된 …sysroots/ca9v1-starfishmllib32-linux-gnueabi를 target이 ’/’ 루트 디렉터리로 인식           따로 필요한 헤더파일들은 $SYSROOT/usr/include에 저장   컴파일 install 결과는 $SYSROOT/usr/bin $SYSROOT/usr/lib등에 저장됨   # OpenCL 헤더 파일이 필요하다면 $ cp -R /usr/include/CL $SYSROOT/usr/include   cross-compile 기본  sysroot      sysroot: 크로스 컴파일에선 sysroot가 필수!  export SYSROOT=”toolchain의 sysroot” Target은 지정한 SYSROOT를 ’/’ 루트 디렉터리로 인식  Target용 파일은 $SYSROOT/usr, $SYSROOT/usr/lib, $SYSROOT/usr/include 등에서 가져와 컴파일 함            컴파일 install 결과는 $SYSROOT/usr/bin $SYSROOT/usr/lib등에 저장됨           따로 지정하지 않았는데 컴파일이 된다면     $ arm-linux-gnueabi-gcc -v\t# 이 명령로 컴파일러에 셋된 옵션 확인 $ arm-linux-gnueabi-gcc -print-sysroot\t# sysroot만 print          입력 시, gcc가 미리 셋 해둔 sysroot 등이 출력됨. 이걸 써서 그럼.       완전 수동으로 한다면..     $ arm-linux-gnueabi-gcc --sysroot=/opt/starfish-sdk&lt;생략&gt; like.c -o like           ","categories": ["linux-compile"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-compile/cross_compile/",
        "teaser": null
      },{
        "title": "ctags, cscope",
        "excerpt":"ctags     Ctags is a programming tool that generates an index (or tag) file of names found in source and header files of various programming languages to aid code comprehension.   The original Ctags was introduced in BSD Unix 3.0 and was written by Ken Arnold   from Wiki       아래 커맨드를 입력시 tags가 만들어 진다.     $ ctags -R           vim과 연동해야 vim에서 먹힌다.     # vim을 열고...! :set tags=[tags file 위치]           vim을 열때마다 이럴 순 없지 않은가..! 자동 연동 설정하자!     $ vim ~/.vimrc\t# vim 설정 파일 진입 $ set tags=./tags                 설정을 보면 알겠지만, ./tags가 먹히는 위치에서 vim을 켜야 자동 연동           ctags 커맨드      ctrl + ]:   ctrl + t:   cscope     ctags만으로는 local, global variable이 사용된 곳이나, 함수가 사용된 곳 찾기 힘들다.      cscope.out 파일을 만들어야 한다.   $ find ./ -name \"*.[csSh]\" &gt; file_list $ find ./ -name \"*.cpp\" &gt;&gt; file_list $ find ./ -name \"*.cc\" &gt;&gt; file_list  $ cscope -i file_list ctrl + d      커맨드를 보면 알겠지만, 현재 폴더에서 .c, .s, .S, .h, .cpp, .cc 파일을 찾아서 file_list에 넣는다.   cscope -i file_list는 file_list내에 파일을 cscope가 한 줄씩 읽어서 cscope.out 파일 생성한다.   그런데 이거 매번 하기 귀찮으니 쉘로 만들고 어디에서나 사용가능하게 /usr/local/bin에 넣자  mkcscope.sh   mkcscope.sh   #!/bin/bash rm -rf cscope.files file_list find ./ -name \"*.[csSh]\" &gt; file_list find ./ -name \"*.cpp\" &gt;&gt; file_list find ./ -name \"*.cc\" &gt;&gt; file_list  cscope -i file_list  $ chmod +x mkcscope.sh $ sudo mv ./mkcscope.sh /usr/local/bin   어디서든 mkcscope.sh 실행 시, 내 현재 위치에 cscope.out을 만들어 준다.   vim연동   set csprg=/usr/local/bin/cscope set nocsverb  if filereadable(\"./cscope.out\") cs add cscope.out else cs add /usr/local/bin/cscope.out endif  set csverb set csto=0 set cst   cscope 커맨드   # vim에서 :cs f [질의 종류] [심볼] :cs f s start_kernel\t\t# 예                  search type       number       Description                       s       0       C 심볼을 검색 변수, 함수, 매크로, 구조체 등                 g       1       전역 선언, 정의 검색                 d       2       함수에 의해 호출되는 함수들 검색 cs f 2 get_src ==&gt; get_src함수가 Call하는 함수들 나열 get_src==&gt; main, others                 c       3       함수를 호출하는 함수들 검색 cs f 3 get_src ==&gt; get_src를 호출하는 함수들 나열 main, others ==&gt; get_src                 t       4       텍스트 문자열 검색                 e       5       확장 정규식을 사용해 검색                 f       6       파일 이름을 검색                 i       7       파일을 인클루드하는 파일 검사              space bar: 내리기   q: 나가기   ","categories": ["linux-tools"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-tools/ctags_cscope/",
        "teaser": null
      },{
        "title": "후킹(Hooking)",
        "excerpt":"Hooking     후킹: OS나 App등에서 함수 호출, 메시지, 이벤트 등을 중간에서 바꾸거나 가로챔. 이때 간섭된 함수 호출, 이벤트, 메시지를 처리하는 코드를 후크라고 한다.            shared library을 사용하여, 기존 바이너리에서 API 를 호출할 때 가로채, 내가 정의한대로 사용케함           주의점            LD_PRELOAD는 SU가 Set 되어 있으면 무시된다. 보안상 이유       init constructor, destructor에서 system, fork, popen으로 프로세스를 실행시키면 그 프로세스도 constructor, destructor 명령을 실행하기 때문에 정말 주의 무한 실행된다.           속성            LD_PRELOAD에 설정된 shared library는 모든 shared library보다 먼저 로딩       타인 소유 파일에도 동작       secure-execution mode로 실행되면 제약이 걸린다.       overloading을 따지지 않고 함수 이름 일치만하면 후킹된다.       main은 후킹 안된다.       LD_PRELOAD에 등록한 library가 위치한 path가 LD_LIBRARY_PATH 나 /etc/ld.so.conf에 등록되어 있을 필요는 없다.       LD_PRELOAD나 /etc/ld.so.conf 에 등록된 디렉터리에 위치한 라이브러리는 라이브러리 파일 이름만 적어도 인식한다.       wrapper function가 실행 시, 원래 함수가 실행되어야 하면 dlsym을 사용해 원래 함수 포인터를 얻은 뒤 return origin_function       dlsym을 이용하기 위해 #include &lt;dlfcn.h&gt; 사용 및 -ldl 링크 옵션       RTLD_NEXT는 #define _GNU_SOURCE해야 정의된다.           실행 커맨드      후킹코드를 담아 제작한 shared library를 LD_PRELOAD로 실행해야한다.      특정 바이너리 실행     $ LD_PRELOAD=/where/library/path [binary path]           쉘에 등록한 다음 사용 (어떤 바이너리든 실행히 LD_PRELOAD 동작)     $ export LD_PRELOAD=/where/library/path                etc/ld.so.preload에 등록해 계정 상관없이 시스템 전역으로 후킹       2개 이상 PreLoad 하는 법     $ LD_PRELOAD=\"lib1.so lib2.so\" ./app           구현           후킹을 구현하는 shared library 본체와 header file로 나뉜다.       header file   shared library            constructor       Define hooked function       destructor           header   clGetPlatformInfo() 함수를 후킹해 사용하고자 한다!        clGetPlatformInfo라는 API를 후킹해서 여러 파일에 사용하고 싶다면, 위와 같이 헤더파일에 정의   Hook_API.h   cl_int (*clGetPlatformInfo_real)(cl_platform_id, cl_platform_info, size_t, void *, size_t *);   constructor      후킹을 하는 shared library 본체의 constructor   Hook_Library.c   #include &lt;stdio.h&gt; #include ...some system headerfiles #include \"Hook_API.h\" #define _GNU_SOURCE_ #include &lt;dlfcn.h&gt;  void __attribute__((constructor)) init_hooking(){ \tclGetPlatformInfo_real = (cl_int (*)(cl_platform_id, cl_platform_info, \\ \t\t\t\tsize_t, void*, size_t *))dlsym(RTLD_NEXT, \"clGetPlatformInfo\"); }        RTLD_NEXT사용 위해 #define _GNU_SOURCE정의            혹시라도 #define _GNU_SOURCE가 안먹히면, 컴파일 때 전처리기 옵션으로  -D_GNU_SOURCE 주기           dlsym() 사용 위해,  #include &lt;dlfcn.h&gt; 및 -ldl 링크 옵션            Dynamic Library - runtime loaded libs는 여기 참고                constructor에서 후킹하고 싶은 함수를 명시한다.    origin함수주소=(return자료형 (*)(arg1자료형..))dlsym(RTLD_NEXT, “후킹 하고픈 함수”);        앞으로 “후킹 하고픈 함수”가 Call되면 내가 정의한대로 사용 가능   “후킹 하고픈 함수”의 실제 함수는 origin함수주소가 담긴 변수에 담겨서 사용가능   Define hooked function    Hook_Library.c   #include &lt;stdio.h&gt; #include ...some system headerfiles #include \"Hook_API.h\" #define _GNU_SOURCE_ #include &lt;dlfcn.h&gt;  void __attribute__((constructor)) init_hooking(){ \tclGetPlatformInfo_real = (cl_int (*)(cl_platform_id, cl_platform_info, \\ \t\t\t\tsize_t, void*, size_t *))dlsym(RTLD_NEXT, \"clGetPlatformInfo\"); }  cl_int clGetPlatformInfo(cl_platform_id platform, cl_platform_info param_name, \\ \t\t\t\t\tsize_t param_value_size, void *param_value, size_t *param_value_size_ret){  \t/* Define What you want to do */  \tcl_int err=clGetPlatformInfo_real(platform, param_name, param_value_size, param_value, param_value_size_ret); \t\t\t\t\t\t\t\t\t// If you want to call original API  \treturn err; }              응용 프로그램에서 Hook한 함수 Call시, 우리가 정의한 Scope가 사용된다.            바로 “return Origin함수주소” 로 원본 함수 return 하면 그게 그거       destructor       _destructor_에서는 후킹 라이브러리가 종료할 때 취할 행동 정의   Hook_Library.c   #include &lt;stdio.h&gt; #include ...some system headerfiles #include \"Hook_API.h\" #define _GNU_SOURCE_ #include &lt;dlfcn.h&gt;  void __attribute__((constructor)) init_hooking(){ \tclGetPlatformInfo_real = (cl_int (*)(cl_platform_id, cl_platform_info, \\ \t\t\t\tsize_t, void*, size_t *))dlsym(RTLD_NEXT, \"clGetPlatformInfo\"); }  cl_int clGetPlatformInfo(cl_platform_id platform, cl_platform_info param_name, \\ \t\t\t\t\tsize_t param_value_size, void *param_value, size_t *param_value_size_ret){  \t/* Define What you want to do */  \tcl_int err=clGetPlatformInfo_real(platform, param_name, param_value_size, param_value, param_value_size_ret); \t\t\t\t\t\t\t\t\t// If you want to call original API  \treturn err; }  void __attribute__((destructor)) done_hooking(){ }      Compile      다시 강조하지만 컴파일 때, -ldl 링크 필수   #define _GNU_SOURCE가 안먹히면 -D_GNU_SOURCE 옵션 추가   $ gcc -fPIC -c -L. Hook_Library.c Hook_API.h -ldl $ gcc -shared -L. Hook_Library.o -ldl -o Hook_Library   사용   $ LD_PRELOAD=./Hook_Library ./binary   ","categories": ["linux-system"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-system/linux_linux-system_hooking/",
        "teaser": null
      },{
        "title": "리눅스 자주 쓰는 Shell 커맨드",
        "excerpt":"패키지 관련     apt provides a high-level commandline interface for the package management system. It is intended as an end user interface and enables some options better suited for interactive usage by default compared to more specialized APT tools like apt-get and apt-cache. - “man apt”       Ubuntu 패키지 관리 툴 명령어 apt                  apt 명령       설명                       $ apt update       Repository 패키지 인덱스 정보 업그레이드                 $ apt upgrade       설치되어 있는 패키지 업그레이드                 $ apt dist-upgrade       의존성 검사하며 업그레이드                 $ apt install [패키지 이름]       패키지 설치                 $ apt --reinstall install [패키지 이름]       패키지 재설치                 $ apt remove [패키지 이름]       패키지 삭제 설정 파일 미포함                 $ apt purge [패키지 이름]       패키지 삭제 설정 파일 포함                 $ apt autoremove       불필요한 패키지 제거                 $ apt full-upgrade       의존성 고려한 패키지 업그레이드                 $ apt search [키워드]       키워드를 가진 패키지 검색                 $ apt show [패키지]       패키지 상세 정보 출력                 $ apt list       Repository에 등록된 패키지 목록 조회           $ apt show docker.io로 도커 패키지 상세 정보 출력     $ apt list로 패키지 목록 조회     패키지 업데이트      패키지 목록: /var/lib/apt/lists   레파지토리 목록: /etc/apt/sources.list   압축     tar 압축     $ tar -cvf aaa.tar abc                 aaa.tar &lt;== abc           tar 압축 풀기     $ tar -xvf aaa.tar                 aaa.tar ==&gt; aaa           tar.gz 압축     $ tar -zcvf aaa.tar.gz abc                 aaa.tar.gz &lt;== abc           tar.gz 압축 풀기     $ tar -zxvf aaa.tar.gz                 aaa.tar.gz ==&gt; aaa                          Option       Description                       -C       파일 경로 지정                 -p       파일 권한 저장                 -v       파일 압축, 압축풀기 때 화면으로 출력                 -f       파일 이름 지정                 -c       tar                 -z       gz           와일드카드, 정규식     ^d: 시작 문자가 d   hello*: hello~~~ 뒤엔 상관없는 모든 파일   [ts]*: t 혹은 s로 시작하는 모든 파일   [0-9]*: 0~9로 시작하는 모든 파일   [a-zA-Z]*: a~z, A~Z로 시작하는 모든 파일        [!a-z]*: a~z로 시작 하지 않는 모든 파일       [[:upper:]]*: 대문자로 시작하는 모든 파일        [![:upper]]*: 대문자로 시작하지 않는 모든 파일       ?: 앞 문자 있어되고 없어도 되고!            books?: 's'가 있어도되고 없어도된다. =&gt; book, books           .: Don’t care 1문자            book.: . 위치에 한 문자는 와야한다. =&gt; books, bookt, …           $: 문자$ 에서 ‘문자’로 끝나는 것            e$: xxxxxxe           a{aa,bc,dd}: aaa abc add            $ mkdir -p dir{1,2,3} =&gt; mkdir -p dir1 dir2 dir3           특수 파라미터     $#: 파라미터 전체 갯수   $?: 최근에 종료된 프로세스 return 값   $-: set 내장명령을 통해 또는 쉘 자체에 의해(ex, -i) 설정된 현재 옵션 플래그로 확장한다.   $$: 현재 쉘의 PID   $!: 가장 최근 실행된 프로세스의 PID   $0: 쉘 또는 쉘 스크립트의 이름을 가지고 있다.   $_: 실행된 쉘 스크립트의 절대 경로를 가지고 있다.   $[1~9]: 1~9번째 아규먼트        ${10~}: 10번 째 아규먼트 부터       ${#변수} : 몇 글자?   $ test=\"That that is is not not\" $ echo ${#test} 23      ${변수:string 시작 idx} : 시작idx부터 끝까지   \t0123456789....        $ test=\"That that is is not not\" $ echo ${test:3} t that is is not not      ${변수:string 시작 idx:몇글자} : 시작 idx부터 몇 글자   \t0123456789....        $ test=\"That that is is not not\" $ echo ${test:3:5} t that   shell cmd  find      현재 디렉터리 + 하위 디렉터리 파일 검색     $ find . -name \"*STR\"           하위 디렉터리 검색하지 않음     $ find . -maxdepth 1 -name \"FILE\"           파일 검색 후 삭제     $ find . -name \"FILE\" -delete           파일, 디렉터리만 검색     $ find . -name \"FILE\" -type f           wc (갯수)      현재 디렉터리에서 디렉터리 개수     $ ls -l | grep ^d | wc -l           현재 디렉터리에서 파일 개수     $ ls -l | grep ^- | wc -l           현재 + 하위 디렉터리 recursive 디렉터리 개수     $ ls -Rl | grep ^d | wc -l           grep    wildcard 사용 말것!  ex) grep “*STR” (x), grep “STR” (o)                  Option       Description                       -i       대소문자 무시                 -r       하위 까지 search                 -v       패턴 없는 것만 출력                 egrep “donald | trump”       정규식 사용              현재 디렉터리의 *.c 파일에서 cp 문자열 찾기   $ grep \"cp\" ./*.c      현재 디렉터리 + “하위 디렉터리” *.c 파일에서 cp 문자열 찾기   $ grep -r \"cp\" ./*.c   function      명령어에 Argument로 커맨드 넣기   $ function m() { minicom -w -D/dev/ttyS${1}; } $ function 10\t# ${1] &lt;= 10      Argument로 cp   $ function cpresult() { cp ${1}result.csv ./result${2}.csv; }   echo      -e: 개행 문자(“\\n”) 사용케 함 (원래는 안됨)   $ echo -e 'hello \\n' hello   $ echo 'hello \\n' hello \\n       -n: 자동 줄바꿈 하지 않음   user@linux$ echo -n 'hello' hellouser@linux$      *: 현재 디렉터리 내용이 ‘ ‘ 공백문자를 두고 나옴      read      read: 사용자로 부터 입력을 받음(스페이스도 받음, 엔터를 만나면 끝냄) ≒ gets()   $ read num 34\t\t# num &lt;= 34  $ echo $num 34   $REPLY      $REPLY: read 명령어에서 사용하는 디폴트 변수 read 에서 따로 변수를 안두면 자동으로 저장됨   $ echo \"Are  you ready ?\" $ read y $ echo $REPLY y   wc      wc -c [파일]: 파일이 몇 Byte인가?   wc -m [파일]: 파일 안에 글자 갯수는?   wc -l [파일]: 파일 내 라인 수?   대입, 테스트   $(), $(())      Command Substitution  $(command) : 명령 대체     $ VAR=$(ipcs | awk '$2==2 ${print $1}') $ echo=$VAR           Arithmetic expansion  $((expression)) : 산술연산     $ i=$(($i+1))           $(()) $[ ] 계산 대입 vs (()) [] 테스팅    # 계산 대입 i=5 i=$(($i+1)) i=$[$i+1]  # 테스팅   ∨\t\t# 띄워 쓰기! if ((i&lt;=1)) then \techo $i fi   ∨ ∨ ∨   ∨ ∨\t# 띄워 쓰기! if [ $i -le 1 ] then \techo $i fi   문자 비교                   비교 문       Description                       문자1 == 문자2       문자1과 문자2가 일치 시, true                 문자1 != 문자2       문자1과 문자2가 불일치 시, true                 -z 문자       문자 == null 시, true                 -n 문자       문자 != null 시, true           문자 존재 유무       특정 문자 존재 유무  [[ ]] 반드시 두 개사용   string=\"abc\"  if [[ $string =~ \"a\" ]]; then \techo \"true\" else \techo \"false\" fi   $ echo \"Are you eady?\" $ read ; if [[ $REPLY =~ ^[yY]$ ]] ; then echo \"true\" ; fi y true $     [[ =~ ]]: 문자열 비교 패턴   ^: 맨 첫글자 찾기   $: 맨 끝 글자   =~: 우측에 정규표현식 패턴을 사용   수치 비교                   비교 문       Description       뜻                       값1 -eq 값2       값1 == 값2       equal                 값1 -ne 값2       값1 != 값2       not equal                 값1 -lt 값2       값1 &lt; 값2       less than                 값1 -le 값2       값1 &lt;= 값2       less equal                 값1 -gt 값2       값1 &gt; 값2       greater than                 값1 -ge 값2       값1 &gt;= 값2       greater equal           논리 연산                   옵션       Description                       조건1 -a 조건2       AND                 조건1 -o 조건2       OR                 조건1 &amp;&amp; 조건2       양쪽 다 성립                 조건1 || 조건2       한쪽 또는 양쪽 다 성립                 !조건       조건이 성립하지 않음                 true       조건이 언제나 성립                 false       조건이 언제나 성립하지 않음           파일 검사    $ if [ -f hi ]\t# hi가 파일이면 true                  옵션       Description                       -e 파일명       파일이 존재 시 참                 -d 파일명       파일이 디렉터리면 참                 -h 파일명       파일이 심볼릭 링크 파일                 -f 파일명       파일이 일반 파일이면 참                 -r 파일명       파일이 읽기 가능이면 참                 -w 파일명       파일이 쓰기 가능이면 참                 -x 파일명       파일이 실행 가능이면 참                 -s 파일명       파일의 크기가 0이 아니면 참                 -u 파일명       파일의 set-user-id가 설정되면 참           ( ) : sub shell group      내부 명령이 서브 쉘에서 실행되는 경우     $ u2dos() ( set -f; IFS=''; printf '%s\\r\\n' $(cat \"$1\") )           { } : inline group      중괄호 안의 명령은 마치 하나의 명령처럼 취급된다.     $ { local v1; v1=123; }           배열       배열 선언 및 참조하기   #!/binb/ash arr=(1 2 3 4 5 6 7 8 9 10 15 20 25 30)  echo \"${arr[0]}\"\t# 배열 idx 0번 참조 echo \"${arr[*]}\"\t# 배열 전부 출력 echo \"${arr[@]}\"\t# 배열 전부 출력 echo \"${!arr[@]}\"\t# 배열 인덱스 넘버 전부 출력 echo \"${#arr[@]}\"\t# 배열 size echo \"${#arr[0]}\"\t# 배열 특정 인덱스 사이즈         배열 for文   #!/bin/bash arr=(1 2 3 4 5 6 7 8 9 10 15 20 25 30)  for (( i=0 ; i &lt; ${#arr[@]} ; i++ )) ; do \techo \"${arr[$i]}\" # 배열 사이즈 done   1  2  3  .. 쭉 echo   #!/bin/bash classrom=(desk pen note chair book)  echo ${classroom[@]} echo ${#classroom[@]}  for i in #{classroom[@]}; do \techo $i done      연산자(expr)      역할: 숫자 계산 사용하는 경우 ` 를 사용해야한다. 연산자 *와 괄호 ( ) 앞에는 역 슬래시\\와 사용   연산자, 숫자, 변수, 기호 사이에는 space를 넣어야 함   num=`expr \\( 3 \\* 5 \\) / 4 + 7` echo $num 10   if 文      if   if [ 조 건 ] then \t명 령 fi  if [ 조 건 ]; then 명 령 ; fi      if else   if [ 조 건 ] then \t명 령  else \t명 령 fi  if [ 조 건 ]; then 명 령; else 명 령; fi      if elif   if [ 조 건 ] then \t명 령 elif [ 조 건 ] then \t명 령 fi  if [ 조 건 ]; then 명 령; elif [ 조 건]; then 명 령; fi   while 文    i=1  while [ $i -lt 5 ] do \techo $i \ti=$(($i+1)) done  i=1; while [ $i -lt 5 ] ; do echo $i; i=$(($i+1)) ; done   for 文    for (( i = 0; i &lt; 10 ; i++ )) do \t명 령 done  for (( i = 0; i &lt; 10 ; i++ )); do 명 령 ; done   Network  port      현재 시스템의 포트 할당 확인     $ lsof -i -P -n | grep -i listen                 시스템  우선순위      스케줄링 우선순위     $ nice [-n 조정수치] [cmd [arg..]]                          Option       Description                       無 옵션       nice는 상속받은 현재의 스케줄링 우선권을 출력한다                 -n [조정수치]       - 조정수치 생략 시, nice = 10  - su 권한 시, nice = 음수 가능  - 우선순위: -20 (高 priority ↑↑↑) ~ 19 (低 priority ↓↓↓)           마운트      마운트     $ mount [-fnrvw] [-t 파일시스템 유형] [-o 옵션] 장치명 디렉터리명 ex) $ mount -t vfat /dev/sdb1 /mnt/usb           언마운트     $ unmount 장치명 디렉터리명           환경변수  환경변수 미리 지정된 변수    $ echo $HOME /home/pllpokko                  ENV       Description                       HOME       사용자의 홈 디렉터리                 PATH       실행파일을 찾는 경로                 LANG       프로그램 사용 시 기본 지원되는 언어                 PWD       사용자의 현재 작업하는 디렉터리                 TERM       로그인 터미널 타입                 SHELL       로그인해서 사용하는 쉘                 USER       사용자의 이름                 DISPLAY       X 디스플레이 이름                 VISUAL       visual 편집기의 이름                 EDITOR       기본 편집기의 이름                 COLUMNS       현재 터미널이나 윈도우 터미널의 컴럼 수                 PS1       명령 프롬프트 변수                 PS2       2차 명령 프롬프트. 명령 행에서 사용하여 명령 행을 연장 햇을 때 나타냄                 BASH       사용하는 bash 쉘의 경로                 BASH_VERSION       bash의 버전                 HISTFILE       history 파일의 경로                 HISTFILESIZE       history 파일의 크기                 HISTSIZE       history에 저장되는 갯수                 HISTCONTROL       중복되어지는 명령에 대한 기록 유무를 지정하는 변수                 HOSTNAME       호스트의 이름                 LINES       터미널의 라인 수                 LOGNAME       로그인 이름                 LS_COLORS       ls 명령의 색상 관련 옵션                 MAIL       메일을 보관하는 경로                 MAILCHECK       메일 확인 시간                 OSTYPE       운영체제 타입                 SHLVL       쉘의 레벨                 TERM       터미널 종류                 UID       사용자의 UID                 USERNAME       사용자 이름           which/whereis      which: PATH 경로내 실행 파일 검색   whereis: 실행 파일, 소스, 맨페이지 위치   $ which bash /bin/bash $ whereis bash bash: /bin/bash /etc/bash.bashrc /usr/share/man/man1/bash.1.gz   vim  문자열 찾기      검색 문자열 뒤에 \\c   # vim /findstr\\c   ","categories": ["linux-system"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-system/linux_linux-system_linux-command/",
        "teaser": null
      },{
        "title": "pkg-config",
        "excerpt":"pkg-config     라이브러리의 메타 정보를 pkg-config가 관리   pkg-config 응용 프로그램 위치: /usr/bin/pkg-config   라이브러리 메타 정보 pkg-config 파일 *.pc 위치            /usr/lib/pkgconfig       /usr/share/pkgconfig       간혹 /usr/local/lib/pkgconfig에 위치  &lt;= export하자       /usr/lib/x86_64-linux-gnu/pkgconfig              autoconf에서 아래와 같은 추가 매크로 사용해 pkg-config 툴의 기능 결합해 활용 가능            PKG_PROG_PKG_CONFIG([MIN-VERSION]) pkg-config 프로그램의 위치,  해당 버전 이상의 버전이 설치되어 있는지 확인       PKG_CHECK_EXISTS(MODULES, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])                    찾고자 하는 모듈이 설치되어 있는지 확인           pkg-config --cflags ==&gt; &lt;VARIABLE-PREFIX&gt;_CFLAGS 변수           pkg-config --libs ==&gt; &lt;VARIABLE-PREFIX&gt;_LIBS 변수                           pkg-config 관리 리스트 보기      pkg-config가 관리하는 라이브러리 리스트 보기   $ pkg-config --list-all      pkg-config가 관리하는 모듈 시스템 설치 확인      pkg-config가 aom 라이브러리 모듈 설치 확인   $ pkg-config --exists aom   aom.pc pkg-config 뜯어보기   # libaom pkg-config. prefix=/home/pllpokko/aom/install exec_prefix=${prefix} includedir=${prefix}/include libdir=${exec_prefix}/lib  Name: aom Description: Alliance for Open Media AV1 codec library v2.0.0-279-gd75de538b. Version: 2.0.0 Requires: Conflicts: Libs: -L{libdir} -laom Libs.private: -lm -lpthread Cflags: -I${includedir}      Version: 패키지의 버전을 정의   Requires:            패키지가 의존하여 사용하는 다른 패키지의 이름의 목록으로 공백으로 구분한다.       비교 연산자(=, &lt;, &gt;, &lt;=, &gt;=)를 사용하여 버전을 지정할 수 있다.           Requires.private:            패키지가 의존하여 사용하는 다른 패키지의 이름의 목록으로 공백으로 구분한다.       단, Requires와 다르게 패키지 안에서만 사용하며 이 패키지를 가져다가 사용하는 App에는 사용할 필요 없을 패키지를 나열한다.       버전을 지정하는 형식은 Requires와 동일하다.           Conflicts:            옵션으로 정의하여 사용하는 키워드로 패키지와 충돌을 일으키는 다른 패키지를 목록 형식으로 정의한다.       버전을 지정하는 형식은 Requires와 동일.       ex) Conflicts: bar &lt; 1.2.3, bar &gt;= 1.3.0           Cflags:            외부에서 이 패키지를 가져다가 컴파일할 때 사용하는 컴파일러 옵션 플래그로, 이 패키지에서 의존하는 컴포넌트가 pkg-config 파일을 지원하지 않아서 컴파일러 옵션을 지정하도록 전달하기 위해 사용한다.       이 패키지에서 의존하는 컴포넌트가 pkg-config 파일을 지원한다면 Requires나 Requires.private에 이름만을 나열해야 한다.           Libs:            외부에서 이 패키지를 가져다가 링크할 때 사용하는 링크 옵션 플래그.       Cflags와 마찬가지로 이 패키지에서 Public하게 의존하는 컴포넌트가 pkg-config파일을 지원하지 않는 경우 링크 옵션을 지정하도록 전달하기 위해 사용한다.       이 패키지에서 의존하는 컴포넌트가 pkg-config 파일을 지원한다면 Requires 나 Requires.private에 지정해야 한다.           Libs.private:            외부에서 이 패키지를 가져다가 정적으로 링크할 때 사용하는 링크 옵션 플래그       이 패키지가 의존하여 사용하는 다른 패키지를 링크하는 옵션 플래그로 이 패키지를 가져다가 사용하는 App에서 직접 사용할 필요 없을 패키지에 대한 링크 옵션 플래그.       이 패키지에서 의존하는 컴포넌트가 pkg-config 파일을 지원한다면 Requires 나 Requires.private에 지정해야 한다.           aom 라이브러리 대상 pkg-config 응용프로그램 실행  version    $ pkg-config --modeversion aom 2.0.0   aom 라이브러리 사용하기 위한 컴파일 option      LDFLAGS, LIBS     $ pkg-config --libs aom -L/usr/local/lib -laom           LDFLAGS, LIBS, for 정적 컴파일     $ pkg-config --libs --static aom -L/usr/local/lib -laom -lm -lpthread           CFLAGS     $ pkg-config --cflags aom -I/usr/local/include           컴파일 시 활용     $ gcc `pkg-config --cflags --libs --static aom` app.c -o app          ","categories": ["linux-compile"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-compile/pkg-config/",
        "teaser": null
      },{
        "title": "strace - \"-g\" 컴파일 안된 바이너리 디버깅 유용 by syscall",
        "excerpt":"strace     strace: system-call tracer. 프로세스가 호출하는 시스템 콜을 화면에 출력한다. -g 옵션 없이 컴파일 된 바이너리 -&gt; strace 사용하자            시스템 콜, 리턴값 체크           #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt;  int main(){ \tint fd; \tfd=open(\"/usr/bin/cat\", O_WRONLY); \tif(fd&gt;=0) \t\tprintf(\"OK\\n\"); \treturn 0; }   빌드 후, print 안됨  -&gt; strace 실행   $ strace -tf ./example                     strace option       description                       -f       자식 프로세스가 fork되면, 자식 프로세스의 시스템 콜까지 출력해라                 -p pid       뒤에오는 pid 프로세스를 trace해라           ","categories": ["linux-tools"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-tools/strace/",
        "teaser": null
      },{
        "title": "파일 처리: 저수준 vs 고수준",
        "excerpt":"저수준 vs 고수준                  file processing       Description                 저수준 파일 처리       시스템 콜 Byte 단위 지정한 버퍼 크기만큼 R/W UNIX 계열에서만 호환 pread, pwrite를 통해 atomic실행 보장(Thread safe)                 고수준 파일 처리       POSIX C문자 단위, 줄 단위 R/W C 표준 이므로, C를 지원하는 모든 플랫폼에서 사용 가능 stdio 버퍼링 있음 버퍼링은 사용자 변수와 버퍼 사이의 메모리 복사, 버퍼와 커널 사이의 복사까지 중복되므로 메모리 대역폭을 비효율적 사용. 저수준 파일 처리보다 비효율적인 면이 있기에 real-time system과 같이 응답성과 성능을 중시한다면 고수준 파일 처리는 최소화(다양한 옵션이 있기 때문에 저수준 VS 고수준 단편 속도 비교 불가)             stdio 버퍼     stdio만의 독자적인 버퍼 사용            내부적으로 적절한 크기로 read()를 사용해 stdio 버퍼로 가져와, 프로그램이 요구한 만큼 반환           읽을 때, 버퍼링            적절한 크기만큼 시스템 콜 read()를 사용해 stdio 버퍼에 저장       프로그램이 요청하는 만큼 반환           쓰기 때, 버퍼링            바이트 단위, 줄 단위의 데이터를 전달받아 stdio 버퍼가 꽉차면 시스템 콜 write() 내부적 호출       스트림이 단말에 연결된 경우, 버퍼가 가득 찰 때까지 기다리지 않는다.                    '\\n'를 만나면 즉각적으로 시스템 콜 write() 호출(빠른 응답성 요구)                       setvbuf()를 이용해, 비 버퍼링 모드 셋, 즉시 write() 수행           멀티 스레드/프로세싱에서 파일 출력이 섞이지 않게 하려면 어떻게 하나?     복잡한 멀티 스레드를 적용한 네트워크 서버에서 로그 파일을 기록하는 데 있어서 로그 메시지가 서로 섞이지 않게 하고 싶다!!            저수준 출력 함수 사용                    저수준 출력은 atomic 보장 하므로, 저수준 출력을 사용한다.           장점: 성능을 해지치 않는다.           단점: 저수준 FILE I/O는 불편함                       Lock 이용                    장점: 간단           단점: lock쓰면 느림 -&gt; 빈번한 출력에서는 사용하지 않음                       직렬화를 이용하여 전문적으로 출력을 도맡아서 하는 프로세스나 스레드 둔다.                    장점: 신뢰성이 높음, 응답이 좋음           단점: 설계 과정 복잠                       mmap을 이용해 메모리에 쓰고 파일로 동기화하는 방법           저수준에서 printf     형식화된 출력(formatted print)란, 간단하게 printf   저수준에서 printf            snprintf()사용 후, write계열 함수 사용           len = snprintf(buf, sizeof(buf), \"counter : %d\", i);   write(fd, buf, len);                       dprintf()(POSIX.1-2008 표준)           dprintf(fd, \"counter: %d\", i);                           저수준 파일 처리 관련 함수     POSIX.1-2008                  저수준 함수       Description                 open()       파일 열기                 openat()       fd를 지정하여 파일 열기                 close()       파일 닫기                 create()       생성                 fcntl()       fd 조작                 fsync()       파일 동기화                 fdatasync()       메타 정보(access time, inode 정보 등)를 제외한 동기화                 dup(), dup2()       fd 복제                 read(), write()       읽기, 쓰기                 pread(), pwrite()       오프셋을 지정한 읽기 쓰기(시그널, 스레드에 안전)                 readv(), writev()       벡터 단위 읽기 쓰기                 dprintf()       저수준에서 printf (POSIX.1-2008에서 추가)                 lseek()       파일 위치 변경                 truncate()       파일 크기 변경                 fdopen()       fd를 고수준 파일 처리 스트림으로 변환                 renameat()       파일명 변경(POSIX.1-2008에서 추가)                 glob()       패턴 매칭되는 path명 찾기                 stat(), fstat(), fstatat()       파일 메타 정보 읽기           고수준 파일 처리 관련 함수                  고수준 함수       Description                 fopen(), fclose()       파일 스트림 열기, 닫기                 freopen(), fdopen()       파일 스트림을 지정한 파일 스트림으로서 열기, fd -&gt; 파일 스트림 변환                 setvbuf(), setbuf()       stdio 버퍼 설정                 fflush(), fpurge()       버퍼 비움, 버퍼 삭제                 fread(), fwrite()       문자열로서가 아닌 Byte로서 읽고 쓰기                 scanf()계열       형식화된 문자열 입력                 printf()계열       형식화된 문자열 출력                 fgetpos(), fsetpos(), fseek(), ftell(), rewind()       파일 스트림 위치 변경, 보고                 clearerr(), feof(), ferror()       파일 스트림 체크                 ftruncate()       파일 크기 변경                 fileno()       스트림-&gt;fd                 fmemopen(), open_memsteram()       메모리를 파일 스트림으로 열기(POSIX.1-2008)                 getline(), getdelim()       행단위, 구분자 단위로 읽기(POSIX.1-2008)                 getc_unlocked(), getchar_unlocked(), putc_unlocked(), putchar_unlocked()       getc, getchar, putc, putchar의 NON-BLOCKING           파일 관련 시스템 함수                  파일 관련 시스템 함수       Description                 umask()       umask값 조정                 mktemp()       임시 파일 생성                 remove(), unlink()       파일 삭제                 link()       링크 생성                 mkdir(), rmdir()       디렉터리 생성, 삭제                 opendir(), closedir(), fdopendir(), dirfd()       디렉터리 열고 닫기                 readdir(), rewinddir(), seekdir(), telldir()       디렉터리 읽기, 위치 변경/보고                 scandir(), alphasort()       디렉터리 스캔           메모  pread, pwrite,  만일 파일이 아닌 파이프에 입출력할 때는 read, write를 PIPE_BUF 이내의 길이로 입출력하는 경우에 atomic 보장 (PIPE_BUF는 POSIX표준에서 _POSIX_PIPE_BUF(512 Byte)의 최소 기준을 세우고 있음) 하지만, 대부분의 유닉스 계열의 PIPE_BUF는 이보다 훨씬 큰 값 지원(보통 Page의 영향을 받아 4KByte 배수)  ","categories": ["file"],
        "tags": [],
        "url": "https://markyang920413.github.io//file/system_programming-file-processing/",
        "teaser": null
      },{
        "title": "lowlevel I/O <1> read(), write(), open(), posix_fadvise(), ftruncate()",
        "excerpt":"stream                  FileDescriptor       매크로       Discription                       0       STDIN_FILENO       표준 입력, 기본 입력 스트림                 1       STDOUT_FILENO       표준 출력, 기본 출력 스트림                 2       STDERR_FILENO       표준 에러 출력, 별도 메시지 출력용           inotify   파일 시스템의 이벤트를 감시하는 inotify     최근 리눅스에는 파일 시스템 이벤트 감시하는 inotify   리눅스전용, 유닉스 X, 구형 리눅스 X   inotify 기능의 특징은 특정 파일에 접근, 읽기, 쓰기 등등 다양한 이벤트 감시가능   저수준 파일 제어 시스템 콜  read    #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; // for ssize_t, size_t  ssize_t read(int fd, void *buf, size_t bufsize);   기능: fd에 해당하는 스트림에서 Byte열을 읽는 시스템 콜                  return       value                 성공       읽어들인 Byte 수 0: 파일의 끝에 도달                 실패       -1                          parameter       Description                 fd       읽어올 대상 File descriptor fd에 해당하는 스트림에서 Byte 열을 읽음                 *buf       읽어와서 저장할 곳                 bufsize       얼마나 읽을 것임?           주의!: 문자열 끝에 ‘\\0’이 있다고 가정하지 않는 API이다.   write    #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt;  ssize_t write(int fd, const *buf, size_t bufsize);   기능: 지정한 buf 에서 bufsize만큼 지정한 fd 스트림에 write!                  return       value                 성공       write 한 Byte 수(0이상)                 실패       -1                          parameter       Description                 fd       Write할 대상 File descriptor                 *buf       여기서 읽어와서 write할 것임                 bufsize       얼마나 읽어올 것임?           open    #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt;  int open(const char *path, int flags); int open(const char *path, int flags, mode_t mode);   기능: path에서 지정한 경로의 파일에 대한 스트림을 flags를 통해 어떤 모드로 열것 인지?                  parameter       Description                 *path       지정한 경로의 파일에 대한 스트림을 만듬. 즉, 열 대상 파일 path                 flags       위 path 파일을 어떻게 열 것인지?                 mode       위 flags에서 O_CREAT을 설정했을 때만 유효하다. 새 파일을 만들 때, permission을 지정한다. 지정한 값이 그대로 그 파일의 권한이 되는 것은 아니다. 'mode &amp; ~umask'로 permission이 계산된다. umask 참고                              flags       Description                 O_RDONLY       읽기 전용                 O_WRONLY       쓰기 전용                 O_RDWR       읽고 쓰기                 O_WRONLY O_RDWR을 사용할 경우 | 을 통해 더 flags를 지정할 수 있다.       -                 O_CREAT       파일이 존재하지 않으면 새롭게 만든다.                 O_EXCL       O_CREAT와 함께 사용되어 이미 파일이 존재하면 에러 발생시킴 복수의 프로세스가 동시에 같은 경로의 파일을 만들지 않게한다. 먼저 만든 하나의 프로세스만 파일을 만들 수 있으며, 다른 프로세스는 모두 open()에 실패하게 된다.                 O_TRUNC       O_CREAT과 함께 사용되어 이미 파일이 존재하면, 파일의 크기를 0으로 만든다.                 O_APPEND       write() 함수가 항상 파일의 끝에 쓰도록 설정한다.           저수준 파일 입출력 예제             fd_test.log에 이미 100Byte의 데이터가 있다면, 앞부분 53Byte만 덮어 쓰이고 뒤의 47Byte는 그대로 남는다.       원래 파일의 내용을 모두 지우고 빈 파일로 열고자 한다            O_TRUNC 플래그를 더해서 호출하거나 truncate, ftruncate를 사용한다.         fd = open(FILENAME, O_CREAT | O_TRUNC | O_WRONLY, 0644);                           원래 파일 이미 존재하는 경우에 기존 파일을 백업 받고 새로운 파일을 열고자 한다. log 파일들..            O_EXCL(exclusive open) 플래그 더해서 호출         fd = open(FILENAME, O_CREAT | O_WRONLY | O_EXCL, 0644);                       O_EXCL 플래그가 지정 시, 이미 존재하면 open은 실패(-1 리턴)하고 errno는 EEXIST로 셋           동기화된 I/O로 열기      저수준 파일 처리에서는 동기화된 I/O(synchronized I/O)를 설정할 수 있다.   현대 OS는 상대적으로 느린 디바이스들(디스크, 네트워크)에 대해서는 좀 더 빠른 디바이스(메모리)에 캐시하고 나중에 좀 더 한가할 때 실제적인 기록을 하여 동기화를 하게 된다.    동기화된 I/O를 사용하면 운영체제는 캐시된 데이터와 느린 디바이스를 최대한 동일하게 유지하려고 노력            단점은 응답성 저하, 시스템 성능 저하             동기화 방법            수동                    동기화 필요 시점에서 fsync(), fdatasync()함수 호출                       입출력 발생 시, 자동                    open() 시, O_SYNC, O_DSYNC 플래그 설정                                          flag       description                 O_SYNC       파일 내용과 메타 데이터 모두를 동기화 쓰기만 동기화 함. 읽기는 캐시를 사용하여 좀 더 빠른 응답                 O_DSYNC       메타 데이터 제외하고 순수 파일만 동기화(가볍다) 쓰기만 동기화 함. 읽기는 캐시를 사용하여 좀 더 빠른 응답                 O_RSYNC       읽을 때, 밀린 쓰기 작업 모두 완료 후 동기화 I/O사용 지연된 쓰기 작업들이 완료된 뒤에야 읽기 작업 수행 -&gt; 캐시 X -&gt; 느림              동기화 I/O 사용     fd = open(path, O_CREAT | O_WRONLY | O_SYNC, 0644);           메타 데이터를 제외한 동기화     fd = open(path, O_CREAT | O_WRONLY | O_DSYNC, 0644);           동기화 I/O 사용 + 읽기 작업 동기화 추가     fd = open(path, O_CREAT | O_WRONLY | O_SYNC | O_RSYNC, 0644);           메타 데이터를 제외한 동기화 + 읽기 작업 동기화 추가     fd = open(path, O_CREAT | O_WRONLY | O_DSYNC | O_RSYNC, 0644);           close-on-exec      open() 시, O_CLOEXEC를 지정하면 close-on-exec가 설정된다.            close-on-exec: exec 계열의 함수 때문에 다른 프로세스 이미지로 교체되면서 자동으로 fd를 닫음       fcntl을 이용한 close-on-exec 참고       fcntl을 사용하는 것 보다 open()때 해당 fd는 O_CLOEXEC해두는게 편하다.       참고! open의 O_CLOEXEC 플래그는 2008년도 SUSv4 issue7 표준에 포함되었다. 따라서 SUSv3 이하 표준 시스템에서는 fcntl의 FD_CLOEXEC로 해야한다.           close   사용이 끝난 스트림은 close()로 닫는다.   #include &lt;unistd.h&gt;  int close(inf fd);  if (close(fd)&lt;0){ \t/* 에러 처리 */ }   기능: file descriptor 끝                  return       value                 성공       0                 실패       -1                          parameter       description                 fd       종료할 파일 디스크립터              특정 파일을 계속 입출력하는 것이 아니라면, 사용 후 닫자.   open, close에 숨겨진 과정      파일을 열고(open) 닫는(close)는 파일에 관련된 정보를 읽고, 버퍼를 할당하는 과정이 숨겨져 있다.   산발적으로 한두 번 쓰는 파일이라면 쓰고 난 뒤 닫아주는 것이 좋다.            특별한 경우 제외하고, 모든 프로세스에는 최대 열 수 있는 파일의 개수 제한 존재하기 때문에 파일을 닫지 않으면 나중에 더는 파일을 열 수 없는 상황이 발생할 수 도 있다.           최대 파일 오픈 수(max open files)는 ulimit -n 명령어로 확인한다.     posix_fadvise(): 파일 사용 패턴 조언     POSIX에서는 2001년에 파일 사용 패턴 조언추가하였다.            열린 fd를 앞으로 순차적으로 읽을 것? 랜덤하게 접근할 것? 한번만 쓰고 다시는 쓰지 않을 것?인지를 알려주는 기능           int posix_fadvise(int fd, off_t offset, off_t len, int advice);     순차적 접근: 시스템은 현재 읽은 데이터의 다음 데이터를 prefetch해 미리 가져온다. 최대한 latency 줄인다. 대용량 파일을 읽어들일 때 성능이 좋아진다.   한번만 사용: 시스템은 해당 파일을 읽을 때 사용한 메모리를 퇴출하도록 캐시 정책에 반영, 메모리를 좀 더 효율적 사용 가능   추후 보충   ftruncate(): 파일을 지정한 크기로 변경   #include &lt;unistd.h&gt;  int ftruncate(int fd, off_t length);     기능: 파일을 지정한 크기로 변경한다.                  return       value                 성공       0                 실패       -1                          parameter       description                 fd       파일 디스크립터                 length       제한할 크기           #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt;   int main(void){ \tint fd; \tchar buf[100] = \"hello world!\"; \tfd=open(\"./test.txt\", O_WRONLY, 0644);  \twrite(fd, buf, strlen(buf));  \tftruncate(fd, strlen(buf));\t// 파일 디스크립터에 있는 파일을 문자열 외엔 없애기   \tclose(fd);  \treturn 0; }     파일을 만들고 파일 크기만큼으로 자른다.        strlen(buf)만큼 크기로 만들어짐        Hex code  ","categories": ["file"],
        "tags": [],
        "url": "https://markyang920413.github.io//file/system_programming-file-lowlevel_IO_1/",
        "teaser": null
      },{
        "title": "lowlevel I/O <2> fd를 통한 파일제어, lseek(), dup(), dup2(), ioctl(), fcntl()",
        "excerpt":"lseek():2     스트림은 파일의 특정 위치에 연결되어 있다. 스트림이 연결되어 있는 위치를 파일 오프셋이라 한다.   #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;  Off_t lseek(int fd, off_t offset, int whence);  기능: fd 내부의 파일 오프셋을 지정한 위치로 이동                  return       value                 성공       파일의 시작으로 부터 오프셋 위치                 실패       -1                          parameter       Description                 fd       파일 디스크립터                 offset       오프셋                 whence       모드                          whence       이동 위치                 SEEK_SET       파일의 처음을 기준으로 오프셋 계산 및 이동                 SEEK_CUR       파일의 현재 위치을 기준으로 오프셋 계산 및 이동                 SEEK_END       파일의 마지막을 기준으로 오프셋 계산 및 이동              dup():2, dup2():2   #include &lt;unistd.h&gt;  int dup(int oldfd); int dup2(int oldfd, int newfd);  기능: 인자로 지정한 파일 디스크립터 복제   활용은 pipe dup사용하기 참고   ioctl():2   #include &lt;sys/ioctl.h&gt;  int ioctl(int fd, unsigned long request, ...);  기능: 스트림이 연결된 디바이스에 특화된 작업을 모두 포함하는 시스템 콜     DVD 드라이브 여닫기, 음악 CD 재생   프린터 구동이나 일시 정지   SCSI 디바이스 하드웨어 옵션 셜정   단말 통신 속도 설정 등   유닉스의 open(), read(), write(), close() 인터페이스 이외 기능들이 모두 ioctl()에 있다.                  parameter       Description                       fd       처리할 파일 디스크립터                 request       어떤 작업을 할 것인가?                 …       _request_파라미터에 따라 추가 지정해야 하는 인자 man ioctl_list에서 확인 할 수 있다.           fcntl():2 파일 제어     UNIX는 모든 것이 file로 되어 있다. 그래서.. file을 잘 다루어야한다!            일반 파일, socket, IPC, device등 모든 것이 파일이고 이를 특성 제어하는 것이 fcntl()이다.       대표적 Non-Blocking 셋팅!           #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt;  int fcntl(int fd, int cmd); int fcntl(int fd, int cmd, long arg); int fcntl(int fd, int cmd, struct flock *lock);     기능: 지정한 fd에 cmd로 특성 제어 한다.                  parameter       Description       arg       비고                 fd       제어할 파일 디스크립터       　                         cmd       F_DUPFD 지정한 fd를 복사하기 위해 사용       복사결과의 fd번호       copied fd &gt;= arg이며, 이미 사용중이면 가능하면서 가장 적은후로 Copy                 　       F_GETFD 리턴 값으로 FD에 대한 flag 값을 넘겨준다.       0       현재는 FD_CLOEXEC(close-on-exec) 정보만 넘겨준다                 　       F_SETFD arg로 준 비트값 설정을 fd에 set       설정 bit       FD_CLOEXEC(close-on-exec)설정 가능                 　       F_GETFL fd에 대한 open() 호출 했을 때, flags 읽어옴       0       -                 　       F_SETFL arg에 지정된 값으로 fd 특성 셋팅       설정 가능: O_APPEND, O_NONBLOCK, O_ASYNC 읽기 가능: O_RDONLY, O_WRONLY, O_RDWR       (O_ASYNC는 비동기 입출력모델을 구현하기 위해 사용) 읽기 권한 정보를 읽어오는 것은 O_ACCMODE와 bit연산을 함으로써 얻을 수 있다. 그 밖 정보는 각각의 플래그등과 비트연산한다. ex) fcntl(fd, F_SETFL, O_RDWR | O_NONBLOCK | O_ASYNC)                 　       F_GETOWN 비동기 입출력과 관련되어 사용 됨       -       SIGIO, SIGURG 신호를 받는 PID를 얻기위해 사용                 　       F_SETOWN 비동기 입출력과 관련되어 사용       getpid()       SIGIO, SIGURG 신호를 받는 PID(혹은 그룹)을 설정하기 위해 사용 ex) fcntl(fd, F_SETOWN, getpid())                 　       F_SETAUXFL       O_ONESIGFD: 하나의 소켓당 하나의 이벤트가 대기열에 들어가도록 설정. RTS Overflow를 일어나지 않게한다.       RTS Overflow참고                 　       F_SETSIG       시그널 번호       fd에 대해 시그널 셋 ex) fclntl(fd, F_SETSIG, SIGRTMIN): fd에 대해 RTS대응하도록 만든다.                 　       Other flags       Refer to man page                                  return       value                       성공       0                 실패       -1           close-on-exec에 대하여      보통 프로세스에서 exec()하면, 새로운 프로세스는 기존의 이미지를 덮어쓴다.   특별한 설정이 없으면 fd를 그대로 넘겨준다.   #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt;  int main(){ \tint fd; \tint val; \tfd=open(\"exec_copy.txt\",O_CREAT);  \texecl(\"/home/my_cvs/test/c_source/loop\", \"./loop\", 0); \treturn 0; }      그냥 무한 loop 시키는 프로그램이다.   실행 후, ps를 확인하고 /proc/pid/fd로 이동해서 ls를 보면     $ ls -al 합계 0 dr-x------    2 root     root            0 10월 25 13:59 . dr-xr-xr-x    3 root     root            0 10월 25 13:59 .. lrwx------    1 root     root           64 10월 25 13:59 0 -&gt; /dev/ttyp0 lrwx------    1 root     root           64 10월 25 13:59 1 -&gt; /dev/ttyp0 lrwx------    1 root     root           64 10월 25 13:59 2 -&gt; /dev/ttyp0 lr-x------    1 root     root           64 10월 25 13:59 3 -&gt; /home/mycvs/test/exec_copy.txt           exec하면서 fd가 상속되었음을 알 수 있다.   때때로 exec하면서 기존 fd를 정리하고 실행하고 싶을 때도 있다.            이러한 경우를 Close-on-exec이라고 한다.       fcntl()을 사용하면, fd에 대해 close-on-exec를 작동케할 수 있다.       이미 open()에서 close-on-exec를 애초에 설정하고 fd를 여는 방법도 있다. 참고           F_DUPFD      f_dupfd.c   #include &lt;fcntl.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;stdio.h&gt;  int main(){ \tint testfd; \tint fd; \tfd=open(\"test.txt\", O_CREAT);  \ttestfd=fcntl(fd,F_DUPFD, 10); \tprintf(\"testfd: %d\\n\", testfd); \ttestfd=fcntl(fd,F_DUPFD, 10); \tprintf(\"testfd: %d\\n\", testfd);  \treturn 0; }        이미 사용중인 fd라면 arg보다는 크지만 허용가능한 fd 수 중에서 가장 작은 수로 부여   F_SETFD/F_GETFD      close-on-exec 값을 조절하기 위해 사용된다.   F_GETFD를 이용해서, FD_CLOEXEC 값을 가져옴   F_SETFD를 이용해 이 값을 변경한다.   기본적으로는 exec할 때 close되지 않는다. 그럼 f_dupfd.c를 close-on-exec 하도록 약간 변경해보자.   #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt;  int main(){ \tint fd; \tint val; \tfd=open(\"exec_copy.txt\",O_CREAT,0600);  \t// FD_CLOEXEC 값을 fcntl을 이용해서 가져온 다음 세팅되어 있는지 검사한다  \tval=fcntl(fd,F_GETFD,0); \tif(val&amp;FD_CLOEXEC) \t\tprintf(\"close-on-exec on\\n\"); \telse \t\tprintf(\"close-on-exec off\\n\"); \t \t// FD_CLOEXEC set \tval |= FD_CLOEXEC; \tif(val&amp;FD_CLOEXEC) \t\tprintf(\"close-on-exec on\\n\"); \telse \t\tprintf(\"close-on-exec off\\n\"); \tfcntl(fd,F_SETFD,val); // set val  \texecl(\"/home/my_cvs/test/c_source/loop\", \"./loop\", 0);  \treturn 0; // It shouldn't be executed. \t }   F_GETFL/F_SETFL      F_GETFL은 open()시 fd의 flags값을 가져온다.   F_SETFL은 fd값 특성을 셋팅한다.            F_SETFL을 이용해 변경할 수 있는 특성은 O_APPEND, O_NONBLOCK, O_OASYNC다. O_\\RDONLY, O_WRONLY, O_RDWR은 읽기만 가능하다.       읽기 권한 정보를 읽어오는 것은 O_ACCMODE와 비트 연산       다른 정보는 각각의 플래그와 비트연산으로 얻는다.           fgetfl_test.c   #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;  int main(){ \tint mode, fd, value;  \tfd=open(\"test.sh\", O_RDONLY|O_CREAT, 0644); \tif(fd&lt;0){ \t\tperror(\"open error\\n\"); \t\texit(-1); \t}  \tvalue=fcntl(fd,F_GETFL,0); // fd의 open시 flags 얻음   \tmode=value &amp; O_ACCMODE; \tif (mode==O_RDONLY) \t\tprintf(\"O_RDONLY on\\n\"); \telse if(mode == O_WRONLY) \t\tprintf(\"O_WRONLY on\\n\"); \telse if(mode == O_RDWR) \t\tprintf(\"O_RDWR on\\n\"); \t \tif(value &amp; O_NONBLOCK) \t\tprintf(\"O_NONBLOCK on\\n\"); \telse \t\tprintf(\"BLOCKING mode on\\n\"); \tif(value &amp; O_ASYNC) \t\tprintf(\"O_ASYNC on\\n\");  \treturn 0; }      NON_BLOCKING ON      fsetfl_test.c   #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;string.h&gt;  #define STDIN 0 int main(){ \tint mode, fd, value; \tchar buf[255]; \tmemset(buf, 0x0, sizeof(buf));  \t// 처음 입력은 BLOCKING MODE \tread(STDIN, buf, 255); \tprintf(\"-&gt; %s\\n\", buf); \tmemset(buf, 0x0, sizeof(buf));  \t// NON_BLOCKING 모드로 변경 \tvalue=fcntl(STDIN, F_GETFL, 0); \tvalue |= O_NONBLOCK; \tfcntl(STDIN, F_SETFL, value); \tprintf(\"Non blocking mode on\\n\");  \t// wait 2 sec \tsleep(2);  \t// busy wait start \twhile(1){ \t\tread(STDIN,buf,sizeof(buf)); \t\tprintf(\"-&gt; %s\\n\", buf); \t\tfflush(stdout); \t\tbreak; \t}  \treturn 0; }        blocking모드 일 땐, 입력을 기다리지만 NON_BLOCKING 모드일 땐 2초 뒤 그냥 끝낸다.   F_GETOWN/F_SETOWN      F_GETFL/F_SETFL은 fd의 특성을 변경한다. 그 중 O_ASYNC는 비동기 입출력과 관련된 것이다.            F_GETOWN/F_SETOWN 은 이 비동기 입출력과 관련된 flags이다.       이들 flag를 사용함으로써 비동기 입출력 모드로 fd가 설정되어 있을 때, 어떤 프로세스(그룹) 아이디로 부터 오는 시그널을 받을지를 지정해 줄 수 있다.       추후 명세           fcntl을 통한 잠금방법     fcntl을 통해 파일 잠금, 레코드 잠금 가능     잠금            멀티 스레드프로그램에서, 여러 스레드가 하나의 파일에 동시에 접근하는 경우, 파일 잠금이 필요할 수 있다. 한번에 하나의 스레드만이 읽기 및 쓰기를 해야하는 경우가 있기 때문이다.       DB의 경우 파일잠금 + 레코드잠금이 필요하다. 특정 레코드에는 하나의 스레드만 접근 제어해야한다.                    레코드 잠금은 해당 프로세스가 액세스하는 부분만 잠금!                       UNIX에서는 fcntl()을 통해 잠금 구현           #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt;  int fcntl(int fd, int cmd, struct flock* lock);     struct flock* lock이 레코드 잠금을 위해 사용된다(잠금에 필요한 정보를 포함).                  parameter       description                 int fd       설정할 파일 디스크립터                 int cmd       명령 F_SETLK: flock 구조체에 설정된 잠금을 얻기/잠금을 풀기위해 사용 　- 프로세스는 특정 영역의 잠금을 검사해서 잠금을 사용할 수 있으면 잠금을 얻음. 작업이 끝나면 잠금을 품 　- 잠금을 얻을 수 없으면, -1을 반환하고 errno EACCESS, EAGAIN을 설정 　- 잠금을 검사하는 용도로 사용할 수 있다. F_SETLKW: F_SETLK와 같은 일을 하지만, 에러를 리턴하는 대신 잠금이 풀릴때까지 해당영역에서 기다린다(block). 　- F_SETLK의 봉쇄형이다. F_GETLK: 잠금이 있는지 없는지 검사 　- 만약 잠금이 없다면 l_type을 F_UNLCK로 설정 　- 만약 잠금이 있다면, 현재의 flock 정보를 flock 구조체로 돌려준다.           struct flock{ \tshort int l_type;\t/* 잠김 타입: F_RDLCK, F_WRLCK, F_UNLCK */ \tshort int l_whence;\t/* 파일의 절대 위치 */ \t__off_t l_start;\t/* 파일의 offset */ \t__off_t l_len;\t\t/* 잠그고자 하는 파일의 길이 */ \t__pid_t l_pid;\t\t/* 잠금을 얻은 프로세스의 pid */ };                  struct flock의 멤버       description                 short int l_type       F_RDLCK: 읽기 전용 F_WRLCK: 쓰기 전용 F_UNLCK: 잠금 되지 않음                 short int l_whence       파일에서 절대적 위치                 __off_t l_start       l_whence로 부터 이동한 거리(offset)                 __off_t l_len       잠그고자 하는 파일 길이              l_whence: SEEK_SET, l_start: 16, l_len: 16 　　=&gt; 레코드 위치: 처음 + 16 (16th) ~ 32 사이 데이터 블럭 잠금            whence 매크로참고           파일 잠그기 예제 by fcntl      code   #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;  int fd_unlock(int fd); int fd_open(int fd); int fd_lock(int fd);  int main(){ \tint fd; \tint n_read; \tchar buf[11]=\"1\"; \tchar wbuf[11];  \tfd=open(\"counter.txt\", O_CREAT | O_RDWR, 0644); \tif(fd==-1){ \t\tperror(\"file open error : \"); \t\texit(0); \t} \tif(fd_lock(fd)==-1){ // lock \t\tperror(\"file is lock \"); \t\texit(0); \t} \tprintf(\"I get file lock\\n\");  \twrite(fd,buf,strlen(buf)+1); \tmemset(wbuf, 0x0, 11); \tif((n_read=read(fd,buf,11))&gt;0){ \t\tprintf(\"%s\\n\",buf); \t} \t// 처음 위치로 되돌림 \tlseek(fd, 0, SEEK_SET); \tsprintf(wbuf,\"%d\",atoi(buf)+1); \twrite(fd, wbuf, 11);  \t// 숫자외의 필요없는 부분을 자른다. \tftruncate(fd, strlen(wbuf));  \tsleep(10);  \t// 파일잠김을 푼다. \tif(fd_unlock(fd) == -1){ \t\tperror(\"file unlock error \"); \t} \tprintf(\"file unlock success\\n\"); \tsleep(5);  \tclose(fd); }  /* 파일이 잠겨있는지 확인하고 잠겨있지 않다면,   * 잠금을 얻고  * 잠겨있으면, 잠김이 풀릴때까지 기다린다(F_STREAM)  */  int fd_lock(int fd){ \tstruct flock lock;  \tlock.l_type=F_WRLCK; \tlock.l_start=0; \tlock.l_whence=SEEK_SET; \tlock.l_len=0;  \treturn fcntl(fd, F_SETLKW, &amp;lock); }  /* 파일잠금을 얻은 후 모든 작업이 끝난다면 파일 잠금을 돌려줌 */ int fd_unlock(int fd){ \tstruct flock lock;  \tlock.l_type=F_UNLCK; \tlock.l_start=0; \tlock.l_whence=SEEK_SET; \tlock.l_len=0;  \treturn fcntl(fd, F_SETLK, &amp;lock); }  $ ./file_lock_using_fcntl I get file lock\t\t# 이 단계에서, 프로그램은 counter.txt를 만들어 1을 write한다. file unlock sucess $ cat counter.txt 2\t\t\t# 원래 1이 있던 텍스트에서 +1하여 2를 write 된 파일     하나의 fd에 접근제어해서 사용하는 예   레코드 잠그기           기본적으로 파일을 잠그는 방법과 동일하다. 단지 특정 범위에 대해서만 잠금을 허용하는게 다르다.            테스트용 샘플 프로그램은 다중 프로세스 카운터로 하나의 파일에 여러 개의 프로세스가 자신에게 할당된 레코드에 카운팅한다.             잠금, 풀기할 때 레코드의 영역 하나의 카운터 블럭은 16Byte로 고정 되며, 카운터 숫자 이외의 영역은 NULL로 채워 짐                 프로세스가 1번째 counter 데이터에 접근할 때 굳이 1번부터 16번까지 전부다 잠글 필요는 없으므로 1번만 잠근다.            이때 프로세스가 1번째 counter데이터에 접근 중일때, 다른 프로세스는 접근하지 못하게한다.           #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdlib.h&gt;  #define BLOCK_SIZE 16 int main(void){ \tint fd; \tint i; \tchar buf[BLOCK_SIZE]; \tif ((fd=open(\"b_counter\",O_CREAT | O_WRONLY)) == -1){ \t\tperror(\"file open error: \"); \t\texit(0); \t} \tfor(i=1; i&lt;4; i++){ \t\tmemset(buf, 0x0, BLOCK_SIZE); \t\tsprintf(buf,\"%d\",i); \t\twrite(fd, buf, BLOCK_SIZE); \t} \tclose(fd); }     위 코드는 b_counter라는 파일 만든다.   od -c 명령어를 사용해 counter정보가 제대로 만들어 졌는지 확인한다.            데이터 블럭단위만 잠근다.   ","categories": ["file"],
        "tags": [],
        "url": "https://markyang920413.github.io//file/system_programming-file-lowlevel_IO_2/",
        "teaser": null
      },{
        "title": "프로세스 API <1> fork(), wait(), exec(), posix_spawn()",
        "excerpt":"프로세스  process      프로세스 상태            running       waiting       stopped       zombie              프로세스의 Identification            name: 프로세스의 이름       PID: PID       PPID: 부모의 PID       PGID: 프로세스 그룹 ID                    프로세스는 여러 자식만들 수 있다. 이 자식들을 하나의 그룹으로 관리(Group)           즉, PGID는 프로세스가 어느 그룹에 포함되어 있는지에 대한 정보를 알려준다.           보통 \"PPID == PGID\"                            부모: PID == PGID               자식: PPID == PGID                                                     $ ps -efjc | grep forktest  UID        PID  PPID  PGID   SID CLS PRI STIME TTY          TIME CMD yundream 12198  8557 12198  8557 TS   24 17:40 pts/0    00:00:00 ./forktest yundream 12199 12198 12198  8557 TS   21 17:40 pts/0    00:00:00 ./forktest     위에서 부모(PID 12198)의 부모는(PID 8557)는 어떤 프로세스일까?   $ ps -efjc | grep 8557 UID        PID  PPID  PGID   SID CLS PRI STIME TTY          TIME CMD yundream  8557  8550  8557  8557 TS   24 13:37 pts/0    00:00:00 bash     bash다!     PGID가 왜 중요할까?            공통의 자원을 공유하는 관계는 서로 중요하다.       이 Group 사이에는 signal()을 이용해 소통한다.           고아 프로세스?            부모가 자식을 낳고, 자식의 자원을 리턴 받기 전에 종료되면, 자식 프로세스는 고아 프로세스가 된다.       linux에서는 고아가된 프로세스는 init프로세스가 관리해서 버려지지 않도록 설계되어 있다.           #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt;  int main() {     int pid;     int i;      i = 1000;     pid = fork();     if (pid == -1)     {         perror(\"fork error \");         exit(0);     }     // 자식프로세스가 실행시키는 코드     else if (pid == 0)     {         printf(\"자식 : 내 PID는 %d\\n\", getpid());         while(1)         {             printf(\"--&gt;%d\\n\", i);             i++;             sleep(1);         }     }     // 부모프로세스가 실행시키는 코드     else     {         printf(\"부모 : 내가 낳은 자식의 PID는 %d\\n\", pid);         sleep(1);         printf(\"T.T 나죽네\\n\");         exit(0);     } }     실행   $ ./forktest 부모 : 내가 낳은 자식의 PID는 8207 자식 : 내 PID는 8207 --&gt;1000 T.T 나죽네 --&gt;1001 mark@mark-desktop$ --&gt;1002 --&gt;1003 . . .     자식이 자원을 해제하지 못하고 계속 실행   bash에서 Ctrl + C를 눌러도 자식프로세스는 kill 되지 않는다.            bash &lt;–&gt; 자식프로세스가 같은 PGID XX!!           전통적인 프로세스 fork(fork-exec)       전통적인 fork: 멀티 프로세스            fork된 자식 프로세스는 부모 프로세스와 독립적으로 작동, 복수 개의 CPU가 설치된 경우 뛰어난 응답성과 성능       서로 독립적 및 프로세스 간 통신 비용 단점       공통으로 사용하는 파일, I/O는 mmap을 이용하여 비용을 최소화           fork의 예            shell                    ls 명령 -&gt; fork 자식 프로세스 생성 -&gt; 자식 프로세스가 exec(\"/bin/ls\")로 프로그램 이미지 교체                            popen 링크: 부모 프로세스와 자식 프로세스 간에 주고 받을 데이터가 있을 때 파이프를 이용해 통신               system: 어떤 피드백도 없이 간단히 프로그램 실행할 때 사용                                               연달아서 fork-exec호출을 하는 방식이 inetd형식 프로그램(리눅스 에서는 xinetd) 대몬이 inetd형식을 처리           vfork      vfork: fork시, 페이지 테이블을 복제하지 않음            fork-exec를 좀 더 가볍게 하려고 지원했던 기능       fork-exec는 exec 가 호출되는 순간 fork로 복제되었던 페이지 테이블은 모두 해제되는 단점                    fork() -&gt; 페이지 테이블 복제           exec() -&gt; 프로그램 이미지 실행 및 위 페이지 테이블 해제                       즉, fork_exec는 쓰지도 않는 자원 복제 때문에 오버헤드가 존재했다.           Copy on Write 방식의 fork()      fork 시, 페이지 테이블 즉시 복사 XX   부모와 자식 프로세스의 페이지 테이블이 달라지는 시점에 복제            부모나 자식 중에 메모리에 write하는 시점에 복제           부모 &lt;-&gt; 자식 공유, 부모만의 메모리, 자식만의 메모리        PTE는 커널 메모리 영역에 있음       과정            부모 자식도 전체 페이지에 write 권한 무효화한다.                  부모 혹은 자식이 write 시도 시, 다음과 같이 공유 해제            CPU에 페이지 폴트 발생       CPU가 커널 모드로 변경되어 커널의 페이지 폴트 핸들러 동작       페이지 폴트 핸들러는 접근한 페이지를 다른 장소에 복사하고, write하려고 한 프로세스에 할당한 후 내용을 다시 작성       부모 프로세스, 자식 프로세스 각각 공유가 해제된 페이지에 대응하는 PTE 업데이트                    write한 프로세스 쪽에 엔트리는 새롭게 할당된 물리 페이지를 매핑해 write 허가           다른 쪽 프로세스의 엔트리에도 write허가                       이후 공유가 해제된 페이지에는 각각 자유롭게 R/W 가능              하지만, 페이지 테이블을 제외한 모든 정적 자원 그대로 복제되는 오버헤드            fork 후 즉각 exec를 호출하지 않을 때는 페이지가 복제되는 오버헤드           Copy On Write 실험      100MB 메모리를 확보하여 모든 페이지에 접근   시스템의 메모리 사용량 확인   fork() 시스템 콜 호출   부모 프로세스와 자식 프로세스가 각각 다음과 같은 동작을 한다.            부모 프로세스                    자식 프로세스의 종료 기다림                       자식 프로세스                    시스템 메모리의 사용량과 자기 자신의 가상 메모리 사용량, 물리 메모리의 사용량, Major Fault의 횟수, Minor Fault 횟수 표시           위에서 획득한 영역 전부의 페이지에 접근           위 결과 횟수 표시                           copy_on_write.c    #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/mman.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;err.h&gt;  #define BUFFER_SIZE (100*1024*1024) #define PAGE_SIZE 4096 #define COMMAND_SIZE 4096  static char *p; static char command[COMMAND_SIZE];  static void child_fn(char *p){ \tprintf(\"*** child ps info before memory access ***:\\n\"); \tfflush(stdout); \tsnprintf(command,COMMAND_SIZE,\"ps -o pid,comm,vsz,rss,min_flt,maj_flt | grep %d\",getpid()); \t// shell cmd에 명령을 내리는 문자열 \t// vsz: 가상 메모리양 \t// rss: 확보된 물리 메모리양 \tsystem(command);  \tprintf(\"*** free memory info before memory access ***:\\n\"); \tfflush(stdout); \tsystem(\"free\");  \tint i; \tfor(i=0;i&lt;BUFFER_SIZE;i+=PAGE_SIZE) \t\tp[i]=0;  \tprintf(\"*** child ps info after memory access ***:\\n\"); \tfflush(stdout); \tsystem(command);  \tprintf(\"*** free memory info after memory access ***:\\n\"); \tfflush(stdout); \tsystem(\"free\");  \texit(EXIT_SUCCESS); }  static void parent_fn(void){ \twait(NULL);  \texit(EXIT_SUCCESS); }  int main(void){ \tchar* buf; \tp=malloc(BUFFER_SIZE); \tif(p==NULL) \t\terr(EXIT_FAILURE,\"malloc() failed\");  \tint i; \tfor(i=0;i&lt;BUFFER_SIZE;i+=PAGE_SIZE) \t\tp[i]=0;  \tprintf(\"*** free memory info before fork ***:\\n\"); \tfflush(stdout); \tsystem(\"free\");  \tpid_t ret; \tret=fork(); \tif(ret==-1) \t\terr(EXIT_FAILURE,\"fork() failed\");  \tif(ret==0) \t\tchild_fn(p); \telse \t\tparent_fn();  \terr(EXIT_FAILURE,\"shouldn't reach here\"); }      #include &lt;unistd.h&gt;  pid_t fork(void);     기능: fork()는 프로세스 자신을 복제해서 새로운 프로세스를 만드는 시스템 콜            parent process: 원래 존재하는 프로세스       child process: parent process에서 복제되어 만들어진 프로세스                          return       value                       성공       Parent process get 0                 실패       Parent process get -1           exec():2 프로세스 실행     exec는 새로운 프로세스 호출 덮어씌워짐            exec를호출하면, 그 시점에서 실행 중인 프로그램 소멸 후 새로운 프로그램 로드       exec로 프로그램 이미지가 대체 되어도 기본적인 PID, PPID, fd등 프로세스의 정보는 유지           #include &lt;unistd.h&gt;  int execl(const char *path, const char *arg, ... /* NULL */);                  parameter       description                       *path       실행되는 프로그램의 완전한 경로                 *arg       프로그램이 실행될 때, 넘겨질 아규먼트. 여러 개가 정의 될 수 있다. 더 이상 넘겨질 인자가 없으면 마지막엔 NULL              ls -al를 실행하는 간단한 예제   #include &lt;unistd.h&gt;  int main(int argc, char *argv[]){ \texecl(\"/bin/ls\", \"ls\", \"-al\", NULL); }             UNIX: execve()만 시스템 콜, 나머지는 라이브러리 함수   API 이름 뒷 부분에 l(list)가 붙은 경우는 argument를 가변 인자로 전달, 마지막 NULL   API 이름 뒷 부분에 v(vector)가 붙은 경우는 argument를 문자열 배열로 전달, 마지막 NULL            1, 2번 째 인자에는 프로그램 이름 중복           execl(\"/bin/cat\", \"cat\", \"hello.c\", NULL);  char *argv[3]={ \"cat\", \"hello.c\", NULL); execv(\"bin/cat\", argv);      API 이름 뒷 부분에 e가 붙은 경우, 환경변수인 envp가 추가된다. e가 붙지 않은 경우, 현재 프로세스 환경 변수 그대로 사용   API 이름 뒷 부분에 p가 붙은 경우, $PATH에서 프로그램을 찾는다. p가 붙지 않은 경우, 프로세스를 절대 경로 또는 상대 경로로 지정해야 한다.        exec는 성공하면 호출이 돌아오지 않기 때문에 호출이 돌아온 경우는 언제나 실패했음을 의미한다. 실패했을 때는 -1을 반환하고 errno에 에러 번호가 설정한다.       exec는 부모 프로세스의 fd를 복제한다.            fd에 fcntl 로 FD_CLOEXEC 플래그를 지정하고 fork, 후 exec를 하면 해당 fd는 닫히고 실행된다       close-on-exec참고           system():3     system 함수는 셸을 실행시켜서 명령어 실행 기능 fork-exec를 간단하게 구현한 형태            system(“ls -al”)           system 명령은 부모 프로세스가 잠시 정지된다.            자식 프로세스의 정지, 종료 상태를 통보해주는 시그널인 SIGCHLD 도 블록       종료 시그널인 SIGINT, SIGQUIT 시그널도 무시           system함수는 시그널이 블록되어 부모 프로세스가 무한 대기에 빠지는 경우 발생            fork-exec로 구현하자.           fork():2   #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;  pid_t fork(void);     기능: fork()는 호출한 프로세스를 복제하여 만들어진 프로세스            분기 이후, child와 parent는 별도의 메모리 공간에서 실행한다.       fork()시, 같은 내용이 두 프로세스에 복제된다       Memory Write, file mappings(mmap()), unmapping는 서로 영향을 끼치지 않는다.                          return       value                 성공       Parent:　child의 real pid Child:　0                 실패       -1, errno set           예제 1. 간단한 fork()    #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt;  int main(){ \tint pid; \tint i;  \ti=1000; \tpid=fork(); \tif(pid==-1){ \t\tperror(\"fork error\\n\"); \t\texit(-1); \t} \telse if(pid==0){ \t\t/* child process */ \t\tprintf(\"자식의  real pid: %d\\n\",getpid()); \t\twhile(1){ \t\t\tprintf(\"--&gt;%d\\n\",i); \t\t\ti++; \t\t\tsleep(1); \t\t} \t} \telse { \t\t/* parent process */ \t\t// 부모는  pid값으로 자식의 real pid값 가진다. \t\tprintf(\"부모, 내 자식의 real pid: %d\\n\", pid); \t\twhile(1){ \t\t\tprintf(\"==&gt;%d\\n\", i); \t\t\ti += 4; \t\t\tsleep(1); \t\t} \t} \treturn 0; }   $ ps -ef | grep test UID        PID  PPID  C STIME TTY          TIME CMD yundream 12119  8557  0 17:33 pts/0    00:00:00 ./forktest\t\"parent\" yundream 12120 12119  0 17:33 pts/0    00:00:00 ./forktest\t\"child\"  ex)     부모의 real PID: 1000　　　　 \t\t return pid=fork(): 1001(자식의 real PID)   자식의 real PID: 1001(부모+1) 　\t\treturn pid=fork(): 0   wait():2     child process를 기다리는데는 wait()나 waitpid()를 사용한다.   #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt;  pid_t wait(int *status); pid_t waitpid(pid_t pid, int *status, int options);  wait(&amp;status) == waitpid(-1, &amp;status, 0); // 같은 기능     wait()는 임의의 child 기다림 + 기다린 프로세스 정보 Get!!   waitpid()는pid 명시해 기다림 + 기다린 프로세스 정보 Get!!   wait는 child process가 종료될 때까지 호출한 프로세스는 중지된다.   state 변화 정보를 얻는다.            child process 종료, signal에 의한 stop, signal에 의한 resume…           wait는 child process에 관련된 자원을 release 한다. Parent의 wait가 동작하지 않으면, child process는 zomebie 프로세스가 된다.            wait()하는 권리는 부모&lt;–&gt;자식 뿐!           child process가 이미 state가 바뀌었다면, wait는 즉시 리턴된다.         wait(), waitpid() return                  상황       &amp;status에 기록되는 값       waitpid return 값                       child process 정상적 종료       WIFEXITED(status) = child process가 exit로 정상적 종료 시, 0이 아닌 값 WEXITSTATUS(status) = 하위 8bit 참조해 child process의 return 값 얻음       process ID                 child process 비정상적종료       WIFSIGNAL(status) = 시그널로 종료 시, 0이 아닌 값 WTERMSIG(status) = 시그널로 종료했으면 시그널 번호를 반환!       process ID                 waitpid 함수 오류       ECHILD: 호출 프로세스의 child process 미생성 EINTR: 시스템 콜이 인터럽트 되었음       -1                 pid_t waitpid(pid_t pid, int *status, int options);                  waitpid의 pid real pid 아님!       Description                 pid &lt; -1       프로세스 그룹 ID가 pid의 절댓값과 같은 자식 프로세스를 기다림                 -1       임의의 자식 프로세스를 기다림                 0       호출 프로세스의 프로세스 그룹 PID와 같은 프로세스 그룹 ID를 가진 프로세스 기다림                 pid &gt; 0       프로세스 ID가 pid인 자식 프로세스 기다림 기다릴 pid 명시                          options       Description                 WCONTINUED       중단되었다가 재개된 자식 프로세스의 상태 받음                 WNOHANG       기다리는 PID가 종료되지 않아, 즉시 종료 상태를회수 할 수 없는 상황에서 호출한 프로세스는 차단되지 않고 반환 값으로 0을 얻음                 WUNTRACED       중단된 자식 프로세스의 상태를 받음           예제 2. fork와 exec를 이용한 새로운 프로세스 생성    #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/wait.h&gt; #include &lt;sys/types.h&gt;  #define chop(str) str[strlen(str)-1]= 0x0;  int main(int argc, char *argv[]){ \tchar buf[256]; \tprintf(\"My Shell\\n\"); \tint pid; \twhile(1){ \t\t// 사용자 입력을 기다린다. \t\tprintf(\"# \"); \t\tchop(buf);  \t\t// 입력이 quit라면, 프로그램을 종료한다. \t\tif(strncmp(buf, \"quit\", 4)==0) \t\t\texit(0); \t\t \t\t// 입력한 명령이 실행가능한 프로그램이라면, \t\t// fork한 후 execl을 이용해서 실행한다. \t\tif(access(buf, X_OK)==0){ \t\t\tpid=fork(); \t\t\tif(pid&lt;0){ \t\t\t\tperror(\"fork error\\n\"); \t\t\t\texit(-1); \t\t\t} else if(pid==0){ \t\t\t\t// child process  \t\t\t\tif(execl(buf, buf, NULL) == -1) \t\t\t\t\tperror(\"execl in child error\\n\"); \t\t\t\t// 제대로 성공 했다면 여기엔 오지 않는다. \t\t\t\texit(-1); \t\t\t} else if(pid&gt;0){ \t\t\t\t// parent preocess \t\t\t\tint status; \t\t\t\twaitpid(pid, &amp;status, WUNTRACED); \t\t\t} \t\t} else { \t\t\t// 만약 실행 가능한 프로그램이 아니라면, 에러 메시지 출력 \t\t\tperror(\"Command Not Found\\n\\n\"); \t\t} \t} }   $ myshell # /usr/bin/w 01:15:32 up  2:58,  4 users,  load average: 0.47, 0.50, 0.62 USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT yundream :0       -                00:05   ?xdm?  14:20m  0.05s /bin/bash /usr/ yundream pts/1    :0               00:06    9.00s  1.47s  1.24s w3m -F http://w yundream pts/3    :0               00:54    0.00s  0.22s  0.00s ./myshell yundream pts/4    :0.0             00:53   22:13m  0.40s  0.27s BitchX irc.nuri  # ll Command Not Found  # quit $   simple fork 예제    #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/wait.h&gt; #include &lt;errno.h&gt; #include &lt;err.h&gt; #include &lt;signal.h&gt;  #define VERSION 1  static void child_fn(void){ \tprintf(\"Hi,I'm child [PID:%d]\\n\",getpid()); // getpid()는 진짜 real PID 보여줌 \texit(EXIT_SUCCESS); }  int main(){ \tint ret=EXIT_FAILURE; \tint i=0, ncreated=0; \tint nproc=5; // How many child process will you made?  \tpid_t *pids=(pid_t*)malloc(nproc*sizeof(pid_t)); \tif(pids==NULL){ \t\twarn(\"malloc(pids) failed\"); \t\texit(ret); \t}  \tfor(i=0, ncreated=0; i&lt;nproc;i++,ncreated++){ \t\tpids[i]=fork();\t\t// fork()하면서 child pid가 pids[i]에 담김 \t\tif(pids[i]&lt;0){ \t\t\tgoto wait_children; \t\t} else if(pids[i]==0){ // child의 pid_t 값은 0임 \t\t\t// child process \t\t\tchild_fn(); \t\t\t/* shouldn't reach here */ \t\t} \t}  \tret=EXIT_SUCCESS; \t// parent wait_children: \tif(ret==EXIT_FAILURE) \t\tfor(i=0;i&lt;ncreated;i++) \t\t\tif(kill(pids[i],SIGINT)&lt;0) \t\t\t\twarn(\"kill(%d) failed\\n\",pids[i]);  \tfor(i=0;i&lt;ncreated;i++){ \t\t/* \t\t * if(wait(NULL)&lt;0) \t\t * \twarn(\"wait() failed\"); \t\t * \t\t */ \t\tint status; \t\tpid_t ChildPid;  #if VERSION == 1 \t\tChildPid=wait(&amp;status); #elif VERSION == 2 \t\t/* 에러 발생시 명시적으로 처리하고 wait */ \t\twhile(((ChildPid=wait(&amp;status))==-1)&amp;&amp;errno==EINTR); // 인터럽트로 비정상 종료시, 무한 루프로 다시 wait 건다 \t\t{ #endif \t\tif(ChildPid&lt;0){ \t\t\tprintf(\"[ERROR] %d\\n\",errno); \t\t\tperror(\"wait func error!\"); \t\t} else { \t\t\tif(WIFEXITED(status)) \t\t\t\tprintf(\"wait: 자식 프로세스 정상 종료 %d\\n\",WEXITSTATUS(status)); \t\t\telse if(WIFSIGNALED(status)) \t\t\t\tprintf(\"wait: 자식 프로세스 비정상 종료 %d\\n\",WTERMSIG(status)); \t\t} #if VERSION == 2 \t\t} #endif \t} \tfree_pids: \t\tprintf(\"Original Process [PID:%d]!\\n\",getpid()); \t\tprintf(\"pids free is done!\\n\"); \t\tfree(pids); \texit(ret); }       getpid()으로 real pid 구할 수 있다.   child의 real pid=parent의 real pid +1   세 가지를 다 써보는 예제   #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt;  int main(int argc, char *argv[]){ \tpid_t pid; \tif(argc!=3){ \t\tfprintf(stderr, \"Usage: %s &lt;command&gt; &lt;arg&gt;\\n\",argv[0]); \t\texit(1); \t} \tpid=fork(); \tif(pid&lt;0){ \t\t/* error occured */ \t\tfprintf(stderr, \"fork(2) failed\\n\"); \t\texit(1); \t} \tif(pid==0){  \t\t/* child process */ \t\texecl(argv[1], argv[1], argv[2], NULL);  \t\t/* Shouldn't reach here */ \t\tperror(argv[1]); \t\texit(99); \t} \telse { \t\t/* parents process */ \t\tint status;  \t\twaitpid(pid, &amp;status, 0); \t\tprintf(\"child (PID=%d) finished; \", pid); \t\tif(WIFEXITED(status)) \t\t\tprintf(\"exit, status=%d\\n\", WEXITSTATUS(status)); \t\telse if(WIFSIGNALED(status)) \t\t\tprintf(\"signal, sig=%d\\n\", WTERMSIG(status)); \t\telse \t\t\tprintf(\"abnormal exit\\n\"); \t\texit(0); \t} }   $ gcc -g -Wall spawn.c -o spawn $ ./spawn /bin/echo OK OK child (PID=20092) finished; exit,status=0  # 만약 존재하지 않는 프로그램을 실행 한다면? $ ./spawn /usr/bin/notexist xxx /usr/bin/notexist: No Such file or directory child (PID=20339) finished; exit, status=99      fork()한다.   child에서 새로운 프로세스 exec   parent는 wait   execl로 실행된 프로세스가 exit하며 return 값을 wait에 반환한다.   posix_spawn()  posix_spawn():3      확장된 프로세스 실행 방법            IEEE std. 1003.1d-1999 posix_spawn 계열의 새로운 프로세스 실행 방법 제안           posix_spawn에는 부모 프로세스의 자원 중 6가지를 선택적 복제            열린 파일       프로세스 그룹 ID       유저 및 그룹 ID       시그널 마스크       스케줄링           부모 프로세스의 자원 선택적 복제            fork-exec는 부모 프로세스의 자원을 선택적 복제할 수 없었음                             parameter       description                 *pid       -                 *path       실제로 생성할 자식 프로세스의 실행 파일 경로 절대경로, 상대경로, 현재 실행 위치 tip) path는 경로, file은 PATH에서 찾음                 posix_spawn_file_actions_t *file_actions       posix_spawn이 실행하면서 열거나 닫을 파일의 정보를 담은 구조체 posix_spawn도 부모 프로세스가 열었던 파일은 모두 상속받는다. 추가로 열어야 할 파일이 있거나 기존에 열은 파일을 닫아야 할 필요가 있을 경우에만 사용                 posix_spawnattr_t *restrict attrp       부모 프로세스 자원 선택적 복제 posix_spawnattr_t구조체는 EUID, 프로세스 그룹, 기본 시그널 작동, 시그널 블록 마스크, 스케줄링 파라미터, 스케줄러 설정 NULL: fork-exec와 동일한 작동, 부모 프로세스의 자원을 모두 복제                 *restrict argv       argv                 *restrict envp       envp                          return       value                 성공       0                 실패       양수, errno set              전통적인 UNIX system call은 int 반환 시, 0이 성공            스레드, 비동기처리가 활용되면서 전역 변수인 errno를 사용하는 구조는 문제(pthread는 errno를 스레드 별로 분리하므로 큰 문제x)       POSIX에서 새로 추가된 system call의 return                    성공: 0 반환           실패: errno가 가지던 EINVAL, EACCESS 같은 매크로 값들이 양수를 반환                           posix_spawn_file_actions_t 구조체 조작                      posix_spawn_file_actions_t *file_actions       posix_spawn이 실행하면서 열거나 닫을 파일의 정보를 담은 구조체 posix_spawn도 부모 프로세스가 열었던 파일은 모두 상속받는다. 추가로 열어야 할 파일이 있거나 기존에 열은 파일을 닫아야 할 필요가 있을 경우에만 사용           int posix_spawn_file_actions_init(posix_spawn_file_actions_t *file_actions);     file_actions 구조체를 초기화한다.   int posix_spawn_file_actions_destroy(posix_spawn_file_actions_t *file_actions);     file_actions 구조체 사용한 후 연결된 메모리 해제   int posix_spawn_file_actions_addopen(posix_spawn_file_actions_t *restrict file_actions,  \t\tint fildes, const char *restrict path, int oflag, mode_t mode);     자식 프로세스가 생성되면서 추가로 오픈할 파일을 지정할 수 있다.   int posix_spawn_file_actions_addclose(posix_spawn_file_actions_t *file_actions, int fildes);     오픈했던 fd를 닫는 close-on-exec 기능 설정   int posix_spawn_file_actions_adddup2(posix_spawn_file_actions_t *file_actions, int fildes, int newfildes);     자식 프로세스가 생성되면 새 fd를 복제하는 기능, dup2 참고   posix_spawn file_action 예제         posix_spawnattr_t 구조체 조작                      posix_spawnattr_t *restrict attrp       부모 프로세스 자원 선택적 복제 posix_spawnattr_t구조체는 EUID, 프로세스 그룹, 기본 시그널 작동, 시그널 블록 마스크, 스케줄링 파라미터, 스케줄러 설정 NULL: fork-exec와 동일한 작동, 부모 프로세스의 자원을 모두 복제           int posix_spawnattr_init(posix_spawnattr_t *attr);     posix_spawnattr_t구조체 초기화   int posix_spawnattr_getflags(const posix_spawnattr_t *restrict attr, short *restrict flags); int posix_spawnattr_setflags(posix_spawnattr_t *attr, short *flags);     설정할 속성을 플래그로 표시   posix_spawnattr_t구조체는 EUID, 프로세스 그룹, 기본 시그널 작동, 시그널 블록 마스크, 스케줄링 파라미터, 스케줄러 설정            EUID 설정 제외                    나머지 기능들은 해당 속성의 on/off를 의미하는 플래그 설정 및 개별적으로 속성을 등록하는 함수 사용                       기본적으로 자식 프로세스의 EUID는 부모 프로세스의 EUID를 상속 받는다.       보안 문제, 권한 등의 이유로 부모 프로세스의 RUID를 상속 받아야 한다면, POSIX_SPAWN_RESETIDS를 셋팅하고 자식 프로세스를 생성       set-uid 시스템콜 참조           표 bitwise-inclusive OR로 결합 가능한 플래그 중에서 POSIX_SPAWN_RESETIDS를 제외한 나머지 5개의 플래그는 설정 후, 상세한 개별 속성을 지정하는 함수를 별도로 사용해야함!!                  flag       해당 플래그가 설정된 경우에 자식 프로세스의 작동 설명                 POSIX_SPAWN_RESETIDS       자식 프로세스의 EUID(Effective UID)를 부모 프로세스의 RUID(Real UID)로 설정한다. 하지만, 실행될 파일에 SetUID비트가 설정되어 있다면 POSIX_SPAWN_RESETIDS의 플래그는 무시, 해당 파일의 소유권자 UID(Owner UID)로 EUID가 설정된다.                 POSIX_SPAWN_SETPGROUP       프로세스 그룹 관련 속성을 활성화한다. 활성화 후 posix_spawnattr_setpgroup으로 속성을 설정한다.                 POSIX_SPAWN_SETSIGDEF       기본 시그널 작동 속성을 활성화한다. 활성화 후 posix_spawnattr_setsigdefault로 속성을 설정한다.                 POSIX_SPAWN_SETSIGMASK       시그널 블록 마스크 속성을 활성화한다. 활성화 후 posix_spawnattr_setsigmask로 속성을 설정한다.                 POSIX_SPAWN_SETSCHEDPARAM       스케줄링 파라미터 속성을 활성화한다. 활성화 후 posix_spawnattr_setschedparam으로 속성을 설정한다.                 POSIX_SPAWN_SETSCHEDULER       스케줄러 정책 속성을 활성화한다. 활성화 후 posix_spawnattr_setschedpolicy로 속성을 설정한다.              posix_spawnattr_t의 프로세스 그룹 속성 조작    int posix_spawnattr_getpgroup(const posix_spawnattr_t *restrict attr, pid_t *restrict pgroup); int posix_spawnattr_setpgroup(posix_spawnattr_t *attr, pid_t pgroup);     POSIX_SPAWN_SETPGROUP로 프로세스 그룹 속성 활성화 플래그 set   posix_spawnattr_setpgroup 함수로 생성될 자식 프로세스의 PGID를 변경할 수 있다. 아래 예제 참고         PGID(프로세스 그룹 ID)가 0이되면 자식 프로세스는 프로세스 그룹 리더됨   부모 프로세스로 부터 탈퇴   같은 세션 내에서 다른 프로세스 그룹에 편입되려면 해당 PGID를 넣어주면된다.   이 기능은 시스템 함수인 setpgid와 동일하므로 프로세스 그룹에 대해 알고 있다면 이해가 쉽다.   posix_spawnattr_t의 시그널 관련 속성 조작    int posix_spawnattr_getsigdefault(const posix_spawnattr_t *restrict attr, sigset_t *restrict sigdefault); int posix_spawnattr_setsigdefault(posix_spawnattr_t *restrict attr, const sigset_t *restrict sigdefault); int posix_spawnattr_getsigmask(const posix_spawnattr_t *restrict attr, sigset_t *restrict sigmask); int posix_spawnattr_setsigmask(posix_spawnattr_t *restrict attr, const sigset_t *restrict sigmask);     시그널 관련으로는 2가지 속성 설정이 가능하다.            시그널 핸들러 리셋 -&gt; 기본 값으로   posix_spawnattr_setflags에 POSIX_SPAWN_SETSIGDEF 플래그 설정   posix_spanattr_setsigdefault()를 이용해 세부적 시그널 목록 설정       시그널 블록 마스크             중요!  부모 프로세스가 자식 프로세스의 기능을 제어하려면 어떤 방법이 있는지 생각해보자.      간단한 제어 명령: 시그널 핸들러를 사용   복잡한 제어 명령: IPC     위와 같은 형태의 서버 프로그램에서는 시그널 핸들러가 부모와 자식 프로세스가 각각 다르다.     부모 프로세스는 SIGTERM을 무시, 자식 프로세스는 SIGTERM을 받으면 종료한다고 하자.   부모 프로세스와 자식 프로세스가 속한 프로세스 그룹에 대해 SIGUSR1 시그널이 전파되면 일부 자식프로세스만 반응하도록 하고 싶다면 어떻게 프로그래밍해야 할까?   기존 fork-exec에서 위의 기능을 그대로 구현     매번 자식 프로세스를 fork하기 직전에 부모 프로세스의 시그널 핸들러와 시그널 마스크를 잠시 교체하고 fork 후에 다시 복구   이런 방식은 갑작스런 시그널에 대응하기 힘들어서 신뢰성이 높지 못하다.   시그널 핸들러 선택적 설정      부모 프로세스 SIGUSR1 SIGUSR2 SIGTERM 핸들러를 무시(lgn)로 동작하도록 설정되어 있다.   SIGUSR1, SIGUSR2, SIGTERM의 디폴트 동작은 종료(Term)   posix_spanattr_setsigdefault()를 이용해 SIGTERM을 디폴트로 리셋하고 자식 프로세스 생성         시그널 핸들러 테스트용 자식 프로그램     int main(){   printf(\"Child[%d]: Start\\n\", getpid());   printf(\"Child[%d]: raise(SIGUSR1)\\n\", getpid());   raise(SIGUSR1);   printf(\"Child[%d]: raise(SIGUSR2)\\n\", getpid());   raise(SIGUSR2);   printf(\"Child[%d]: raise(SIGTERM)\\n\", getpid());   raise(SIGTERM);   printf(\"Child[%d]: Exit\\n\", getpid());   return 0; }           시그널 마스크 설정      시그널 마스크 설정: 시그널은 프로세스에 전달되지 못하고 막힌다.            기본적으로 시그널 마스크는 모두 해제된 상태                 선택적으로 프로세스 그룹에 시그널을 전파하는 기능 예제   부모 프로세스는 그룹X(자식 2개) 그룹Y(자식 2개) 생성            그룹 X: SIGUSR2 마스크 됨, SIGTERM 받을 수 있음       그룹 Y: SIGUSR1 마스크 됨, SIGTERM 받을 수 있음           부모 프로세스는 프로세스 그룹 내에 SIGUSR1, SIGUSR2, SIGTERM을 순서대로 전파      kill(-getpgid(0), SIGUSR1) = killpg(getpgid(0), SIGUSR1)     getpgid(0): 현재 프로세스의 프로세스 그룹 ID return   '-': 프로세스 그룹 ID내 프로세스 전체에 시그널 전달하라     자식 프로세스의 코드      posix_spawnattr_t의 스케줄링 관련 속성 조작    int posix_spawnattr_getschedpolicy(const posix_spawnattr_t *restrict attr, int *restrict schedpolicy); int posix_spawnattr_setschedpolicy(posix_spawnattr_t *attr, int schedpolicy);     자식 프로세스의 스케줄링 정책 설정            POSIX_SPAWN_SETSCHEDULER 플래그       posix_spawnattr_setschedpolicy() 함수           int posix_spawnattr_getschedparam(const posix_spawnattr_t *restrict attr, struct sched_param *restrict schedparam); int posix_spawnattr_setschedparam(posix_spawnattr_t *restrict attr, const struct sched_param *restrict schedparam);     스케줄링 파라미터 지정            POSIX_SPAWN_SETSCHEDPARAM 플래그       posix_spawnattr_setschedparam() 함수           자세한 인수들은 추후 설명   ","categories": ["process"],
        "tags": [],
        "url": "https://markyang920413.github.io//process/system_programming-process-processAPI_1/",
        "teaser": null
      },{
        "title": "프로세스 API <2> 좀비프로세스 피하기, exit()",
        "excerpt":"_exit():2   #include &lt;unistd.h&gt;  void _exit(int status);     기능: argument로 지정한 status를 종료 상태로 하여 종료한다. 절대 실패하지 않는다.   exit():3   #include &lt;stdlib.h&gt;  void exit(int status);          기능: argument로 지정한 status를 종료 상태로 하여 종료한다. 절대 실패하지 않는다.       _exit() exit()의 차이            exit()는 stdio버퍼를 전부 해제한다.       exit()는 atexit()로 등록한 처리를 실행한다.       즉, exit()는 libc 함수이므로, libc와 관련된 각종 뒤처리를 수행한다.           exit(0): 성공, exit(1): 실패는 UNIX에선 맞지만, 그 외 시스템에서는 다를 수도 있다.   exit(EXIT_SUCCESS), exit(EXIT_FAILURE)라는 매크로를 사용하면 호환성이 좋다.   좀비 프로세스 피하는방법     fork()시 parent가 wait   이중 fork()   sigaction() 사용        wait를 하는 권리는 직계 부모에게만 있다.   자식 프로세스가 없어지면, 손자 프로세스를 wait하는 권리를 가진 프로세스도 없어진다. 따라서, 커널도 손자 프로세스를 좀비로 두지 않고 종료하면 즉시 정리한다.   3번 sigaction은 추후 설명   wait():2     child process를 기다리는데는 wait()나 waitpid()를 사용한다.   #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt;  pid_t wait(int *status); pid_t waitpid(pid_t pid, int *status, int options);  wait(&amp;status) == waitpid(-1, &amp;status, 0); // 같은 기능     wait()는 임의의 child 기다림 + 기다린 프로세스 정보 Get!!   waitpid()는pid 명시해 기다림 + 기다린 프로세스 정보 Get!!   wait는 child process가 종료될 때까지 호출한 프로세스는 중지된다.   state 변화 정보를 얻는다.            child process 종료, signal에 의한 stop, signal에 의한 resume…           wait는 child process에 관련된 자원을 release 한다. Parent의 wait가 동작하지 않으면, child process는 zomebie 프로세스가 된다.   child process가 이미 state가 바뀌었다면, wait는 즉시 리턴된다.         wait(), waitpid() return                  상황       &amp;status에 기록되는 값       waitpid return 값                       child process 정상적 종료       WIFEXITED(status) = child process가 exit로 정상적 종료 시, 0이 아닌 값 WEXITSTATUS(status) = 하위 8bit 참조해 child process의 return 값 얻음       process ID                 child process 비정상적종료       WIFSIGNAL(status) = 시그널로 종료 시, 0이 아닌 값 WTERMSIG(status) = 시그널로 종료했으면 시그널 번호를 반환!       process ID                 waitpid 함수 오류       ECHILD: 호출 프로세스의 child process 미생성 EINTR: 시스템 콜이 인터럽트 되었음       -1                 pid_t waitpid(pid_t pid, int *status, int options);                  waitpid의 pid real pid 아님!       Description                       pid &lt; -1       프로세스 그룹 ID가 pid의 절댓값과 같은 자식 프로세스를 기다림                 -1       임의의 자식 프로세스를 기다림                 0       호출 프로세스의 프로세스 그룹 PID와 같은 프로세스 그룹 ID를 가진 프로세스 기다림                 pid &gt; 0       프로세스 ID가 pid인 자식 프로세스 기다림 기다릴 pid 명시                          options       Description                       WCONTINUED       중단되었다가 재개된 자식 프로세스의 상태 받음                 WNOHANG       기다리는 PID가 종료되지 않아, 즉시 종료 상태를회수 할 수 없는 상황에서 호출한 프로세스는 차단되지 않고 반환 값으로 0을 얻음                 WUNTRACED       중단된 자식 프로세스의 상태를 받음           simple fork 예제    #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/wait.h&gt; #include &lt;errno.h&gt; #include &lt;err.h&gt; #include &lt;signal.h&gt;  #define VERSION 1  static void child_fn(void){ \tprintf(\"Hi,I'm child [PID:%d]\\n\",getpid()); // getpid()는 진짜 real PID 보여줌 \texit(EXIT_SUCCESS); }  int main(){ \tint ret=EXIT_FAILURE; \tint i=0, ncreated=0; \tint nproc=5; // How many child process will you made?  \tpid_t *pids=(pid_t*)malloc(nproc*sizeof(pid_t)); \tif(pids==NULL){ \t\twarn(\"malloc(pids) failed\"); \t\texit(ret); \t}  \tfor(i=0, ncreated=0; i&lt;nproc;i++,ncreated++){ \t\tpids[i]=fork();\t\t// fork()하면서 child pid가 pids[i]에 담김 \t\tif(pids[i]&lt;0){ \t\t\tgoto wait_children; \t\t} else if(pids[i]==0){ // child의 pid_t 값은 0임 \t\t\t// child process \t\t\tchild_fn(); \t\t\t/* shouldn't reach here */ \t\t} \t}  \tret=EXIT_SUCCESS; \t// parent wait_children: \tif(ret==EXIT_FAILURE) \t\tfor(i=0;i&lt;ncreated;i++) \t\t\tif(kill(pids[i],SIGINT)&lt;0) \t\t\t\twarn(\"kill(%d) failed\\n\",pids[i]);  \tfor(i=0;i&lt;ncreated;i++){ \t\t/* \t\t * if(wait(NULL)&lt;0) \t\t * \twarn(\"wait() failed\"); \t\t * \t\t */ \t\tint status; \t\tpid_t ChildPid;  #if VERSION == 1 \t\tChildPid=wait(&amp;status); #elif VERSION == 2 \t\t/* 에러 발생시 명시적으로 처리하고 wait */ \t\twhile(((ChildPid=wait(&amp;status))==-1)&amp;&amp;errno==EINTR); // 인터럽트로 비정상 종료시, 무한 루프로 다시 wait 건다 \t\t{ #endif \t\tif(ChildPid&lt;0){ \t\t\tprintf(\"[ERROR] %d\\n\",errno); \t\t\tperror(\"wait func error!\"); \t\t} else { \t\t\tif(WIFEXITED(status)) \t\t\t\tprintf(\"wait: 자식 프로세스 정상 종료 %d\\n\",WEXITSTATUS(status)); \t\t\telse if(WIFSIGNALED(status)) \t\t\t\tprintf(\"wait: 자식 프로세스 비정상 종료 %d\\n\",WTERMSIG(status)); \t\t} #if VERSION == 2 \t\t} #endif \t} \tfree_pids: \t\tprintf(\"Original Process [PID:%d]!\\n\",getpid()); \t\tprintf(\"pids free is done!\\n\"); \t\tfree(pids); \texit(ret); }     getpid()으로 real pid 구할 수 있다.   child의 real pid=parent의 real pid +1   Copy on Write 방식의 fork()     할당 시, 가상 메모리 방식을 사용한다.   부모 프로세스의 메모리를 자식 프로세스에 전부 복사 X, 페이지 테이블만 복사하여 속도↑   PTE(페이지 테이블 엔트리) 안에는 write권한을 나타내는 필드가 있다.            PTE는 커널 메모리 영역에 있음                부모 자식도 전체 페이지에 write 권한 무효화한다.       부모 혹은 자식이 write 시도 시, 다음과 같이 공유 해제            CPU에 페이지 폴트 발생       CPU가 커널 모드로 변경되어 커널의 페이지 폴트 핸들러 동작       페이지 폴트 핸들러는 접근한 페이지를 다른 장소에 복사하고, write하려고 한 프로세스에 할당한 후 내용을 다시 작성       부모 프로세스, 자식 프로세스 각각 공유가 해제된 페이지에 대응하는 PTE 업데이트                    write한 프로세스 쪽에 엔트리는 새롭게 할당된 물리 페이지를 매핑해 write 허가           다른 쪽 프로세스의 엔트리에도 write허가                       이후 공유가 해제된 페이지에는 각각 자유롭게 R/W 가능           Copy On Write 실험      100MB 메모리를 확보하여 모든 페이지에 접근   시스템의 메모리 사용량 확인   fork() 시스템 콜 호출   부모 프로세스와 자식 프로세스가 각각 다음과 같은 동작을 한다.            부모 프로세스                    자식 프로세스의 종료 기다림                       자식 프로세스                    시스템 메모리의 사용량과 자기 자신의 가상 메모리 사용량, 물리 메모리의 사용량, Major Fault의 횟수, Minor Fault 횟수 표시           위에서 획득한 영역 전부의 페이지에 접근           위 결과 횟수 표시                           copy_on_write.c    #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/mman.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;err.h&gt;  #define BUFFER_SIZE (100*1024*1024) #define PAGE_SIZE 4096 #define COMMAND_SIZE 4096  static char *p; static char command[COMMAND_SIZE];  static void child_fn(char *p){ \tprintf(\"*** child ps info before memory access ***:\\n\"); \tfflush(stdout); \tsnprintf(command,COMMAND_SIZE,\"ps -o pid,comm,vsz,rss,min_flt,maj_flt | grep %d\",getpid()); \t// shell cmd에 명령을 내리는 문자열 \t// vsz: 가상 메모리양 \t// rss: 확보된 물리 메모리양 \tsystem(command);  \tprintf(\"*** free memory info before memory access ***:\\n\"); \tfflush(stdout); \tsystem(\"free\");  \tint i; \tfor(i=0;i&lt;BUFFER_SIZE;i+=PAGE_SIZE) \t\tp[i]=0;  \tprintf(\"*** child ps info after memory access ***:\\n\"); \tfflush(stdout); \tsystem(command);  \tprintf(\"*** free memory info after memory access ***:\\n\"); \tfflush(stdout); \tsystem(\"free\");  \texit(EXIT_SUCCESS); }  static void parent_fn(void){ \twait(NULL);  \texit(EXIT_SUCCESS); }  int main(void){ \tchar* buf; \tp=malloc(BUFFER_SIZE); \tif(p==NULL) \t\terr(EXIT_FAILURE,\"malloc() failed\");  \tint i; \tfor(i=0;i&lt;BUFFER_SIZE;i+=PAGE_SIZE) \t\tp[i]=0;  \tprintf(\"*** free memory info before fork ***:\\n\"); \tfflush(stdout); \tsystem(\"free\");  \tpid_t ret; \tret=fork(); \tif(ret==-1) \t\terr(EXIT_FAILURE,\"fork() failed\");  \tif(ret==0) \t\tchild_fn(p); \telse \t\tparent_fn();  \terr(EXIT_FAILURE,\"shouldn't reach here\"); }   #include &lt;unistd.h&gt;  pid_t fork(void);     기능: fork()는 프로세스 자신을 복제해서 새로운 프로세스를 만드는 시스템 콜            parent process: 원래 존재하는 프로세스       child process: parent process에서 복제되어 만들어진 프로세스                          return       value                       성공       Parent process get 0                 실패       Parent process get -1           exec():2     exec는 새로운 프로세스 호출 덮어씌워짐            exec를호출하면, 그 시점에서 실행 중인 프로그램 소멸 후 새로운 프로그램 로드           #include &lt;unistd.h&gt;  int execl(const char *path, const char *arg, ... /* NULL */); int execlp(const char *program, const char *arg, ... /* NULL */); int execle(const char *path, const char *arg, ..., /* NULL, */ char * const envp[]); int execlv(const char *path, char * const argv[]); int execvp(const char *program, char * const argv[]); int execve(const char *path, char * const argv[], char * const envp[]);     UNIX: execve()만 시스템 콜, 나머지는 라이브러리 함수   API 이름 뒷 부분에 l(list)가 붙은 경우는 argument를 가변 인자로 전달, 마지막 NULL   API 이름 뒷 부분에 v(vector)가 붙은 경우는 argument를 문자열 배열로 전달, 마지막 NULL            1, 2번 째 인자에는 프로그램 이름 중복           execl(\"/bin/cat\", \"cat\", \"hello.c\", NULL);  char *argv[3]={ \"cat\", \"hello.c\", NULL); execv(\"bin/cat\", argv);      API 이름 뒷 부분에 e가 붙은 경우, 환경변수인 envp가 추가된다. e가 붙지 않은 경우, 현재 프로세스 환경 변수 그대로 사용   API 이름 뒷 부분에 p가 붙은 경우, $PATH에서 프로그램을 찾는다. p가 붙지 않은 경우, 프로세스를 절대 경로 또는 상대 경로로 지정해야 한다.   exec는 성공하면 호출이 돌아오지 않기 때문에 호출이 돌아온 경우는 언제나 실패했음을 의미한다. 실패했을 때는 -1을 반환하고 errno에 에러 번호가 설정한다.   세 가지를 다 써보는 예제   #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt;  int main(int argc, char *argv[]){ \tpid_t pid; \tif(argc!=3){ \t\tfprintf(stderr, \"Usage: %s &lt;command&gt; &lt;arg&gt;\\n\",argv[0]); \t\texit(1); \t} \tpid=fork(); \tif(pid&lt;0){ \t\t/* error occured */ \t\tfprintf(stderr, \"fork(2) failed\\n\"); \t\texit(1); \t} \tif(pid==0){  \t\t/* child process */ \t\texecl(argv[1], argv[1], argv[2], NULL);  \t\t/* Shouldn't reach here */ \t\tperror(argv[1]); \t\texit(99); \t} \telse { \t\t/* parents process */ \t\tint status;  \t\twaitpid(pid, &amp;status, 0); \t\tprintf(\"child (PID=%d) finished; \", pid); \t\tif(WIFEXITED(status)) \t\t\tprintf(\"exit, status=%d\\n\", WEXITSTATUS(status)); \t\telse if(WIFSIGNALED(status)) \t\t\tprintf(\"signal, sig=%d\\n\", WTERMSIG(status)); \t\telse \t\t\tprintf(\"abnormal exit\\n\"); \t\texit(0); \t} }   $ gcc -g -Wall spawn.c -o spawn $ ./spawn /bin/echo OK OK child (PID=20092) finished; exit,status=0  # 만약 존재하지 않는 프로그램을 실행 한다면? $ ./spawn /usr/bin/notexist xxx /usr/bin/notexist: No Such file or directory child (PID=20339) finished; exit, status=99      fork()한다.   child에서 새로운 프로세스 exec   parent는 wait   execl로 실행된 프로세스가 exit하며 return 값을 wait에 반환한다.   ","categories": ["process"],
        "tags": [],
        "url": "https://markyang920413.github.io//process/system_programming-process-processAPI_2/",
        "teaser": null
      },{
        "title": "프로세스 API <3> 프로세스 관계, pstree, getpid(), 프로세스그룹 setpgid(), 세션 setsid(), 대몬 프로세스",
        "excerpt":"pstree 명령     리눅스에서는 어떠한 프로세스도 fork() &amp; exec()나 비슷한 API로 생성된다. 프로세스를 부모/자식 관계로 이어 가면 하나의 트리 구조로 구성할 수 있다.   pstree 명령은 프로세스 부모/자식 관계 트리를 표시한다.        systemd: 부팅 시 커널이 직접 실행, 모든 프로세스의 시작            getty 프로그램 시작하는 역할도 함           getpid():2, getppid():2   #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;  pid_t getpid(void); pid_t getppid(void);     기능            getpid(): 자신의 PID 반환       getppid(): 부모의 PID 반환           다른 프로세스 정보  /proc/[PID]에서 얻을 수 있다.   참고   프로세스 그룹과 세션       프로세스 그룹: 셸때문에 존재한다.            셸을 사용해서 여러 개의 명령어를 파이프로 연결해 기동했다고 하자.                    파이프로 연결된 명령어 중 하나에 문제가 있어 ctrl+c로 중단했다면, 프로세스 중 어떤 것이 종료되어야 할까?           답은 파이프로 연결된 모든 프로세스가 멈춰야한다.                       파이프로 연결된 프로세스 집단을 하나의 프로세스 그룹으로 통합하여 그룹의 프로세스에 시그널 한방으로 관리               세션: 사용자의 로그인 ~ 로그아웃까지 흐름을 관리하기 위한 개념            로그인 셸을 기점으로 사용자가 동일 단말로 부터 기동한 프로세스를 하나로 통합할수 있다.       하나의 세션은 복수의 프로세스 그룹을 통합하는 형태       세션과 연결된 단말을 프로세스의 제어 단말(controlling terminal)이라고 한다.           프로세스 그룹과 세션 리더      ps j 로 프로세스 그룹, 세션을 볼 수 있다.        PPID: 부모 프로세스 ID   PID: 프로세스 ID   PGID: 프로세스 그룹 ID   SID: 세션 ID     프로세스 그룹 리더: 처음으로 그 프로세스 그룹을 만든 프로세스가 리더            PID == PGID           세션 리더: 처음으로 그 세션을 만든 프로세스가 리더            PID == SID           리더: 특별히 권한이 강한 것은 없고, 새로운 프로세스 그룹, 세션을 만들 수 없는 프로세스다.   대몬 프로세스      ps -ef: 시스템에서 작동하고 있는 모든 프로세스표시        대몬 프로세스: TTY에 ? 되있는 프로세스들이 있는데, 제어 단말이 없는 프로세스이다.            서버로 동작하기 위해서~!       특정 단말로 로그인해 서버를 돌리다가 로그아웃 시, 그 세션 프로세스들 모두 종료되기 때문에 대몬 프로세스를 둔다.           대몬 프로세스가 되기 위한 조건            고아 프로세스가 되어야 한다.                    대몬 프로세스는 완전히 독립된 프로세스다.                       표준 입력, 출력, 에러를 닫아야한다.                    대몬 프로세스와 상호작용은 IPC로만 할 것                       터미널을 가지지 않는다.                    단말 X                           대몬 프로세스 만들기    #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;  int main(){ \tint pid; \tint i;  \ti=1000; \tpid=fork(); \tif(pid==-1){ \t\tperror(\"fork error\\n\"); \t\texit(0); \t} else if(pid==0){ \t\t// 자식 프로세스가 실행시키는 코드 \t\tprintf(\"자식: 내 PID는 %d\\n\", getpid());  \t\t/* 표준 IO, ERR 닫기 */ \t\tclose(0); \t\tclose(1); \t\tclose(2);  \t\t/* setsid()를 통해서 자신만의 독립적인 환경 만든다. \t\t   기존의 환경이 리셋되면서, 터미널이 사라진다. */ \t\tsetsid(); \t\twhile(1){ \t\t\tprintf(\"---&gt;%d\\n\", i); \t\t\ti++; \t\t\tsleep(1); \t\t} \t} else { \t\t// 부모 프로세스가 실행시키는 코드  \t\t/* 대몬 프로세스는 고아가 되어야한다. \t\t   따라서, 부모 프로세스는 바로 종료 */ \t\tprintf(\" 부모 : 내가 낳은 자식의 PID는 %d\\n\", pid); \t\tsleep(1); \t\tprintf(\"부모 종료\\n\"); \t\texit(0); \t} \treturn 0; }   $ ps -efjc | grep daemon UID\t\tPID\tPPID\tPGID\tSID\tCLS\tPRI\tSTIME\tTTY\t\tTIME\tCMD yundream\t8282\t1\t8252\t8252\tTS\t24\t00:43\t?\t00:00:00\t./daemon     PPID가 1이고 새로운 Session ID 8252인 대몬 생성됨   setpgid():2   #include &lt;unistd.h&gt;  int setpgid(pid_t pid, pid_t pgid);     기능: 새로운 프로세스 그룹만듬                  return       value                       성공       0                 실패       -1 errno set                          parameter       Description                       pid       설정할 pid 0 지정 시, 현재 프로세스가 대상                 pgid       위 프로세스에게 부여할 프로세스 그룹 ID 0 지정 시, 현재 PID가 PGID로 사용 즉, 자신이 리더가 되어 새로운 프로세스 그룹을 만들고 싶은 경우 (0, 0) 설정           setsid():2   #include &lt;unistd.h&gt;  pid_t setsid(void);     기능: 새로운 세션을 만들고 스스로 세션 리더, 그 세션에 최초의 프로세스 그룹 작성하고 프로세스 그룹 리더가 된다.   만들어진 세션은 제어 단말을 가지지 않는다.            즉, 세션 리더가 되는 동시에 대몬이 되는 것이다.           주의: 현 프로세스가 프로세스 그룹 리더라면 setsid()는 실패                  return       value                       성공       세션ID(일반적으로 현 프로세스 PID)                 실패       -1 errno set           ","categories": ["process"],
        "tags": [],
        "url": "https://markyang920413.github.io//process/system_programming-process-processAPI_3/",
        "teaser": null
      },{
        "title": "valgrind 메모리 누수 체크 디버거",
        "excerpt":"valgrind     메모리 문제를 찾을 수 있는 메모리 디버거            valgrind, mpatrol, dmalloc, LeakTracer, mcheck 등과 같은 다른 메모리 디버거도 있다.           가상으로 프로그램을 실행시켜 프로그램에서 요청하는 malloc, _free_를 잡아채 문제가 있는지 분석      바이너리 -g 옵션 재 컴파일   cmd 실행   $ valgrind --tool=memcheck --leak-check=yes --leak-resolution=high -v ./binary     결과      에러의 원인과 결과 출력     2 alloc, 3 free   Invalid free() at main (temp.c:11)   ","categories": ["linux-tools"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-tools/valgrind/",
        "teaser": null
      },{
        "title": "errno변수, perror(), strerror(), feof(), ferror(), clearerr()",
        "excerpt":"errno 변수     시스템 콜, 파일 스트림이 실패할 경우 원인 정수 값이 errno에 설정            예) 파일이 존재하지 않을 때: ENOENT, 인자 값이 올바르지 않을 때 EINVAL           perror():3   #include &lt;stdio.h&gt;  void perror(const char *s);  기능: errno값에 해당하는 에러 메시지를 표준 에러 출력에 출력 문자열 s가 빈 문자열이 아닌 경우에는 s의 내용 출력 후 에러 메시지 출력.   $ ./cat not_exist_file\t# 존재하지 않는 파일 : No such file or directory # errno에 해당하는 에러 메시지 출력 $ ./cat .. ..: Is a directory   strerror():3   #include &lt;string.h&gt;  char *strerror(int errnum);  기능: errno 값인 errnum에 해당하는 에러 메시지를 반환. strerror()의 반환값을 다시 함수를 호출할 때 덮어써지므로 보통 즉시 출력한다.   feof():3   #include &lt;stdio.h&gt;  int feof(FILE *stream);  기능: stream의 EOF 플래그를 가져온다. EOF 플래그는 처음 0(거짓)을 가지다 stream을 읽는 작업이 EOF에 도달하면, 0이 아닌 값이 설정 된다.    하지만, feof()는 다른 stdio함수가 데이터를 읽어서 EOF에 도달해야 비로소 0이 아닌 값으로 반환한다.  따라서 아래와 같은 잘못된 코드를 작성할 수 있다.   char buf[1024]; while (! feof(stdin)){ \tfgets(buf, 1023, stdin); \tfputs(buf, stdout); }   이 코드는 fgets()를 사용해 데이터를 읽기 전에 feof()를 사용하고 있다.  따라서, fgets()가 실제로 EOF를 만나고 나서도 fputs()가 실행된 후에야 루프를 빠져나온다.  결과적으로 마지막 줄이 두 번 출력된다.    feof()는 fread()처럼 반환값이 EOF인지 에러인지 구별할 수 없는 API와 함께 사용하는 것이 바람직하다.  하지만 곧 이어 설명하는 ferror()를 사용하는 것이 더 좋다.   ferror():3   #include &lt;stdio.h&gt;  int ferror(FILE *stream);  기능: ferror()는 지정 stream의 에러 플래그를 가져온다. 에러 플래그는 stream이 만들어 질 때 0, IO작업에서 에러가 발생했을 때 0이 아닌 값   이 함수는 fread()함수 처럼 반환 값을 에러와 EOF로 구분할 수 없는 API에서 에러만을 확인하기 위해 사용된다.   clearerr():3   #include &lt;stdio.h&gt;  void clearerr(FILE *stream);  기능: stream의 에러 플래그와 EOF 플래그를 지운다.   tail -f 처럼 계속 생성되는 파일을 출력하는 경우, EOF에 도달 후에도 다른 프로세스가 내용을 추가하면 계속 읽어야한다.  그러나 stdio는 read()가 한 번이라도 EOF를 반환하면 FILE에 EOF 플래그를 설정하기 때문에 이후 read()를 호출하지 않는다.   이 때, clearerr()을 사용한다. clearerr()는 EOF 플래그도 초기화하므로 stdio가 다시 read()를 사용할 수 있게된다.  ","categories": ["c"],
        "tags": [],
        "url": "https://markyang920413.github.io//c/error/",
        "teaser": null
      },{
        "title": "stdio <1> stdio, fopen(), fclose()",
        "excerpt":"stdio     stdio: standard I/O 표준 입출력 라이브러리   시스템 콜은 바이트 단위로 R/W            지정한 버퍼 크기 만큼 R/W           stdio 라이브러리 함수는 문자 단위, 줄 단위로 R/W            stdio만의 독자적인 버퍼 사용한다.                    내부적으로 적절한 크기로 read()를 사용해 stdio 버퍼로 가져와, 프로그램이 요구한 만큼 반환                           읽기 때, 버퍼링            적절한 크기만큼 시스템 콜 read()를 사용해 stdio 버퍼에 저장       프로그램이 요청하는 만큼 반환해줌           쓰기 때, 버퍼링            바이트 단위, 줄 단위의 데이터를 전달받아 stdio 버퍼가 꽉차면 시스템 콜 write() 내부적 호출       스트림이 단말에 연결된 경우, 버퍼가 가득 찰 때까지 기다리지 않음!  ‘\\n’ 만나면 시스템 콜 write() 호출       비 버퍼링 모드로 셋된 경우, 즉시 write() 수행. setvbuf()로 설정 가능           버퍼링(2단계)            사용자 변수 &lt;—————&gt; 버퍼 &lt;—————————&gt; 커널  　　　　　메모리 복사　　　　　복사　       두 단계를 거치기 때문에 메모리 대역폭 비효율적 사용       real-time 시스템과 같이 응답성, 성능을 중시한다면 고수준 파일 처리를 최소한으로 사용하는 편       저수준보다 느리다는 말은 아님!           atomic 불가   fopen():3   #include &lt;stdio.h&gt;  FILE *fopen(const char *path, const char *mode);  FILE *fp; if((fp=fopen(\"streamfile.txt\", \"w\")) == NULL){ \t/* Error Handling */ } ... fclose(fp);  기능: path에 지정한 파일에 대한 스트림을 만들고, mode처럼 동작하게 만듬                  return       value                 성공       File Pointer                 실패       NULL                          parameter       Description                 *path       open할 파일                 *mode       path에 지정한 파일 스트림을 어떤 모드로 열 것인가?                          mode       읽기       쓰기       파일 포지션       파일 존재시       파일 부재시       시스템 콜 open()에서 대응되는 모드                 “r”       O       X       파일의 시작       성공       실패       O_RDONLY                 “w”       X       O       파일의 시작       기존 파일 제거 후 생성       생성       O_WRONLY, O_CREAT, O_TRUNC                 “a”       X       O       파일의 끝       성공       생성       O_WRONLY, O_CREAT, O_APPEND                 “r+”       O       O       파일의 시작       성공       실패       O_RDWR                 “w+”       O       O       파일의 시작       기존 파일 제거 후 생성       생성       O_RDWR, O_CREAT, O_TRUNC                 “a+”       O       O       읽기-파일의 시작 쓰기-파일의 끝       성공       생성       O_RDWR, O_CREAT, O_APPEND           또한, 바이너리 파일을 나타내기 위해 b를 추가할 수도 있다.  하지만 리눅스에서는 바이너리 파일과 테스트 파일의 구분이 없기 때문에 지정해도 무시된다.   #include &lt;stdio.h&gt;  int main(void){ \tFILE *fp; \t/* Case 1 */ \tfp=fopen(\"data\", \"w\"); \tif(fp==NULL){ \t\tperror(\"fopen error\\n\"); \t\treturn -1; \t} \t/* Case 2 */ \tif(!(fp=fopen(\"data\", \"w\"))){ \t\tperror(\"fopen error\\n\"); \t\treturn -1; \t} \tfclose(fp); }   fclose():3   #include &lt;stdio.h&gt;  int fclose(FILE *stream);  기능: stream이 가리키는 스트림을 닫는다.                  return       value                 성공       0                 실패       EOF(-1)                          parameter       Description                 *stream       닫을 파일 스트림           ","categories": ["stdio"],
        "tags": [],
        "url": "https://markyang920413.github.io//stdio/stdio_1/",
        "teaser": null
      },{
        "title": "stdio <2> Byte 단위 입출력 fgetc(), getc(), getchar(),fputc(), putc(), putchar(), ungetc()",
        "excerpt":"get, put series     Byte단위 입출력 API   #include &lt;stdio.h&gt;  int fgetc(FILE *stream); int getc(FILE *stream); int getchar(void); == getc(stdin);  기능: 지정한 File Stream으로 부터, 1Byte를 읽어 반환한다.                  return       value                       성공       읽은 값                 실패       EOF(-1)           #include &lt;stdio.h&gt;  int fputc(int c, FILE *stream); int putc(int c, FILE *stream); int putchar(int c); == putc(c, stdout);  기능: 지정한 File Stream에, c 1Byte 쓰기                  return       value                       성공       쓴 바이트                 실패       EOF(-1)           ungetc():3   #include &lt;stdio.h&gt;  int ungetc(int c, FILE *stream);   기능: 1Byte를 버퍼에 반환   바이트 c를 stream의 버퍼로 되돌린다.  즉, ungetc(c,steram) -&gt; fgetc(stream) = c 반환  단, 하나의 stream에 대해 연속 호출 불가   바이트 단위로 읽으며 토큰을 구분하기 위해 사용한다.     예를 들어, 문자열에서 숫자 부분만을 읽고 싶다면 반드시 한 글자를 더 읽어봐야 숫자가 끝났는지 알 수 있다.   숫자가 끝났는지 여부를 판별하고자 추가로 읽은 마지막 한 문자를 원래 스트림에 되돌려 놓기 위해 사용한다.   ","categories": ["stdio"],
        "tags": [],
        "url": "https://markyang920413.github.io//stdio/stdio_2/",
        "teaser": null
      },{
        "title": "stdio <3-1> Text mode: snprintf(), strstr()",
        "excerpt":"snprintf():3   #include &lt;stdio.h&gt;  int snprintf(char *str, size_t size, const char *fmt, ...)                  return       vlaue                       성공       문자열 마지막 \\0을 제외한 프린트된 문자 수                 실패       음수                          parameter       Description                       *str       저장할 주소                 size       최대 몇 Byte 저장할 것인가?                 *fmt       출력할 문자           #include &lt;stdio&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt;  int main(void){ \tpid_t pid; \tpid=getpid(); \tchar command[1024]; \tsnprintf(command, sizeof(command), \"cat /proc/%d/maps\", pid);  \tsystem(command); \treturn 0; }   strstr(): 문자열내 문자열 검색  #include &lt;string.h&gt;  char* strstr(char *const_String, char const *const_SubString); \t\t\t소스 문자열,　　　　　　 찾을 문자열 ex) char s1[1024]=\"A Garden Diary\"; char* strstr(s1, \"den\");     기능: 문자열 안에서 문자열(대소문자 구분함!) 검색해서, 시작 주소 리턴                  return       value                 성공       찾은 문자열 시작주소                 실패       NULL              #include &lt;stdio.h&gt; #include &lt;string.h&gt;  int main(){ \tchar s1[30]=\"A Garden Diary\";  \tchar *ptr=strstr(s1, \"den\");  \tprintf(\"%s\\n\", ptr); \treturn 0; }   den Diary      while을 사용해 문자열을 계속 검색 가능   #include &lt;stdio.h&gt; #include &lt;string.h&gt;  int main(){ \tchar s1[1024]=\"A Garden Diary A Garden Diary A Garden Diary\";  \tchar *ptr=strstr(s1, \"den\");  \twhile(ptr!=NULL){ \t\tprintf(\"%s\\n\", ptr); \t\tptr=strstr(ptr+1, \"den\"); \t}   den Diary A Garden Diary A Garden Diary den Diary A Garden Diary den Diary   ","categories": ["stdio"],
        "tags": [],
        "url": "https://markyang920413.github.io//stdio/stdio_3-1/",
        "teaser": null
      },{
        "title": "stdio <3> 문자열 단위 입출력 fgets(), fputs(), puts(), fscanf(), fprintf(): Text mode",
        "excerpt":"Text mode vs Binary mode                  Text mode       Binary mode                       문자를 저장할때 사용       데이터를 저장할 때 사용                 “10” 저장 시, 파일에는 -&gt;ASCII-&gt; 0x31 0x30이 저장       10 저장 시, 파일에 0x0a가 저장                 fputc, fputs, fprintf fgetc, fgets, fscanf       fwrite, fread           리눅스에서 ‘줄’이란?     \\n   EOF   \\0, NULL   fgets():3   #include &lt;stdio.h&gt;  char *fgets(char *buf, int size, FILE *stream);  기능: 지정한 stream에서 한 줄(\\n, EOF, \\0 기준으로 컷)을 읽음  최대size-1만큼 읽어 마지막에 \\0을 추가하고, buf에 저장한다.    \\n도 저장                  return       value                       성공       *buf반환                 실패       NULL(하나도 읽지 못하고 EOF에 도달한 경우)                          parameter       Description                       *buf       stream으로 부터 읽어서 저장할 버퍼                 size       최대 size-1만큼 stream으로 부터 읽어들임  마지막 바이트엔 자동 \\0 추가한다.                 *stream       stream으로 부터 읽어들임           한 줄을 읽고 반환된건지, 지정 size만큼 읽고 반환한건지 모를 때,  ungetc를 사용한다.         주의!: getc()는 버퍼 오버플로문제 야기 사용 지양   fscanf():3   #include &lt;stdio.h&gt;  int fscanf(FILE *stream, const char *fmt, ...);  기능: scanf() + stream 지정                  return       value                       성공       입력받은 아이템 개수                 실패       EOF           fputs():3   #include &lt;stdio.h&gt;  int fputs(const char *buf, FILE *stream);  기능: buf 문자열(\\0, EOF 기준으로 컷, \\n은 컷x)을 *stream에 전송(쓰기) 끝에 \\n 추가 안함                     return       value                       성공       0이상의 숫자                 실패       EOF                          parameter       Description                       *buf       stream으로 한 줄 보낼 정보를 담고 있는 버퍼                 *stream       stream으로 부터 읽어들임              fprintf():3   #include &lt;stdio.h&gt;  int fprintf(FILE *stream, const char *fmt, ...);  기능: printf() + stream 지정                  return       value                       성공       write한 Byte수                 실패       음수           puts():3   #include &lt;stdio.h&gt;  int puts(const char *buf);  기능: buf 문자열(\\0, EOF 기준으로 컷, \\n은 컷x)을 *stream에 전송(쓰기) 끝에 \\n 추가 출력 스트림은 stdout으로 고정                     return       value                       성공       0이상의 숫자                 실패       EOF                          parameter       Description                       *buf       stream으로 한 줄 보낼 정보를 담고 있는 버퍼           ","categories": ["stdio"],
        "tags": [],
        "url": "https://markyang920413.github.io//stdio/stdio_3/",
        "teaser": null
      },{
        "title": "stdio <4> Binary 입출력 fread(), fwrite()",
        "excerpt":"Text mode vs Binary mode                  Text mode       Binary mode                       문자를 저장할때 사용       데이터를 저장할 때 사용                 “10” 저장 시, 파일에는 -&gt;ASCII-&gt; 0x31 0x30이 저장       10 저장 시, 파일에 0x0a가 저장                 fputc, fputs, fprintf fgetc, fgets, fscanf       fwrite, fread           리눅스에서 ‘줄’이란?     \\n   EOF   \\0, NULL   고정 길이 입출력 API가 필요한 이유     다른 stdio API와 함께 사용 할 수 있다.   stdio는 독자 버퍼를 가지고 있는데, 만약 시스템 콜인 read()와 write()와 stdio API를 함께 사용하게 되면 입출력 순서가 꼬인다.           이식성이 좋다. read(), write()는 UNIX system call이기 때문에 다른 OS에 없을 수 있으나, fread()나 fwrite()는 C언어 표준 함수이기 때문에 더 많은 환경에서 사용된다.       fread(), fwrite() 는 특히 structure 와 함께 잘 사용된다.            struct에서는 문자열 말고도 각종 자료형을 다루기 때문         typedef struct person{   char name[20];   int age; }PERSON;                           text형 API에서는 int형 age를 문자열로 저장해야함   fread, fwrite는 그대로 저장하기 때문에 문자열로 바꾸지 않아도 됨   주의점      구조체 패딩문제 조심            정적 캐스팅(static casting)으로 데이터를 읽어오거나 사용할 때 매우 중요한 문제           해결법            mmap       네트워크 소켓 사용시, XDR 규약(External Data Representation)을 지켜주는 것이 좋다.           fread():3   #include &lt;stdio.h&gt;  size_t fread(void *buf, size_t size, size_t nmemb, FILE *stream);  기능: *stream에서 최대 size x nmemb Byte의 데이터를 읽어서, *buf 에 쓴다.                  return       value                       성공       실제로 읽어 온 아이템 갯수(nmemb)                 실패       nmemb보다 적은 값  size x nmemb 읽기 전에 EOF를 만난 경우, errno set                          parameter       Description                       *buf       buf &lt;- stream                 size       size                 nmemb       nmemb                 *stream       지정된 stream에서 읽어올 것           fwrite():3   #include &lt;stdio.h&gt;  size_t fwrite(const void *buf, size_t size, size_t nmemb, FILE *stream);  기능: *buf에서 최대 size x nmemb Byte의 데이터를 읽어서, *stream 에 쓴다.                  return       value                       성공       실제로 출력된 아이템 갯수(nmemb)                 실패       nmemb 보다 적은 값, errno set                          parameter       Description                       *buf       buf -&gt; stream                 size       출력 아이템 하나 당 size                 nmemb       출력 아이템 갯수                 *stream       지정된 stream에 쓸 것           example    #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt;  typedef struct person{ \tchar name[20]; \tint age; }PERSON;  static int write_to_file(void){ \tFILE *fp=NULL; \tif(!(fp=fopen(\"persons\",\"w\"))){ \t\tperror(\"fopen error()\\n\"); \t\treturn -1; \t}  \tPERSON kim={\"kim\",20}; \tPERSON lee={\"lee\",30};  \tif(fwrite(&amp;kim,sizeof(PERSON),1,fp) != 1){ \t\t/* If return value is not equal to num of item, ERROR! */ \t\tperror(\"fwrite error\\n\"); \t\tgoto err; \t} \tif(fwrite(&amp;lee,sizeof(PERSON),1,fp) != 1){ \t\tperror(\"fwrite error\\n\"); \t\tgoto err; \t} \tfclose(fp);  \treturn 0;  err: \tif(fp!=NULL){ \t\tfclose(fp); \t} \treturn -1; }  static int read_from_file(void){ \tFILE *fp=NULL; \tPERSON persons[2]; \tmemset(persons,0x0,sizeof(PERSON)*2);  \tif(!(fp=fopen(\"persons\",\"r\"))){ \t\tperror(\"fopen error\\n\"); \t\treturn -1; \t}  \tif(fread(persons, sizeof(PERSON), 2, fp) != 2){ \t\tperror(\"fread error\\n\"); \t\tgoto err; \t}  \tfor(int i=0;i&lt;2;i++){ \t\tprintf(\"name: %s, age: %d\\n\", persons[i].name, persons[i].age); \t}  \treturn 0; err: \tif(fp!=NULL) \t\tfclose(fp); \treturn -1; }  int main(int argc, char *argv[]){ \tif(write_to_file()){ \t\tprintf(\"write fail\\n\"); \t\treturn -1; \t} \tif(read_from_file()){ \t\tprintf(\"read fail\\n\"); \t\treturn -1; \t} \treturn 0; }     ","categories": ["stdio"],
        "tags": [],
        "url": "https://markyang920413.github.io//stdio/stdio_4/",
        "teaser": null
      },{
        "title": "stdio <5> fseek(), fseeko(), ftell(), ftello(), rewind()",
        "excerpt":"fseek():3 fseeko():3   #include &lt;stdio.h&gt;  int fseek(FILE* stream, long offset, int whence); int fseeko(FILE* stream, off_t offset, int whence);  기능: stream의 파일 오프셋을 whence와 offset으로 나타내는 위치로 이동      fseeko()가 생긴 이유: 32bit 시스템 long은 2GB가 이동 한계            off_t는 기본적으로 long 타입       32bit 시스템: #define _FILE_OFFSET_BITS 64 선언 시,  32bit 컴퓨터에서도 off_t가 64bit 부호 정수형(long long)으로 정의되어 64bit 오프셋을 사용할 수 있게된다. 즉, #define _FILE_OFFSET_BITS 64 + fseeko()       64bit 시스템: fseeko()           그냥 64bit면 fseeko() 쓰자   lseek()과 똑같다.  파일 디스크립터 대신 파일 포인터를 사용하는 것 만 빼면!                  return       value                       성공       파일의 시작으로 부터 오프셋 위치                 실패       -1                          parameter       Description                       *stream       대상 파일 포인터 스트림                 offset       오프셋                 whence       모드                          whence       이동 위치                       SEEK_SET       파일의 처음을 기준으로 오프셋 계산 및 이동                 SEEK_CUR       파일의 현재 위치을 기준으로 오프셋 계산 및 이동                 SEEK_END       파일의 마지막을 기준으로 오프셋 계산 및 이동              ftell():3, ftello():3   #include &lt;stdio.h&gt;  long ftell(FILE *stream); off_t ftello(FILE *stream);  기능: stream의 파일 오프셋 값을 반환     32bit 시스템: #define _FILE_OFFSET_BITS 64 + ftello()   64bit 시스템:  ftello()   #include &lt;stdio.h&gt; #include &lt;string.h&gt;  int main(void){ \tFILE *fp; \tif(!(fp=fopen(\"datafile\",\"w\"))){ \t\tperror(\"fopen() fail\\n\"); \t\treturn -1; \t} \tprintf(\"after fopen(). offset: %ld\\n\", ftello(fp)); \tfputs(\"hello world!\\n\",fp); \tfputs(\"hello world!\\n\",fp); \tfputs(\"hello world!\\n\",fp); \tfputs(\"hello world!\\n\",fp); \tprintf(\"before fclose(), offset: %ld\\n\", ftello(fp));  \tfclose(fp); \treturn 0; }      rewind():3   #include &lt;stdio.h&gt;  void rewind(FILE *stream);  기능: stream의 파일 오프셋을 처음으로 되돌린다.  ","categories": ["stdio"],
        "tags": [],
        "url": "https://markyang920413.github.io//stdio/stdio_5/",
        "teaser": null
      },{
        "title": "stdio <6> FD <-> FILE 포인터",
        "excerpt":"fileno():3, fdopen():3     FILE*: FD+버퍼링 기능의 wrapper   #include &lt;stdio.h&gt;  int fileno(FILE *stream); // FILE* --&gt; FD FILE *fdopen(int fd, const char *mode);  fdopen: fd에다 지정한 mode대로 동작하는 FILE * 리턴 (fd -&gt; FILE *)                  return       value                 성공       FILE *                 실패       NULL           mode는 여기 참고   주의! 파일 디스크립터와 FILE 타입을 함께 사용하지 말자     FILE *는 stdio 독자 버퍼를 사용해서 입출력 순서가 의도치 않게 섞일 수 있다.      stdio API에서 지원하지 않는 system call 기능을 사용 할 때!      permission을 지정하고 싶을 때            open()으로 permission 지정 후 열고 fdopen()           ioctl(), fcntl() 사용하고 싶을 때   저수준과 고수준 파일 처리 혼용 예     fd0: open()으로 연 파일 디스크립터   fd1, fd2: dup(), dup2()를 이용해 복제된 파일 디스크립터   fp0: fdopen()으로 얻은 FILE *   4개 모두 같이 움직인다.     ","categories": ["stdio"],
        "tags": [],
        "url": "https://markyang920413.github.io//stdio/stdio_6/",
        "teaser": null
      },{
        "title": "stdio <7> 버퍼링 작업 fflush(), setvbuf()",
        "excerpt":"fflush():3   #include &lt;stdio.h&gt;  int fflush(FILE *stream);  기능: stream이 버퍼링하고 있는 내용을 즉시 write()                  return       value                       성공       0                 실패       EOF 에러 내용 errno set           문자열을 개행하지 않고 단말에 출력할 때 쓰인다.      fork, exec, posix_spawn 함수를 사용할 때, 기존 버퍼링된 데이터 순서 역전 우려 시, 미리 버퍼 비우는 것이 안전   fflush(stdin)            windows에선 비 표준임           setvbuf():3     stream은 곧바로 디바이스에 보내지 않고 stdio 버퍼에 일시 저장되었다가 특정 조건을 만족 시, 장치에 전송            비 버퍼링: 쓰자마자 곧바로 장치에 전달(모니터, 파일)       블럭 버퍼링(완전 버퍼링 fully buffered): 바로 장치에 가지 않고 설정된 블럭의 크기가 가득 찼을 경우 전달 (기본 모드)       라인 버퍼링: \\n 개행 문자를 만났을 때 장치로 전달, 일반적인 표준 입출력(터미널에서 쓰거나 읽을 떄)모드           #include &lt;stdio.h&gt;  void setbuf(FILE *stream, char *buf); void setbuffer(FILE *stream, char *buf, size_t size); void setlinebuf(FILE *stream); int setvbuf(FILE *stream, char *buf, int mode, size_t size);  기능: setvbuf는 mode를 이용해서 버퍼링 모드를 지정할 수 있고, size 로 버퍼 크기를 지정 가능     _IONBF: 비 버퍼링 모드   _IOFBF: 블럭 버퍼링 모드        _IOLBF: 라인 버퍼링 모드       사용 예     setvbuf(stdout, (char *)NULL, _IOLBF, 0);                 라인 버퍼링(_IOLBF) 지정           ","categories": ["stdio"],
        "tags": [],
        "url": "https://markyang920413.github.io//stdio/stdio_7/",
        "teaser": null
      },{
        "title": "lowlevel I/O <3> I/O readv(), writev()",
        "excerpt":"추후 예정  It may help to simplify code using recvmsg, sendmsg function in socket programming.  ","categories": ["file"],
        "tags": [],
        "url": "https://markyang920413.github.io//file/system_programming-file-lowlevel_IO_3_read_write_vector/",
        "teaser": null
      },{
        "title": "lowlevel I/O <4> I/O Multiplexing, select()",
        "excerpt":"입출력 다중화     입출력관련 함수들은 기본적으로 봉쇄/동기적으로 작동한다.      봉쇄            데이터를 처리하는 직관적인 방식       두 개 이상의 파일을 처리할 때 문제                    하나의 파일에서 봉쇄 -&gt; 다른 파일의 데이터는 영원히 읽지 못할 수도 있다.                              봉쇄/동기성 유지 + 두 개 이상 파일 처리 방법: 멀티 프로세스나 멀티 스레드를 이용한다.            파일 당 하나의 프로세스, 스레드할당해서 동시에 두 개 이상의 파일 처리           이 방식은 단순해 보이지만, 단일 프로세스/스레드 방식의 프로그램에 비해 다음과 같은 복잡한 프로그래밍 이슈가 있다.                    프로세스, 스레드간 통신: IPC를 이용해야 하는데, 이는 복잡하다.           동기화: IPC, mutex           프로세스와 스레드 생성: 프로세스 혹은 스레드 생성에는 자원 소모                              입출력 다중화: I/O Multiplexing     단일 프로세스가 여러 파일 제어할 수 있게 한다.     여러 파일은 fd 배열로 관리된다.              fd: 2, 4, 7에서 데이터 변화가 있음을 알 수 있다.           제한            fd table 크기                    1024, ulimit등으로 변경할 수 없다.                       배열 성능 문제                    배열 모든 필드 전수 검사                       병렬 처리가 아니다.                    멀티스레드와 같은 병렬 처리가 아니다.           IO 발생 -&gt; 그 fd 처리하는 동안 다른 파일은 대기해야한다.                           하지만 매우 견고한 모델이며, 프로그래밍이 단순해 널리 사용된다.   select(): I/O 다중화     입출력 관리하고자 하는 fd를 fd_set에 넣고 비트가 바뀌었는지 확인하는 방식   /* According to POSIX.1-2001, POSIX.1-2008 */ #include &lt;sys/select.h&gt;  /* According to earlier standards */ #include &lt;sys/time.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;  int select(int nfds, fd_set *readfds, fd_set *writefds, \t\t\t fd_set *exceptfds, struct timeval *timeout);                  return       value                 성공       데이터가 변경된 파일 개수: 주의:변경된 데이터의 목록이 아님. 따라서 1이상의 수가 반환 돠면 전수 검사해야함                          parameter       description                 nfds       관리하는 파일의 갯수, Max fd + 1                 *readfds       읽을 데이터가 있는지 검사하기 위한 파일 목록                 *writefds       쓰여진 데이터가 있는지 검사하기 위한 파일 목록                 *exceptfds       파일에 예외 사항들이 있는지 검사하기 위한 파일 목록                 *timeout       select함수는 fd_set에 등록된 파일들에 데이터 변경이 있는지 timeout동안 기다린다. timeout동안 변경이 없다면 0 반환 NULL: 무한정 기다림. 멤버 값이 모두 0이면 즉시 반환           struct fd_set: 관리하는 fd가 있는 비트 배열 구조체    ","categories": ["file"],
        "tags": [],
        "url": "https://markyang920413.github.io//file/system_programming-file-lowlevel_IO_4_select/",
        "teaser": null
      },{
        "title": "libc Regular Expressions API",
        "excerpt":"libc(The GNU C Library)의 정규 표현식 API   #include &lt;sys/types.h&gt; #include &lt;regex.h&gt;  int regcomp(regex_t *reg, const char *pattern, int cflags);  기능:  정규 표현식 문자열 *pattern으로 받아서, regex_t형식 문자열로 변환해 *reg에 기록한다. 즉, 정규식 패턴을 저장하는 것                  cflags option       Description                       REG_EXTENDED       셋O:정규 표현식을 interpreting할 때, POSIX Extended Regular Expression syntax를 사용한다. 셋X: POSIX basix Regular Expression syntax가 사용된다.                 REG_ICASE       Case insensitive                 REG_NOSUB       match position을 report하지 말 것.  nmatch와 pmatch 아규먼트는 무시된다.                 REG_NEWLINE       *을 새 라인에 매치하지 않는다. Non-matching 리스트 ([^…])를 새 라인에 매치하지 않는다. Match-beginning-of-line (^)가 eflags 여부에 상관 없이 새라인 이후, 즉시 빈 문자열을 매칭한다. Match-end-of-line ($)가 eflags NOTEOL포함 여부에 상관없이 새 라인 전에 즉시 빈 문자열을 매칭한다.                          return       value                       성공       0                 실패       에러코드 ==&gt; regerror()가 이 에러코드를 에러메시지로 변환           #include &lt;sys/types.h&gt; #include &lt;regex.h&gt;  void regfree(regex_t *reg);  기능: regcomp()에 의해 할당된 메모리 해제   #include &lt;sys/types.h&gt; #include &lt;regex.h&gt;  int regexec(const regex_t *reg, const char *string, \t\t\tsize_t nmatch, regmatch_t pmatch[], int flags);  기능: regcomp()에서 변환된 regex_t를 사용하여 실제로 문자열과 패턴을 조합하는 API                  return       value                       성공       0 : 받은 문자열 string이 패턴 reg에 적합하다.                 실패       REG_NOMATCH           #include &lt;sys/types.h&gt; #include &lt;regex.h&gt;  size_t regerror(int errcode, const regex_t *reg, \t\t\t\tchar *msgbuf, size_t msgbuf_size);     ","categories": ["env"],
        "tags": [],
        "url": "https://markyang920413.github.io//env/libc_regular_expressions/",
        "teaser": null
      },{
        "title": "option parsing: getopt(), getopt_long()",
        "excerpt":"옵션을 정의할 때의 관습        짧은 옵션(short option)            파라미터 X: ls -a -l -s                    묶을 수 있다: ls -als                       파라미터 O: head -n 5                    옵션과 파라미터를 붙이거나 뗄 수 있다: head -n 5, head -n5                           긴 옵션(long option)            파라미터 X: --version       파라미터 O: tail --lines 5, tail --lines=5                    ”=”를 붙이거나 뗄 수 있다: tail --lines 5, tail --lines=5                               ls -a -s -k와 같은 옵션            ls -a -s -k       ls -ask       ls --all --size --kibibytes           head -n 5와 같은 옵션            head -n 5       head -n5       head --line 5       head --line=5           getopt():3   #include &lt;unistd.h&gt;  int getopt(int argc, char * const argv[], const char *optdecl);  extern char *optarg; extern int optind, opterr, optopt;  기능: 짧은 옵션만 인식하는 UNIX API   getopt() 예제   #include &lt;unistd.h&gt;  extern char *optarg; extern int optind, opterr, optopt;  int main(int argc, char *argv[]){ \tint opt; \twhile ((opt=getopt(argc, argv, \"af:tx\"))!=-1){ \t\tswitch (opt){ \t\tcase 'a': \t\t\t/* code which process option '-a' */ \t\t\tbreak;  \t\tcase '?': \t\t\t/* when wrong option is passed */ \t\t\tbreak; \t\t} \t} }      getopt()는 항상 루프 사용            getopt()는 호출될 때마다 인자로 넘겨진 다음 옵션 문자를 반환       잘못된 옵션의 경우 ? 반환       모든 옵션 반환 시, -1 반환                    따라서 while문으로 -1 조건                           세 번째 인자에 파라미터 및 옵션을 지정한다.            파라미터 X 옵션: -a, -t, -x =&gt; “atx” (순서 상관 X)       파라미터 O 옵션: 옵션뒤에 콜론(:) -f 5 =&gt; “f:”                    “af:tx” (순서 상관 X)           전역 변수 ‘char *optarg’를 통해 파라미터 값 얻음                           getopt() 관련 전역 변수                  형태       명칭       의미                       char*       optarg       현재 처리 중인 옵션의 파라미터                 int       optind       현재 처리 중인 옵션 index(argc + 1 값임을 주의!)                 int       optopt       현재 처리 중인 옵션 문자                 int       opterr       이 값이 ‘참’이면 getopt()가 에러 메시지를 표시             파라미터가 없는 옵션의 경우 optarg는 NULL         파라미터가 있는 경우 optarg는 parameter가 잘 먹힘                주의! --를 만나면 -1을 반환하여 while文 탈출 - 옵션은 다음 옵션으로 넘어간다.   getopt_long():3  '--'의 긴 옵션을 위한 함수 getopt_long()  주의! getopt_long()은 리눅스가 아닌 OS에서는 사용할 수 없다고 보면 된다.   #include &lt;stdio.h&gt;  #define _GNU_SOURCE #include &lt;getopt.h&gt;  int getopt_long(int argc, char * const argv[], \t\tconst char *optdecl, const struct option *longoptdecl, \t\tint *longindex);  struct option{ \tconst char *name; \tint has_arg; \tint *flags; \tint val; };  extern char *optarg; extern int optind, opterr, optopt;      3번째 인자까지는 getopt()와 같음   네 번째 인자 struct option 구조체 배열을 사용해 롱 옵션 지정 이 배열 마지막에는 모든 멤버 0                  멤버 이름       형태       값과 의미                       name       char*       롱 옵션의 이름. lines, help 등                 has_arg       int       no_argument(또는 0): 파라미터 취하지 않음 required_argument(또는 1): 반드시 파라미터를 취함 optional_argument(또는 2): 파라미터를 취할 수도 있음                 flags       int*       NULL: getopt_long()은 val의 값을 반환 NULL 이외: getopt_long()은 0을 반환하고 *flags에 val의 값을 대입                 val       int       flag의 값에 따라 지정한 곳에 반환할 값           이중 flags와 val은 함께 사용해야 하는데, 아래를 참고하자                  의도       name값       has_arg값       flags 값       val 값                       --help 옵션을 발견했을 때 getopt_long()가 ‘h’를 반환하게 하고 싶다. 즉, 긴 옵션 --help를 -h에 대응 시키려함       \"--help\"       no_argument       NULL       ‘h’                 --lines는 -n에 대응 시킴       \"--lines\"       required_argument       NULL       ‘n’                 --all 옵션이 나타나면, 변수 opt_all의 값이 1이된다.       \"--all\"       no_argument       &amp;opt_all       1           getopt_long()의 다섯 번째 인자가 NULL이 아닌 경우에는 발견한 롱 옵션의 인덱스를 적재한다. 이 인덱스를 통해 현재 처리 중인 옵션에 해당하는 struct option을 얻는다.   getop_long() 예제   #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;  #define _GNU_SOURCE #include &lt;getopt.h&gt;  static void do_head(FILE *f, long nlines);  #define DEFAULT_N_LINES 10  static struct option longopts[]={ \t{\"lines\", required_argument, NULL, 'n'}, \t{\"help\",no_argument,NULL,'h'}, \t{0,0,0,0} };  int main(int argc,char *argv[]){ \tint opt; \tlong nlines=DEFAULT_N_LINES;  \twhile((opt=getopt_long(argc,argv,\"n:\",longopts,NULL))!=-1){ \t\tswitch (opt) { \t\tcase 'n': \t\t\tnlines=atol(optarg); \t\t\tbreak; \t\tcase 'h': \t\t\tfprintf(stdout, \"Usage: %s [-n LINES] [FILE ...]\\n\",argv[0]); \t\t\texit(0); \t\tcase '?': \t\t\tfprintf(stderr, \"Usage: %s [-n LINES] [FILE ...]\\n\",argv[0]); \t\t\texit(1); \t\t} \t} \tif(optind==argc){ \t\tdo_head(stdin,nlines); \t} else { \t\tint i;  \t\tfor(i=optind;i&lt;argc;i++){ \t\t\tFILE *f; \t\t\tf=fopen(argv[i],\"r\"); \t\t\tif(!f){ \t\t\t\tperror(argv[i]); \t\t\t\texit(1); \t\t\t} \t\t\tdo_head(f, nlines); \t\t\tfclose(f); \t\t} \t} \texit(0); }   ","categories": ["env"],
        "tags": [],
        "url": "https://markyang920413.github.io//env/system_programming-env-option_parse/",
        "teaser": null
      },{
        "title": "파일시스템 API <1> 디렉터리 관련 함수: opendir(), fdopendir(), readdir(), closedir(), scandir()",
        "excerpt":"디렉터리 내용 읽기  디렉터리 엔트리 리스트 API      디렉터리 또한 open(), read(), close()   디렉터리 내 파일 1개 정보 = 1개 구조체 = 디렉터리 엔트리   opendir():3    #include &lt;sys/types.h&gt; #include &lt;dirent.h&gt;  DIR *opendir(const char *path);     opendir()은 path로 지정한 디렉터리를 읽기 위해 open 후, DIR 타입 포인터반환   DIR 타입은 디렉터리를 읽어들이기 위한 스트림 관리 구조체   fdopendir():3    #include &lt;sys/types.h&gt; #include &lt;dirent.h&gt;  DIR *fdopendir(int fd);     opendir()과 비슷하지만, open fd가 참조하는 디렉터리에 대한 디렉터리 스트림을 반환한다.                  opendir(), fdopendir()  return       value                       성공       *DIR 타입 디렉터리 스트림                 실패       NULL errno set           readdir():3    #include &lt;sys/types.h&gt; #include &lt;dirent.h&gt;  struct dirent *readdir(DIR *d);     기능: 디렉터리 스트림 d로부터 엔트리를 하나씩 읽어 들여 struct dirent 타입으로 반환한다.                  return       value                       성공       struct dirent*                 실패       NULL              struct dirent의 내용은 OS마다 다르다.            리눅스에서는 적어도 엔트리의 이름에 해당하는 char *d_name이 있다.  d_name은 '\\0'을 마지막으로 담고 있는 문자열.           readdir()가 반환하는 포인터는 다시 호출했을 때 덮어 쓰이므로 주의해야한다.         struct dirent의 내용            printf(“%s”, d_name);           closedir():3    #include &lt;sys/types.h&gt; #include &lt;dirent.h&gt;  int closedir(DIR *d);     기능: 디렉터리 스트림 d를 닫는 함수                  return       value                       성공       0                 실패       -1           이외에도 fseek(), ftell()에 대응하는 seekdir()과 telldir()도 있다.   예제 1. ls 명령 구현   #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;dirent.h&gt;  static void do_ls(char *path);  int main(int argc, char *argv[]){ \tint i; \tif(argc&lt;2){ \t\tfprintf(stderr,\"%s: no arguments\\n\",argv[0]); \t\texit(1); \t} \tfor(i=1;i&lt;argc;i++){ \t\tdo_ls(argv[i]); \t} \texit(0); }  static void do_ls(char *path){ \tDIR *d; \tstruct dirent *ent;  \td=opendir(path); \tif(!d){ \t\tperror(path); \t\texit(1); \t} \twhile(ent=readdir(d)){ \t\tprintf(\"%s\\n\",ent-&gt;d_name); \t} \tclosedir(d); }   해당 디렉터리 재귀 검색   #include &lt;sys/stat.h&gt; #include &lt;stdlib.h&gt; #include &lt;dirent.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt;  // 파일의 크기를 저장하기 위한 변수 long int total_size=0;  // 디렉터리 들여쓰기를 위한 디렉터리 depth 레벌 저장용 int indent=0;  // 함수는 인자로 디렉터리 이름을 입력받는다. void dir_parser(char *wd){ \tstruct dirent **items; \tint nitems, i, j; \tstruct stat fstat; // struct stat은 파일의 메타정보 저장 구조체  \tchar per;  \t// 인자로 받은 디렉터리로 이동한다. \tif(chdir(wd)&lt;0){ \t\tperror(\"chdir \"); \t\texit(1); \t}  \t/* scandir 함수를이용해서 현재 디렉터리의 모든 파일과 디렉터리의 내용을 가져온다. */ \tnitems=scandir(\".\", &amp;items, NULL, alphasort);  \t/*  \t * 디렉터리(파일포함) 항목의 갯수만큼 루프를 돌리며 \t * 만약 해당 파일이 디렉터리일 경우 \t * dir_parser 함수를 재귀 호출 한다.  \t */ \tfor(i=0; i&lt;nitems; i++){ \t\t// 파일 상태를 저장하기 위한 구조체 \t\tstruct stat fstat;  \t\t// 현재 디렉터리, 이전 디렉터리는 무시한다. \t\tif((!strcmp(items[i]-&gt;d_name,\".\"))||(!strcmp(items[i]-&gt;d_name, \"..\"))){ \t\t\tcontinue; \t\t}  \t\t/*  \t\t * 파일의 상태를 얻어와서 fstat로 저장한다 \t\t * lstat은 해당파일이 심볼릭링크일 경우, 그 심볼릭링크를 전달 \t\t */ \t\tlstat(items[i]-&gt;d_name, &amp;fstat);  \t\t/* 디렉터리의 depth는 \"\\t\"를 통해서 이루어진다.  \t\t   해당 depth의 크기만큼 \"\\t\"를 반복해서 출력한다. */ \t\tfor(j=0; j&lt;indent; j++) \t\t\tprintf(\"\\t\"); \t\t// 파일이름(디렉터리) 이름과 크기를 출력하고, 총계를 내기 위해서 total_size에 더해준다. \t\tprintf(\"%s\\t%ld\\n\", items[i]-&gt;d_name, fstat.st_size); \t\ttotal_size += fstat.st_size;  \t\t/* \t\t * 만약 파일이 디렉터리라면, dir_parser를 재귀호출한다. \t\t * 그리고 디렉터리의 depth 레벨을 1 증가한다. \t\t */ \t\tif (S_ISDIR(fstat.st_mode)&amp;&amp;S_ISLNK(fstat.st_mode)){ \t\t\tindent++; \t\t\tdir_parser(items[i]-&gt;d_name); \t\t} \t} \t/* 디렉터리의 depth 레벨을 1감소시키고 하위 디렉터리로 이동한다. */ \tindent--; \tchdir(\"..\"); }  int main(int argc, char* argv[]){ \t//memset(direntry, 0x0, 255); \tdir_parser(argv[1]); \tprintf(\"size is %ld Byte\\n\", total_size);  \treturn 0; }     ","categories": ["file"],
        "tags": [],
        "url": "https://markyang920413.github.io//file/system_programming-file-filesystemAPI_1/",
        "teaser": null
      },{
        "title": "파일시스템 API <2> 디렉터리 관련 함수: mkdir(), rmdir()",
        "excerpt":"디렉터리 만들기  mkdir():2    #include &lt;sys/stat.h&gt; #include &lt;sys/types.h&gt;  int mkdir(const char *path, mode_t mode);     mkdir()은 path로 지정한 디렉터리를 만든다.                  return       value                       성공       0                 실패       -1 errno set                          parameter       Description                       *path       디렉터리를 만들 path                 mode       permission지정 지정된 권한이 그대로 되는 것은 아니고, 먼저 umask 값과 비트 연산이 이루어진다.              mkdir()은 다른 시스템 콜에비해 실패자주 한다. 원인은 아래와 같다.            ENOENT: 상위 디렉터리가 없다. ex) mkdir(“/usr/src/hello”,0)에서, /usr/src가 없는 경우       ENOTDIR: path로 지정한 상위 디렉터리가 디렉터리가 아니다. ex) mkdir(“/usr/src/hello”, 0)에서, /usr/src가 파일인 경우       EEXIST: path로 지정한 경로에 이미 파일이나 디렉터리가 존재한다. ex) mkdir(“/usr/src/hello”, 0)에서, /usr/src/hello가 이미 존재       EPERM: 상위 디렉터리에 대한 변경 권한이 없다. ex) mkdir(“/usr/src/hello”, 0)에서, /usr/src에 쓰기 권한이 없는 경우           umask     mkdir(), open()을 사용할 때 만들어질 파일의 권한을 지정할 수 있지만, 지정한 값이 그대로 사용되는 것은 아니다. umask를 사용해서 변경된 값이 사용된다.   umask는 프로세스의 속성 중 하나로, 가장 일반적인 값은 8진수 0228다.   open(), mkdir()에서 실제로 사용되는 권한은 ‘mode &amp; ~umask’로 계산된다.            ex) mode=0777, mask=0228 =&gt; 0755  　　　　111 111 111 =&gt; 111 111 111  　　　　000 010 010\t=&gt; 111 101 101  　　　　　　　　　　　111 101 101 &lt;= 실제 적용되는 권한            umask():2      umask 값은 시스템 콜 umask()로 변경할 수 있다.   #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt;  mode_t umask(mode_t mask);     umask()는 프로세스의 umask 값을 mask로 변경하고, 직전까지의 umask 값을 반환한다.                  return       value                       성공       직전까지 쓰던 umask 값                 실패       -                          parameter       Description                       mask       변경할 mask 값 입력           mkdir 예제   #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/stat.h&gt; #include &lt;sys/types.h&gt;  int main(int argc, char *argv[]){ \tint i; \tif(argc&lt;2){ \t\tfprintf(stderr,\"%s: no arguments\\n\",argv[0]); \t\texit(1); \t} \tfor(i=1;i&lt;argc;i++){ \t\tif(mkdir(argv[i],0777)&lt;0){  \t\t\tperror(argv[i]); \t\t\texit(1); \t\t} \t} \texit(0); }   디렉터리 삭제하기  rmdir():2    #include &lt;unistd.h&gt;  int rmdir(const char *path);     rmdir()은 path로 지정한 디렉터리를 삭제한다.   디렉터리는 반드시 비어 있어야한다.                  return       value                       성공       0                 실패       -1 errno set           rmdir 예제   #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt;  int main(int argc, char * argv[]){ \tint i; \tif(argc&lt;2){ \t\tfprintf(stderr, \"%s: no arguments\\n\", argv[0]); \t\texit(1); \t} \tfor(i=1;i&lt;argc;i++){ \t\tif(rmdir(argv[i])&lt;0){ \t\t\tperror(argv[i]); \t\t\texit(1); \t\t} \t} \texit(0); }   ","categories": ["file"],
        "tags": [],
        "url": "https://markyang920413.github.io//file/system_programming-file-filesystemAPI_2/",
        "teaser": null
      },{
        "title": "파일시스템 API <3> 링크 관련 함수: link(), symlink(), readlink(), unlink(), rename()",
        "excerpt":"하드 링크     리눅스에서는 하나의 파일에 두 개 이상의 이름 지정할 수 있다.   링크: 파일에 새로운 이름을 붙이는 것   $ echo 'This is file' &gt; a     a파일을 만들었다.             파일의 이름과 파일의 실체의 관계는 위와 같다.            파일 a의 실체에 새로운 이름 b를 붙여본다. (하드 링크)             ‘파일 a를 가리키는 하드 링크 b를 만든다’라고 한다.           $ ln a b              a의 내용을 바꾸면 b의 내용도 바뀐다. a와 b모두 같은 것을 가리키고 있기 때문이다.            파일에 부여된 이름의 개수는 ls -l을 사용하여 확인할 수 있다.       $ ls -l    #왼쪽 두 번째가 링크 카운터 -rw-r--r--\t2\taamine\tusers\t13 Nov 14 00:15 a -rw-r--r--\t2\taamine\tusers\t13 Nov 14 00:15 b         rm을 했을 때, 실체가 삭제되는 것 XX, 이름이 삭제되는 것임            링크 카운터가 0이 되면, 비로소 실체가 삭제           link():2      하드 링크를 작성하는 System Call   #include &lt;unistd.h&gt;  int link(const char *src, const char *dest);     link()는 src(원본) 지정한 파일에 dest 이름의 하드링크 만든다.                  return       value                       성공       0                 실패       -1 errno set              src와 dest는 동일한 파일 시스템上 이어야 한다.   src와 dest는 디렉터리 XX   하드 링크 예제    #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt;  int main(int argc, char *argv[]){ \tif(argc!=3){ \t\tfprintf(stderr, \"%s: wrong arguments\\n\", argv[0]); \t\texit(1); \t} \tif(link(argv[1], argv[2] &lt; 0)){ \t\tperror(argv[1]); \t\texit(1); \t} \texit(0); }  심볼릭 링크          하드 링크는 이름과 실체를 연결하는 구조 심볼릭 링크는 이름에 이름을 연결하는 구조이다.        심볼릭 링크는 대응하는 실체가 존재하지 않아도 된다.   파일 시스템의 경계를 뛰어넘어 별명을 붙일 수 있다.   디렉터리에도 별명을 붙일 수 있다.   symlink():2    #include &lt;unistd.h&gt;  int symlink(const char *src, const char *dest);     심볼릭 링크를 만드는 시스템 콜            *src(원본) *dest(심볼릭 링크)                          return       value                       성공       0                 실패       -1 errno set           readlink():2    #include &lt;unistd.h&gt;  int readlink(const char *path, char *buf, size_t bufsize);     심볼릭 링크가 가리키는 이름을 얻는다.                  return       value                       성공       buf에 포함된 바이트 수 반환                 실패       -1 errno set                          parameter       Description                       *path       심볼릭 링크 path                 *buf       심볼릭 링크 path가 가리키는 이름을 담는 버퍼 문자열 마지막에 ‘\\0’을 자동으로 추가 하지 않는점 주의!                 bufsize       최대 이만큼만 이름 저장한다.           심볼릭링크 예제    #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt;  int main(int argc, char *argv[]){ \tif(argc!=3){ \t\tfprintf(stderr, \"%s: wrong number of arguments\\n\", argv[0]); \t\texit(1); \t} \tif(symlink(argv[1], argv[2])&lt;0){ \t\tperror(argv[1]); \t\texit(1); \t} \texit(0); }   파일삭제     리눅스에서 파일 삭제란, 링크 카운터 == 0이 되면 삭제되는 것이다! 즉 ‘실체에 붙인 이름 개수를 줄인다’는 뜻   unlink():2    #include &lt;unistd.h&gt;  int unlink(const char *path);     기능: *path로 지정한 이름을 삭제한다.                  return       value                       성공       0                 실패       -1 errno set           주의!     unlink()로 디렉터리를 삭제할 수는 없다!!!(rmdir()사용할 것)   심볼릭 링크를 unlink()로 삭제하면, 심볼릭 링크만 삭제되고 심볼릭 링크가 기리키는 실체 파일은 삭제되지 않는다.   unlink()를 사용해 rm 명령어 만들기    #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt;  int main(int argc, char *argv[]){ \tint i; \tif(argc&lt;2){ \t\tfprintf(stderr, \"%s: no arguments\\n\", argv[0]); \t\texit(1); \t} \tfor(i=1;i&lt;argc;i++)){ \t\tif(unlink(argv[i]&lt;0){ \t\t\t\tperror(argv[i]); \t\t\t\texit(1); \t\t} \t} \texit(0); }   파일 이동     리눅스에서 파일을 이동한다 = 하드 링크만들고 이전 하드 링크 제거   $ mv a b  # 위 아래 같은 동작  $ ln a b $ rm a     하지만! 조금 차이점은 있다.  하드 링크의 특징은 아래와 같다.            다른 파일 시스템X =&gt; rename() X       디렉터리 X =&gt; mv는 가능           rename():2    #include &lt;stdio.h&gt;  int rename(const char *src, const char *dest);     기능: 파일 이동 API. src를 dest로 변경한다.                  return       value                       성공       0                 실패       -1 errno set              다른 파일 시스템X            src와 dest가 다른 파일 시스템이면, rename은 실패하고 EXDEV가 errno에 set           rename()을 이용한 mv 구현    #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt;  int main(int argc, char *argv[]){ \tif(argc!=3){ \t\tfprintf(stderr,\"%s: wrong arguments\\n\", argv[0]); \t\texit(1); \t} \tif (rename(argv[1]. argv[2]) &lt;0){ \t\tperror(argv[1]); \t\texit(1); \t} \texit(0); }   ","categories": ["file"],
        "tags": [],
        "url": "https://markyang920413.github.io//file/system_programming-file-filesystemAPI_3/",
        "teaser": null
      },{
        "title": "파일시스템 API <4> 파일 정보 획득, 변경 stat(), chmode(), chown(), utime()",
        "excerpt":"메타 정보 획득하기     파일 시스템內 메타 정보            파일의 종류, 크기, 권한, 소유자, 그룹, 작성 시각, 변경 시각, 액세스 시각           이 것들을 획득하는 시스템 콜이 stat(), lstat()   stat():2 fstat():2 lstat():2    #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;unistd.h&gt;  int stat(const char *path, struct stat *buf); int fstat(int fd, struct stat *buf); int lstat(const char *path, struct stat *buf);     기능            stat()은 path로 지정한 엔트리 정보를 취득해, buf에 써넣는다.       fstat()은 file이 fd로 주어진 것 제외하고는 stat()과 동일.       lstat()은 path가 심볼릭 링크이면, 그 심볼릭 링크 정보를 반환, buf에 써넣는다.           주의! file로 이끄는 *path내 모든 디렉터리 경로에 permission이 필요하다.                  return       value                       성공       0                 실패       -1 errno set              struct stat 멤버 설명                  타입       멤버 이름       설명                       dev_t       st_dev       디바이스 번호                 ino_t       st_ino       i 노드 번호                 mode_t       st_mode       파일 타입과 권한을 포함한 플래그                 nlink_t       st_nlink       링크 카운터                 uid_t       st_uid       소유 사용자 ID                 gid_t       st_gid       소유 그룹 ID                 dev_t       st_rdev       디바이스 파일의 종류를 나타내는 번호                 off_t       st_size       파일 크기(바이트 단위)                 bikesize_t       st_bikesize       파일 블록의 크기                 blkcnt_t       st_blocks       블록 수                 time_t       st_atim.tv_sec       최종 액세스 시각의 초 단위(예전에는 st_atime)                 long       st_atim.tv_nsec       최종 액세스 시각의 나노 초 단위                 time_t       st_mtim.tv_sec       최종 변경 시각의 초 단위(예전에는 st_mtime)                 long       st_mtim.tv_nsec       최종 변경 시각의 나노 초 단위                 time_t       st_ctim.tv_sec       메타 정보의 최종 변경 시각의 초 단위(옛날에는 st_ctime)                 long       st_ctim.tv_nsec       메타 정보의 최종 변경 시각의 나노 초 단위              멤버 타입 대부분 typedef로 정의 되어 있고, ssize_t처럼 정수 타입   간단한 예제   #include &lt;stdio.h&gt; #include &lt;fcntl.h&gt;  int main(void){ \tint fd; \tstruct stat sb; /* 1. stat을 저장할 버퍼 */  \tfd=open(\"person_info\", O_RDONLY); \tif(fd==-1){ \t\tperror(\"open() fail\\n); \t\treturn -1; \t}  \tif(fstat(fd,&amp;sb)==-1){ /* 2. stat() 사용. 내용은 sb에 저장 */ \t\tprintf(\"stat() fail\\n); \t\tclose(fp); \t\treturn -1; \t} }    큰 파일에 대한 대응과 long long 타입      32bit, 231=2GB 이상 표현하기 위해 라지 파일 서포트(large file support, LFS)   활성화 방법            #define _FILE_OFFSET_BITS 64 그러면, 32bit에서 off_t타입이 long long이 된다.           stat 명령어 만들기      시스템 콜 stat()을 사용하여 stat 명령어를 만들어 보자.   우리가 만들 stat 명령어는 다음과 같이 파일의 메타 정보를 출력한다.   $ ./stat memo.txt type\t100000 (file) mode\t644 dev\t39 ino\t1236092 rdev\t0 nlink\t1 uid\t1001 gid\t1001 size\t1597 blksize\t4096 blocks\t0 atime\tFri Aug 25 00:01:00 2017 mtime\tFri Aug 25 00:01:00 2017 ctime\tFri Aug 25 00:01:00 2017  stat.c   #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;time.h&gt;  static char *filetype(mode_t mode);  int main(int argc, char * argv[]){ \tstruct stat st; \tif(argc!=2){ \t\tfprintf(stderr,\"wrong argument\\n\"); \t\texit(1); \t} \tif(lstat(argv[1], &amp;st)&lt;0){ \t\tperror(argv[1]); \t\texit(1); \t} \tprintf(\"type\\t%o (%s)\\n\", (st.st_mode &amp; S_IFMT), filetype(st.st_mode)); \tprintf(\"mode\\t%o\\n\", st.st_mode &amp; -S_IFMT); \tprintf(\"dev\\t%llu\\n\", (unsigned long long)st.st_dev); \tprintf(\"ino\\t%lu\\n\", (unsigned long)st.st_ino); \tprintf(\"rdev\\t%llu\\n\", (unsigned long long)st.st_rdev); \tprintf(\"nlink\\t%lu\\n\", (unsigned long)st.st_nlink); \tprintf(\"uid\\t%d\\n\", st.st_uid); \tprintf(\"gid\\t%d\\n\", st.st_gid); \tprintf(\"size\\t%ld\\n\", st.st_size); \tprintf(\"blksize\\t%lu\\n\", (unsigned long)st.st_blksize); \tpirntf(\"blocks\\t%lu\\n\", (unsigned long)st.st_blocks); \tprintf(\"atime\\t%s\", ctime(&amp;st.st_atime)); \tprintf(\"mtime\\t%s\", ctime(&amp;st.st_mtime)); \tprintf(\"ctime\\t%s\", ctime(&amp;st.st_ctime)); \texit(0); }  static char* filetype(mode_t mode){ \tif (S_ISREG(mode)) return \"file\"; \tif (S_ISDIR(mode)) return \"directory\"; \tif (S_ISCHR(mode)) return \"chardev\"; \tif (S_ISBLK(mode)) return \"blockdev\"; \tif (S_ISFIFO(mode)) return \"fifo\"; \tif (S_ISLNK(mode)) return \"symlink\"; \tif (S_ISSOCK(mode)) return \"socket\"; \treturn \"unknown\"; }   보는 바와 같이 struct stat에 필요한 정보가 다 있다.  주의!     심볼릭 링크의 경우, 심볼릭 링크 자신의 정보를 취하는 것이 적절하므로 stat()대신 lstat()사용   st_mode 멤버에서 파일 유형을 꺼내기 위해 S_IFMT와 비트 마스크 사용   S_ISREG() 등의 매크로 사용      파일 판정 매크로 목록                  매크로 이름       효과                       S_ISREG       보통 파일이라면 0이 아닌 값                 S_ISDIR       디렉터리라면 0이 아닌 값                 S_ISLNK       심볼릭 링크라면 0이 아닌 값                 S_ISCHR       캐릭터 디바이스라면 0이 아닌 값                 S_ISBLK       블록 디바이스라면 0이 아닌 값                 S_ISFIFO       named pipe(FIFO)라면 0이 아닌 값                 S_ISSOCK       유닉스 소켓이라면 0이 아닌 값           메타 정보 변경   메타 정보를 변경하는 시스템 콜                  변경 대상       사용하는 시스템 콜                       권한       chmod():2                 오너와 그룹       chown():2                 최종 액세스 시각과 최종 갱신 시각       utime():2           chmode():2    #include &lt;sys/stat.h&gt;  int chmod(const char *path, mode_t mode);     chmode()는 path로 지정한 파일의 모드를 mode로 바꾼다.                  return       value                       성공       0                 실패       -1 errno set              mode는 아래 상수나 값을 OR로 묶어 지정하거나, 0755같은 숫자를 사용한다.            C에서 0을 일부러 앞에 두면, 8진수이다.           permission 644: 0644, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH                  상수       값       의미                       S_IRUSR, S_IREAD       00400       소유한 사용자가 읽기 가능                 S_IWUSR, S_IWRITE       00200       소유한 사용자가 쓰기 가능                 S_IXUSR, S_IEXEC       00100       소유한 사용자가 실행 가능                 S_IRGRP       00040       소유한 사용자가 속한 그룹이 읽기 가능                 S_IXGRP       00010       소유한 사용자가 속한 그룹이 실행 가능                 S_IROTH       00004       그 외의 사용자가 읽기 가능                 S_IWOTH       00002       그 외의 사용자가 쓰기 가능                 S_IXOTH       00001       그 외의 사용자가 실행 가능           chown():2    #include &lt;unistd.h&gt;  int chown(const char *path, uid_t owner, gid_t group); int lchown(const char *path, uid_t owner, gid_t group);     chmown()은 path의 소유 사용자를 owner로 소유, 그룹을 group으로 변경한다. path가 심볼릭 링크인 경우, 그 심볼릭 링크가 가리키는 파일의 정보를 변경한다.            owner: 사용자 ID       group: 그룹 ID       이 中 하나만을 변경하는 경우, 변경하지 않는 쪽에 -1              lchown()은 path가 심볼릭 링크인 경우, 그 심볼릭 링크 자체의 정보를 변경한다.    주의!!   소유 사용자를 변경코자 하면, su 권한 필요   소유 그룹을 변경하는 경우, 해당 파일의 소유 사용자이며 자신이 포함된 그룹으로만 변경할 수 있다. (su 권한이면 임의의 그룹으로 변경가능)   utime():2    #include &lt;sys/types.h&gt; #include &lt;utime.h&gt;  int utime(const char *path, struct utimbuf *buf);  struct utimbuf{ \ttime_t actime;\t/* 최종 액세스 시각 */ \ttime_t modtime;\t/* 최종 갱신 시각 */ };     기능: utime()은 path로 지정한 파일의 최종 액세스 시각(st_atime) 최종 갱신 시각(st_mtime)을 변경한다. buf가 NULL이 아니면 buf의 내용에 따라 actime과 modtime이 설정된다. buf가 NULL이라면, 양쪽 모두 현재 시각으로 변경된다.                  return       value                       성공       0                 실패       -1 errno set                          parameter       Description                       *path       path로 지정한 파일의 최종 액세스 시각(st_atime, 최종 갱신 시각(st_mtime) 을 변경                 *buf       !NULL: buf의 내용에 따라 actime과 modtime이 설정 NULL: 양쪽 모두 현재 시각으로 변경           time_t는 추후에 자세히 기술   chmod 명령 작성 예제    #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/stat.h&gt;  int main(int argc, char *argv[]){ \tint mode; \tint i; \tif(argc&lt;2){ \t\tfprintf(stderr, \"no mode given\\n\"); \t\texit(1); \t} \tmode= strtol(argv[1], NULL, 8); \tfor(i=2; i&lt;argc; i++){ \t\tif(chmod(argv[i], mode) &lt; 0){ \t\t\tperror(argv[i]); \t\t} \t} \texit(0); }   ","categories": ["file"],
        "tags": [],
        "url": "https://markyang920413.github.io//file/system_programming-file-filesystemAPI_4/",
        "teaser": null
      },{
        "title": "메모리 API: cat proc, brek()",
        "excerpt":"주소 공간 들여보기(논리 주소)     프로세스 파일 시스템을 사용하면 특정 프로세스의 주소 공간 구성을 살펴 볼 수 있다.            PID가 n인 프로세스의 메모리 사용 구조를 보고 싶다.           $ cat /proc/n/maps   1. r-xp, mmap() mapped, [TEXT 영역] \t- 텍스트 영역은 한번 메모리에 올라온 뒤, 내용이 바뀔 필요가 없어서 w는 필요없고 실행 가능해야 하므로 x                  memory area       permission and properties       Description                       TEXT       r-xp + mmap으로 매핑된 파일 존재       한번 메모리에 올라온 후 내용이 바뀔 필요가 없으므로: w권한 無 실행 가능해야 하므로: x권한 有                 BSS       rw-p + mmap으로 매핑된 파일 존재       텍스트 영역 인접 전역 변수를 위해: w 권한有                 stack       rw-p       x86아키텍처 리눅스에서 스택은 논리 주소의 큰 번지수에 존재 스택은 보안 문제로 실행 불가: x권한 無                 heap               힙                 vdso, vsycall               리눅스 커널이 자동으로 매핑, 시스템 콜을 위한 보조 데이터를 위해 사용됨              메모리 관리 관련 API     C에서 메모리 확보하는 방법은 언제 어느 영역에 할당하는지에 따라 분류된다.      Compile time에 결정되는 크기 Static            할당 크기 앎, BSS영역 할당                    global 변수, 함수에 선언된 static 변수                       할당 크기 앎, 실행 시 Stack 할당                    local 변수                           Run time에 결정되는 크기 Dynamic            Dynamic 크기, Heap 할당                    malloc()                       Dynamic 크기, Stack 할당           brk():2       기능: malloc()은 내부에 brk(), sbrk() 시스템 콜 사용 　　 malloc() 크기 클경우, mmap()으로 메모리 얻는다.  ","categories": ["file"],
        "tags": [],
        "url": "https://markyang920413.github.io//file/memory_1/",
        "teaser": null
      },{
        "title": "함수 포인터",
        "excerpt":"함수 포인터     자주 사용되지만 헷갈리는 function pointer 아래의 선언을 살펴본다.            int *n: 포인터 변수 n은 int형(4Byte?) 메모리 주소를 가리킨다.       char *str: 포인터 변수 str은 char 타입을 담고 있는 메모리 주소를 가리킨다.       void (*f)(int): 포인터 변수 f는 .. 함수도 주소와 심볼을 가지고 call 하는 것이다!           #include &lt;stdio.h&gt;  int plus(int n){ \treturn n+1; }  int main(){ \tint (*f)(int); \tint result;  \tf = plus; /* match func pointer to function */ \tresult = f(5); \tprintf(\"%d\\n\",result); \texit(0); }      반환 type, 인풋 type 등을 맞추면 됨   char*와 char[　]의 차이     char *buf: buf 라는 포인터 변수만 선언   char buf[64]: 메모리 확보 + 포인터 변수 선언   ","categories": ["c"],
        "tags": [],
        "url": "https://markyang920413.github.io//c/func_pointer/",
        "teaser": null
      },{
        "title": "Signal <1> signal(), sigaction(), kill(), 시그널 블록",
        "excerpt":"시그널 특징     대기열을 가지지 않는다.            프로세스는 동시에 하나의 프로세스 처리           비 신뢰성            요청에 대한 응답이 전달되었는지 확인하는 쌍방향 통신과는 달리, 시그널은 프로세스에 제대로 전달되었는지 확인 x           자주 사용되는 시그널                  시그널명       포착 가능       디폴트 기능       생성 원인과 용도                       SIGALARM       O       -       비동기적인 사건 발생 알림                 SIGINT       O       종료       주로 ctrl+c로 생성 프로그램을 종료하고 싶을 때 사용                 SIGHUP       O       종료       User가 로그아웃할 때 생성됨. 데몬 프로세스에서는 설정 파일을 다시 읽어들이는 경우에 많이 사용                 SIGPIPE       O       종료       끊어진 파이프에 데이터를 쓰려고 시도하면 생성된다.                 SIGTERM       O       종료       프로세스를 종료 kill 명령어를 시그널지정 없이 사용할 때 전달됨                 SIGKILL       X       종료       프로세스 종료                 SIGCHLD       O       무시       자식 프로세스가 정지 또는 종료 시 발생됨                 SIGSEGV       O       코어 덤프       금지된 메모리 영역 액세스, 초기화 하지 않은 포인터, 버퍼 오버 플로우 등..                 SIGBUS       O       코어덤프       Alignment 위반, 포인터 작업을 잘못한 경우 등                 SIGFPE       O       코어 덤프       산술 연산 에러 Div zero, floating point overflow 등..              시그널 번호   $ kill -l  1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL  5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE  9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2 13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT 17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP 21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU 25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH 29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN 35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4 39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8 43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6 59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2 63) SIGRTMAX-1  64) SIGRTMAX  쉘에서 시그널 보내기      kill: sig_kill시그널을 보내는게 아님!   $ kill -[SIGNAL | SIGNO] [PID]  $ kill -SIGKILL 100\t\t# pid 100번 프로세스에 프로세스를 죽이는 시그널 보냄 $ kill -9 100\t\t# pid 100번 프로세스에 프로세스를 죽이는 시그널 보냄  시그널 short cut                   short cut       SIGNAL       Description                       Ctrl+C       SIGINT       프로세스를 종료하는 시그널 전송                 Ctrl+Z       SIGSTP       프로세스를 중단하는 시그널 전송                 Ctrl+\\       SIGQUIT       core dump를 남기고 프로세스 종료하는 시그널 전송           시그널 포착     시그널을 받은 프로세스는 어떻게 되는가?            따로 핸들러를 설정하지 않았다면, 디폴트 기능 수행       포착 가능한 시그널은 트랩하자!           포착: 트랩(trap), 캐치(catch)   포착 가능: 위 표에서 포착 가능하면, 그 시그널은 시그널이 전달될 때의 동작을 변경할 수 있다.            SIGCHLD는 디폴트로 무시되지만, 포착 가능 하므로 siganl(), sigaction()을 사용하여 수신 시 동작을 변경 가능           signal():2   주의! 시그널을 보내는게 아닌 트랩(포착)하는 API임!         시그널 번호 sig인 시그널을 받았을 때, 디폴트 동작할 것을 지정한 함수로 동작하게 한다.   지정한 함수를 시그널 핸들러라 칭함            함수를 넣어 시그널 핸들러로 사용케 하거나, 아래의 몇 매크로를 넣어 사용할 수도 있다.                          func 사용할 수 있는 매크로       의미                       SIG_DFL       디폴트 동작 수행해라                 SIG_IGN       이 시그널은 무시해라                          return       value                       성공       이전까지 사용되었던 시그널 핸들러 값                 실패       SIG_ERR errno set에 원인              SIG_DFL은 왜 필요할까?            최초 시그널을 모시했는데, 중간에 시그널을 기본행동으로 해야할 필요가 있을 때       자식 프로세스를 생성했을 때                    fork()사용 시, 자식 프로세스는 부모의 시그널 정책을 그대로 복사           그래서 자식이 시그널 정책을 바꿀 필요가 있을 때!!                           signal 예제: SIGHUP 구현      SIGHUP를 해당 pid에 주면,  해당 pid로 프로세스가 다시 시작되는 것을 볼 수 있다.   보통 대몬 프로세스의 설정을 마친 다음에 설정 내용 재 적용 시켜주기 위해서 자주 사용한다.   SIGHUP 시그널을 받으면, 프로세스를 해당 지점에서 종료하고, execl계열 시스템 콜 함수를 이용해서 프로세스를 다시 실행시킨다.         위 프로그램 빌드 후, 실행 시키고 kill 명령을 이용해서 SIGHUP를 발생시켜보자.   $ ps -aux | grep sig_hup root\t4209\t.... ./sig_hup $ kill -9 4209 # ./sig_hup 재 실행됨 $ kill -9 4209 # ./sig_hup 재 실행되지 않음     문제점: execl계열 함수를 이용하여 새로운 프로세스를 실행시킬 경우, 기존 프로세스의 자원 중 몇 가지가 새로운 프로세스로 전달된다. signal의 경우는 새로운 프로세스로 현재 상태가 전달되므로 시그널이 블럭 상태로 넘어가게된다.            즉, 시그널 콜은 프로세스 상태도 넘기므로(*이건 넘기면 안됨) 문제가되는 것       핸들러가 종료되지 않아서 시그널이 블럭된 상태라도, 블럭 해제되고 코드는 문제 없이 작동한다.           signal():2의 문제점      프로세스의 상태 고려 X 프로세스 상태를 고려하지 않고 언제라도 날라와 문제를 이르킴   핸들러 초기화 OS에 따라서 지정한 시그널 핸들러를 수행 후, 원래 디폴트로 돌리는경우가 있다. 그러면 한번 시그널 트랩 후, 다시 핸들러를 등록하거나 핸들러 동작 못한다.   시스템 콜 수행 중에 시그널 read()나 write() 시스템 콜을 수행 중에 시그널이 날라오면, 시스템 콜 수행을 보장할 수 없다.   중복 호출해서 안되는 함수를 중복 호출 어떤 함수를 실행 중 시그널 핸들러에 의해 해당 함수가 다시 호출될 수 있다. 함수 내에서 전역 변수를 사용하고 있다면 의도치 않은 문제를 이르킬 수 있다. C 표준 라이브러리에 이러한 함수가 많다.   시그널 블록 시그널 핸들러가 실행 중 또 시그널 핸들러가 발동되어 복수로 실행될 수 있다. 시스템에서는 이를 막고자 시그널 핸들러가 실행 중일 경우 같은 종류 시그널을 블록한다. 하지만 signal()에서는 블록 설정이 없다.   sigaction  sigaction ()       (sa_handler)나 (sa_sigaction) 중 하나를 시그널 핸들러로 사용하면 된다.   sigaction은 시그널을 객체로 다룰 수 있다.            시그널 set       시그널에 대한 정책       시그널 함수           struct sigaction을 이용해서 시그널 객체요소를 다룬다.   #include &lt;signal.h&gt;  int sigaction(int sig, const struct sigaction *act, struct sigaction *oldact);                  return       value                       성공       0                 실패       -1, errno set                          parameter       Description                       sig       어떤 시그널이 들어왔을 때 트랩시킬 것인가?                 *act       시그널 핸들러 지정 SIG_DFL*: 해당 시그널의 디폴트 동작 수행해라 SIG_IGN: 이 시그널이 들어오면 그냥 무시해라 *sigaction struct 포인터: 지정한 포인터로 핸들러 실행                 *oldact       sigaction()를 호출할 때 설정되어 있던 시그널 핸들러 기재된다. 불필요시 NULL 지정           sigaction 구조체    struct sigaction { \t/* sa_handler나 sa_sigaction 중 하나만 사용한다 */ \tvoid (*sa_handler)(int); \tvoid (*sa_sigaction)(int, siginfo_t*, void*); \tsigset_t sa_mask; \tint sa_flags; };                  struct sigaction 멤버       Description                       *sa_handler       SIG_DFL, SIG_IGN, 시그널 핸들링 함수 포인터 (이 함수는 아규먼트로 시그널 번호를 받는다.) *sa_handler나 *sa_sigaction 중 하나만 사용                 *sa_sigaction       기능이 더 많은 시그널 핸들링 함수 포인터 siginfo_t* 기능 등을 추가해서 더 자세한 정보를 얻을 수 있다.. man 2 sigaction page를 참고하자.                 sigset_t sa_mask       시그널 핸들러의 실행동안 블록되어야하는 시그널의 마스크를 지정한다. 트리거되는 핸들러는 SA_NODEFER 플래그가 사용되지 않으면, 블록될 것이다.                 sa_flags       SA_SIGINFO: sa_sigaction(siginfo_t*) 인자로 info 정보를 보낸다. SA_RESTART: 시스템 콜 재기동              signal에 비해 다른점            핸들러 유지                    sigaction()은 OS와 관련 없이 한번 설정한 시그널 핸들러가 계속 유지된다.                       시스템 콜의 재기동                    sa_flags 멤버에 플래그 SA_RESTART을 추가하면 시스템 콜을 재기동한다. 일반적으로 재기동하는 것이 편하다.                       시그널 블록                    sigset_t sa_mask에 블록할 시그널을 지정할 수 있다. 그러나 시그널 핸들러를 수행할 때는 처리 중인 시그널이 자동으로 블록되므로 대부분 이 멤버는 비워두면 된다. 비우기 위해서는 후술할 sigset_t API인 sigemptyset()을 사용하면 된다.                           sigaction 예제      1. sigaction 사용 예제    1-1. sigaction + sa_handler 사용         1-2. sa_sigaction (int ,siginfo_t* ,void *) 사용     sigset_t API    nclude &lt;signal.h&gt;  int sigemptyset(sigset_t *set);\t\t\"set을 빈 값으로 초기화한다.\" int sigfillset(sigset_t *set);\t\t\"set을 모든 시그널을 포함하는 상태로 한다.\" int sigaddset(sigset_t *set, int sig);\t\"set에 시그널(sig)을 추가한다.\" int sigdelset(sigset_t *set, int sig);\t\"set에 시그널(sig)를 제거한다.\" int sigismember(const sigset_t *set, int sig);\t\"set에 시그널(sig)가 포함되어 있으면 참 반환\"                  함수명       parameter       Description                 sigemptyset       sigset_t *set       *set을 빈 값으로 초기화한다. ex) sigemptyset(&amp;act.sa_mask)                 sigfillset       sigset_t *set       *set bit flag를 on한다. ex) 모든 시그널을 SIG_BLOCK하길 원한다면, 아래와 같이한다. sigset_t sigset, oldset; sigfillset (&amp;sigset); sigprocmask(SIG_BLOCK, &amp;sigset, &amp;oldset);                 sigaddset       sigset_t *set int signum       signum번호를 가지는 시그널을 set에 추가한다.                 sigdelset       sigset_t *set int signum       signum번호를 가지는 시그널을 set에서 지운다.                 sigmember       const sigset_t *set int signum       signum이 시그널 set에 포함되어 있는지 확인한다. ★★★sigpending과 함께 사용되면, 어떤 시그널에 대해서 블록되었는지를 알고 이에 대한 처리를 할 수 있다.★★★           시그널 블록      시그널 블록은 struct sigaction의 sa_mask 멤버를 사용하여 설정할 수 있다.   #include &lt;signal.h&gt;  int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); int sigpending(sigset_t *set); int sigsuspend(const sigset_t *mask);                  함수명       parameter       비고                 sigprocmask       int how const sigset_t *set sigset_t *oldset       시그널 마스크를 검사/변경 how값 　SIG_BLOCK: set에 포함되는 시그널을 시그널 마스크에 추가한다. 　SIG_UNBLOCK: set에 포함되는 시그널을 시그널 마스크에서 삭제한다. 　SIG_SETMASK: 시그널 마스크를 set으로 대체한다.                 sigpending       sigset_t *set       시그널이 블록된 상태에서 어떤 시그널이 발생해서 블록되었는지 알 수 있다.                 sigsuspend       const sigset_t *mask       해당 신호가 발생할 때 까지 프로세스를 중지           시그널 블록 예제 1. 블록된 시그널 검출      블록된 시그널을 검출      ==== # shell 1 ===== $ ./sig_block My PID 5389 0 1 2 ... 121 122 ==== # shell 2 ===== $ kill -SIGUSR1 5389 ==== # shell 1 ===== BLOCKED Signal: SIGUSR1   시그널 블록 예제 2.   #include &lt;signal.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt;  void sig_int(int signo); void sig_usr(int signo);  int main(){ \tint i=0; \tstruct sigaction intsig, usrsig;  \tprintf(\"PID : %d\\n\", getpid()); \t/* ====== SIGUSR2 시그널 처리 ======*/ \tusrsig.sa_handler=sig_usr; // 시그널 핸들러 등록 \tsigemptyset(&amp;usrsig.sa_mask); // 시그널 마스크 초기화 \tusrsig.sa_flags=0; \tif(sigaction(SIGUSR2, &amp;usrsig, 0) == -1){ \t\tprintf(\"signal(SIGUSR2 error\"); \t\treturn -1; \t} \t/* ============================== */  \t/* ====== SIGINT (CTRL+C) 시그널 처리 ======*/ \tusrsig.sa_handler=sig_int; // 시그널 핸들러 등록 \tsigemptyset(&amp;usrsig.sa_mask); // 시그널 마스크 초기화 \tusrsig.sa_flags=0; \tif(sigaction(SIGINT, &amp;usrsig, 0) == -1){ \t\tprintf(\"signal(SIGUSR2 error\"); \t\treturn -1; \t} \t/* ============================== */  \twhile(1){ \t\tprintf(\"%d\\n\",i); \t\ti++; \t\tsleep(1); \t} \treturn 0; }  void sig_int(int signo){ \tsigset_t sigset, oldset; \tsigemptyset(&amp;oldset);  \t// SIGUSR2와 SIGUSR1은 블럭된다 \t// 이들 시그널은 핸들러가 종료되면 전달된다. \tsigemptyset(&amp;sigset); \tsigaddset(&amp;sigset, SIGUSR2); \tsigaddset(&amp;sigset, SIGUSR1); \tif(sigprocmask(SIG_BLOCK, &amp;sigset, &amp;oldset)&lt;0) \t\tprintf(\"sigprocmask %d error\\n\", signo);  \t// SIGINT를 UNBLOCK한다. \t// 핸들러가 수행 중 이더라도 즉시 전달한다. \tsigemptyset(&amp;sigset); \tsigaddset(&amp;sigset, SIGINT); \tif(sigprocmask(SIG_UNBLOCK, &amp;sigset, &amp;oldset)&lt;0) \t\tprintf(\"sigprocmask %d error \\n\",signo);  \tprintf(\"sig_int\\n\"); \tsleep(5);  \treturn 0; }  void sig_usr(int signo){ \tprintf(\"sig_usr2\\n\"); }     SIGUSR1과 SIGUSR2 시그널 블럭 시켰다. 핸들러가 수행되는 5초 동안 이들 시그널이 도착하면, 시그널은 BLOCK된다. 그러다 시그널 핸들러가 종료하면, 전달된다.   SIGINT를 UNBLOCK로 한다. 시그널 핸들러가 수행되는 동안 동일한 시그널이 발생하면! 시그널은 BLOCK된다. SIGINT에 대해서 UNBLOCK을 했으므로 SIGINT가 도착하게 되면, 곧바로 시그널 전달되고, sig_int 시그널 핸들러가 수행   이 코드를 주석 처리한 다음에 SIGINT를 여러번 발생 시켜보면서 검사   SIGHUP 문제 해결      위 SIGHUP에서 execl계열 실행이 블록된 상태를 받는 문제를 해결한다. ```c #include  #include  #include    void sig_handler(int signo);   int main(){ \tint i=0; \tsigset_t newmask, oldmask;   printf(\"Program start\\n\");  if(signal(SIGHUP, (void*)sig_handler) == SIG_ERR){ \tperror(\"signal set error \"); \texit(0); }  sigemptyset(&amp;newmask); sigaddset(&amp;newmask, SIGHUP); if(sigprocmask(SIG_UNBLOCK, &amp;newmask, &amp;oldmask) &lt; 0){ \tperror(\"sigmask error: \"); \texit(0); }  while(1){ \tprintf(\"%d\\n\"); \ti++; \tsleep(1); }  return 1; }   void sig_handler(int signo){ \texecl(“./sig_hup2”, 0); }   - &lt;span style=\"color:magenta\"&gt;***sigemptyset***&lt;/span&gt;를 이용해 **newmaskset**을 비운다. - &lt;span style=\"color:magenta\"&gt;***sigaddset***&lt;/span&gt;을 이용해 여기에 &lt;span style=\"color:red\"&gt;**SIGHUP**&lt;/span&gt;추가 - &lt;span style=\"color:steelblue\"&gt;***sigprocmask***&lt;/span&gt;을 이용해서 **newmaskset**에 포함된 &lt;span style=\"color:red\"&gt;**SIGNAL**&lt;/span&gt;들에 대해 **블럭 해제** \t- **핸들러가 종료되지 않아**서 **시그널이 블럭된 상태**라도, **블럭 해제**되고 **코드는 문제 없이 작동**한다.   ## sigwait(): 시그널을 이용한 동기적 시그널 처리 ---  ```c #include &lt;signal.h&gt;  int sigwait(const sigset_t *set, int *sig);     sigwait()는 set에 등록된 시그널이 발생될 때까지 기다린다.   sigset_t 라는 데이터는 시그널에 대응되는 bit값 설정   sigaction에서 sigwait설명   시그널 전송  kill():2    #include &lt;sys/types.h&gt; #include &lt;signal.h&gt;  int kill(pid_t pid, int sig);     기능: PID가 pid인 프로세스에게 시그널 sig를 송신한다. 주의! 절때 kill명령을 내리는게 아님                  retrun       value                 성공       0                 실패       -1, errno set                          parameter       Desciption                       pid       시그널을 전송할 pid 명시 음수로 지정 시, -pid 인 프로세스 그룹 전체에 시그널 송신                 sig       시그널 번호              killpg(): 프로세스 그룹에 시그널 보냄   시그널 보내는 간단한 예제    #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;signal.h&gt; #include &lt;sys/types.h&gt;  int main(int argc, char *argv[]){ \tint pid; \tint sig_num;  \tif(argc!=3){ \t\tprintf(\"usage %s [pid] [signum]\\n\", argv[0]); \t\treturn 1; \t}  \tpid=atoi(argv[1]); \tsig_num=atoi(argv[2]); \tif(!kill(pid, sig_num)){ \t\tperror(\"Signal send error\\n\"); \t\treturn 1; \t} \treturn 0;   Ctrl + C      Ctrl + C가 시그널로 변환되어 프로세스에 전달되기 까지 과정      사용자가 Ctrl + C 누르면, 이것을 단말 드라이브가 파악            단말 드라이브는 모드에 따라 움직임이 다르다.                    셸 사용: cooked 모드로 특수한 기능을 하는 키가 존재한다. stty -a 명령을 쳐본다.  인터럽트: ^C 중지: ^Z 등이 지정                           SIGINT를 단말에서 동작 중인 프로세스에 전송   셸이 단말에게 너가 관리하는 프로세스는 이것 이것이다라고 가르쳐 줌            tcsetpgrp() API사용, ioctl()이 사용됨           단말은 파이프로 연결된 프로세스 그룹 전체에 신호를 전송한다.   SIGINT가 전송되면, 파이프 전체 프로세스가 종료된다.   물론 프로세스가 sigaction() 등으로 SIGINT를 시그널 핸들러 등록하고 있으면, 설정한 대로 동작한다.        셸이 파이프를 구성하는 프로세스 fork()   셸이 파이프의 프로세스 그룹 ID를 tcsetpgrp()로 단말에 통지한다.   fork된 각 프로세스가 각각의 명령어를 exec한다.   사용자가 Ctrl+C로 인터럽트 건다.   커널 내의 단말 드라이브가 그것을 SIGINT로 변환해 동작 중인 프로세스 그룹에 전송   프로세스 그룹이 시그널에 대한 기본 동작으로 종료된다.   ","categories": ["signal"],
        "tags": [],
        "url": "https://markyang920413.github.io//signal/system_programming-signal-signal_1/",
        "teaser": null
      },{
        "title": "소켓 프로그래밍 -1- 인터넷 구조, 호스트명, DNS, 도메인, getaddrinfo()",
        "excerpt":"인터넷 구조     네트워크 프로그래밍이라고 하면 전혀 다른 세계 같지만 그렇지 않다.            하나의 머신 안에서든, 네트워크를 넘어서든, 우리가 다루는 것은 결국 stream이다.       stream이라면 read(), write()를 통해 데이터를 R/W 가능 하므로, 결국 stream을 어떻게 얻느냐의 차이이다.           저수준 프로그래밍에서는 open()을 통해 fd를 얻어 stream을 얻었다.   네트워크 프로그래밍에서는 네트워크 너머의 컴퓨터 이름(IP, PORT)을 커널에 그 이름을 전달해 stream을 얻게된다.      인터넷에서 파일 시스템의 파일 이름에 대응하는 것이 IP주소와 포트 번호            IP주소: HOST       PORT: 각 서버 프로세스              프로토콜: 규약     패킷: IP레벨에서 스트림, 데이터 뭉치        실제로는 호스트가 패킷을 릴레이 처럼 보낸다. 자기꺼 아니면 Pass!   호스트명, DNS, 도메인     HOST는 IP주소로 구분 하지만, 사람이 다루기 어렵다.            따라서 호스트명(host name)을 사용한다.                    호스트명 예: www.naver.com                       etc/hosts에서 호스트명 &lt;-&gt; IP 관리           # /etc/hosts  127.0.0.1\tlocalhost ::1\t\tip6-localhost\tip6-loopback ...      하지만 호스트가 늘어날 때마다 모든 호스트를 /etc/hosts에 기록해야 하므로 현실적이지 않다.            현재는 회사나 가정 내 네트워크처럼 소수 호스트의 이름을 붙이기 위한 용도로 /etc/hosts가 사용된다.       컴퓨터 세계에서 이름으로 실체를 얻어내는 것을 resolve                    호스트 명과 IP주소를 교환해주는 존재를 resolve'r'라고 한다.           리눅스에서는 resolver로 libc가 있어, 해당 설정은 /etc/nsswitch.conf에 기술됨                           DNS(Domain Name System)            DNS는 호스트명을 도메인이라고 하는 영역에 나눠서 관리함으로써 호스트명의 관리를 전 세계에 분산시킴           도메인(Domain)            리눅스 디렉터리처럼 트리 구조로 관리       오른쪽 부터 루트 도메인!                    루트 도메인: 리눅스 루트 디렉터리 ‘/’ 처럼                            최상위 도메인(Top Level Domains, TLDs): com, org, kr                                    배치 .. 배치..                                                                               ex) 'www.example.com' 이라는 호스트 명은                    루트 도메인: ‘’                            최상위 도메인(Top Level Domains): .com                                    ‘example.com’* 도메인                                            www.example.com 호스트명                                                                                                                       각각의 도메인을 도메인 이름(Domain name)이라고 한다.       호스트를 루트 도메인에서 시작하여 전부 기술한 것을 FQDN(Fully Qualified Domain Name)이라고 한다.              ‘example.com’*처럼 호스트명에 대응되지 않는 도메인명도 있다.            이러한 도메인은 파일 시스템에서의 디렉터리처럼 관리를 위해 존재       즉, example.com 도메인은 com 도메인과 다른 관리자가 있어서, 그 밑의 도메인을 독자적으로 관리한다.                    ‘example.com’* 도메인이 관리하는 도메인                            www.example.com, mail.example.com, ftp.example.com                                   example.com 도메인 밑의 도메인은 example.com*도메인 관리자에게 물으면 알 수 있는 것이다.           www.example.com의 호스트 IP주소는 example.com 도메인* 관리자에게 물어보면 된다. 이때 물을 상대는 사람이 아니라 프로그램(서버 프로세스)이다. 이러한 서버를 DNS 서버라고 한다.                           example.com*의 DNS 서버를 어떻게 찾는가?            com 도메인의 DNS 서버에게 물으면 된다. 도메인은 트리 구조로 되어 있어, 밑의 도메인에 대해서는 그 위 도메인 관리 DNS 서버에게 문의하면 된다.           com 도메인 서버는 누구에게 물어야 하나?            루트 도메인의 DNS 서버에게 물으면된다. 루트 도메인의 DNS 서버의 IP주소는 모든 DNS 서버에 직접 등록되어 있어, 문의할 필요가 없다.           이렇게 DNS가 호스트명을 IP주소로 바꿔준다.   socket   #include &lt;sys/socket.h&gt;  int socket(int domain, int type, int protocol);     기능: 소켓 생성                  return       value                       성공       소켓 fd                 실패       -1           bind   #include &lt;sys/socket.h&gt;  int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);     기능: 소켓에 IP, PORT 부여                  return       value                       성공       0                 실패       -1           listen   #include &lt;sys/socket.h&gt;  int listen(int sockfd, int backlog);     기능: 소켓을 연결 대기 몇 개?와 연결 대기 상태로 만듬                  return       value                       성공       0                 실패       -1           accept   #include &lt;sys/socket.h&gt;  int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);     기능: 연결 요청 시, 수락                  return       value                       성공       0                 실패       -1           connect   #include &lt;sys/socket.h&gt;  int connect(int sockfd, struct sockaddr *serv_addr, socklent_t addrlen);     기능: 지정한 sockfd 소켓에 연결 요청                  return       value                       성공       0                 실패       -1           Host Name &lt;-&gt; IP 변환 API     getaddrinfo(): 호스트명, 서비스명으로부터 IP 주소, 포트 번호를 얻기 위해 사용   getnameinfo(): IP주소나 포트 번호로부터 도메인명이나 서비스명을 얻기 위해 사용한다.   freeaddrinfo(): 보조 API   gai_strerror(): 보조 API   getaddrinfo():3 호스트명, 서비스명으로 부터 IP 주소, 포트 번호를 얻음    #include &lt;sys/socket.h&gt; #include &lt;sys/types.h&gt; #include &lt;netdb.h&gt;  int getaddrinfo(const char *node, const char *service,  \t\tconst struct addrinfo *hints, struct addrinfo **res);  void freeaddrinfo(struct addrinfo *res);  const char *gai_strerror(int err);  struct addrinfo{ \tint\t\tai_flags; \tint\t\tai_family; \tint\t\tai_socktype; \tint\t\tai_protocol; \tsocklen_t\tai_addrlen; \tstruct sockaddr\t*ai_addr; \tchar\t\t*ai_canonname; \tstruct addrinfo\t*ai_next; };     기능: 접속 대상인 node의 주소 후보를 res에 기재한다. service와 hints로 범위를 좁힐 수 있다.  res는 struct addrinfo의 링크드 리스트 형태를 가진다.        struct addrinfo의 메모리 영역은 malloc()으로 할당되므로 명시적으로 해제해야한다.            freeaddrinfo()가 free용으로 사용된다.                          return       value                 성공       0                 실패       0 이상의 값의 에러코드 에러코드는 gai_strerror()로 문자열 변환 가능          ","categories": ["socket-programming"],
        "tags": [],
        "url": "https://markyang920413.github.io//socket-programming/socket_programming_1/",
        "teaser": null
      },{
        "title": "디렉터리 API getcwd(), chdir()",
        "excerpt":"디렉터리 API  getcwd():2 현재 디렉터리 얻기     cwd: current working directory   #include &lt;unistd.h&gt;  char *getcwd(char *buf, size_t bufsize);     기능: 실행 중인 프로세스의 현재 디렉터리를 buf에 써넣는다.                  return       value                 성공       *buf                 실패       NULL, errno set ERANGE: 현재 경로를 나타내는 문자열이 bufsize Byte보다 클 때                          parameter       Description                       *buf       현재 경로를 써넣을 버퍼 주소                 bufsize       버퍼의 사이즈 Byte           path를 위한 버퍼 확보      readlink()에서도 bufsize 정하는 것이 문제였다.   malloc() 후, 부족하면 realloc()으로 버퍼 사이즈를 키우는 편이 낫다.   #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt;  #define INIT_BUFSIZE 1024  char* my_getcwd(void){ \tchar *buf, *tmp; \tsize_t size = INIT_BUFSIZE;  \tbuf = malloc(size); \tif(!buf) return NULL; \tfor(;;){ \t\terrno=0; \t\tif (getcwd(buf,size)) \t\t\treturn buf; \t\tif (errno != ERANGE) break; \t\tsize *= 2;\t\t\t// 사이즈 2배 \t\ttmp=realloc(buf, size);\t\t// buf시작으로 size만큼 realloc -&gt; tmp에 \t\tif(!tmp) break;\t\t\t// tmp가 NULL이면 탈출 \t\tbuf=tmp;\t\t\t// buf를 tmp에 매칭 \t} \tfree(buf); \treturn NULL; }   chdir():2 현재 디렉터리 변경   #include &lt;unistd.h&gt;  int chdir(const char *path);     기능: 현재 프로세스의 현재 디렉터리를 인자로 지정한 path로 변경한다.                  return       value                 성공       0                 실패       -1, errno set           다른 프로세스의 현재 디렉터리 변경      API가 지원하는 것은 현재 프로세스만 바꿀 수 있다.   다만 심볼릭 링크 /proc/PID/cwd를 사용하는 방법이 있다.  ","categories": ["file"],
        "tags": [],
        "url": "https://markyang920413.github.io//file/system_programming-file-process_env_1/",
        "teaser": null
      },{
        "title": "환경 변수 API environ, getenv()",
        "excerpt":"환경 변수     환경 변수(environment variable)은 프로세스의 부모/자식 관계를 통해 전파되는 전역 변수같은 관계            항상 설정해 두고 싶은 값을 프로그램에게 전달       쉘에서는 env 명령을 이용하면 전부 출력됨           $ echo $HOME /home/pllpokko                  ENV       Description                       HOME       사용자의 홈 디렉터리                 PATH       실행파일을 찾는 경로                 LANG       프로그램 사용 시 기본 지원되는 언어                 PWD       사용자의 현재 작업하는 디렉터리                 TERM       로그인 터미널 타입                 SHELL       로그인해서 사용하는 쉘                 USER       사용자의 이름                 DISPLAY       X 디스플레이 이름                 VISUAL       visual 편집기의 이름                 EDITOR       기본 편집기의 이름                 COLUMNS       현재 터미널이나 윈도우 터미널의 컴럼 수                 PS1       명령 프롬프트 변수                 PS2       2차 명령 프롬프트. 명령 행에서 사용하여 명령 행을 연장 햇을 때 나타냄                 BASH       사용하는 bash 쉘의 경로                 BASH_VERSION       bash의 버전                 HISTFILE       history 파일의 경로                 HISTFILESIZE       history 파일의 크기                 HISTSIZE       history에 저장되는 갯수                 HISTCONTROL       중복되어지는 명령에 대한 기록 유무를 지정하는 변수                 HOSTNAME       호스트의 이름                 LINES       터미널의 라인 수                 LOGNAME       로그인 이름                 LS_COLORS       ls 명령의 색상 관련 옵션                 MAIL       메일을 보관하는 경로                 MAILCHECK       메일 확인 시간                 OSTYPE       운영체제 타입                 SHLVL       쉘의 레벨                 TERM       터미널 종류                 UID       사용자의 UID                 USERNAME       사용자 이름           envirion 환경 변수의 전역 변수     환경 변수는 전역 변수 char ** environ을 통해 액세스 할 수 있다.      printf(\"%s\\n\", envrion[0]);   #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;  extern char **environ;  int main(int argc, char *argv[]){ \tchar **p; \tfor(p=environ; *p; p++){ \t\tprintf(\"%s\\n\", *p); \t} \texit(0); }  주의! environ이 가리키는 주소는 putenv()로 이동할 수도 있으므로, 변수에 저장해 두고 나중에 접근해서는 안 된다.   getenv():3   #include &lt;stdlib.h&gt;  char *getenv(const char *name);     기능: 환경 변수인 *name의 값을 검색해 반환                  return       value                       성공       *name 값의 환경 변수를 반환                 실패       NULL(No-Match)                          parameter       Description                       *name       알고 싶은 환경 변수           주의! getenv()가 반환하는 문자열도  putenv()로 이동할 수도 있으므로, 값을 저장해 둔 채 반복해서 사용해서는 안 된다.   예제: $LANG을 읽어오는 간단한 프로그램    #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt;  int main(int argc, char *argv[]){ \tchar *value=NULL; \tvalue = getenv(\"LANG\"); \tprintf(\"$LANG is %s\\n\", value); \treturn 0; }      환경 변수는 프로그램이 실행 시, 스택 영역에 복사된다. C에서는 pointer를 이용해서 접근할 수 있도록 방법을 제시하고 있다.   환경 변수가 저장된 스택의 주소는 main 함수의 3번 째 인자를 통해서 가져올 수 있다.   #include &lt;stdio.h&gt;  int main(int argc, char **argv, char **env){ \twhile(*env != NULL){ \t\tprintf(\"%s\\n\", *env); \t\t*env++; \t} \treturn 0; }     환경 변수 전체 쉘에 띄운다.   setenv():3 환경 변수 값 설정      기능: setenv()를 이용시, 환경 변수 값 설정가능.            \"자신+자식\"에만 설정한 환경 변수가 유효           #include &lt;stdlib.h&gt;  int setenv(const char *name, const char *value, int overwrite);                  Parameter       Description                       *name       셋팅할 환경 변수 이름                 *value       환경 변수 값                 overwrite       환경 변수가 이미 존재할 경우 값을 덮어쓸 것인지 결정한다. 1: true 0: 덮어쓰지 않는다.           #include &lt;unistd.h&gt;  int main(){ \tsetenv(\"TEST\", \"YUNDREAM\", 1); \texecl(\"/bin/bash\", \"bash\", NULL); }   $ echo $TEST\t\t# 설정 전엔 없는 환경 변수  $ echo $SHLVL 2 $ ./setenv\t\t\t# execl(자식) $ echo $TEST\t\t# 환경변수 복사됨 YUNDREAM $ echo $SHLVL 3 $ exit exit $ echo $TEST  $ echo $SHLVL 2  ","categories": ["file"],
        "tags": [],
        "url": "https://markyang920413.github.io//file/system_programming-file-process_env_2/",
        "teaser": null
      },{
        "title": "자격 증명, 사용자와 그룹 API, EUID RUID EGID RGID",
        "excerpt":"자격 증명  set-uid 프로그램      인증: 프로세스 속성, 관리 주체는 커널   set-uid 프로그램: 명령어를 실행하는 사용자와 관계없이 특정 사용자의 권한으로 실행하고 싶은 경우가 있다.     passwd: 암호 변경            암호는 /etc/passwd, /etc/shadow에 저장되기 때문에 암호를 변경하려면 이 파일을 수정해야 한다.       모든 사람에게 Permission을 부여할 순 없다.              이러한 상황을 위해 존재하는 것이 파일 권한 set-uid bit이다.     특정 프로그램에 set-uid bit set 시, 실행한 사용자와 관계 없이 프로그램 파일의 소유자 권한으로 기동한다.     ls -l 명령으로 passwd를 살펴보자  $ ls -l /usr/bin/passwd -rwsr-xr-x\t1\troot\troot\t54256\tMay\t17\t08:37\t/usr/bin/passwd     'rwx'가 아닌 'rws' 로 되어 있다.            이는 set-uid bit set되었다는 뜻이다.                소유자는 root이기 때문에 passwd는 누가 시작해도 root 권한으로 실행된다.           set-uid프로그램으로 부터 기동된 프로세스에는 두 종류의 인증이 있다.            시작한 사용자: RUID 실제 사용자 ID(real user ID)       set-uid 프로그램 소유자: EUID 실효 사용자 ID(effective user ID)           주의!! setuid() 시스템 콜은 set-uid 프로그램과 관계 XX      set-gid bit: 그룹의 자동 상승 구조를 지시하는 권한 플래그            시작한 사용자 그룹: RGID 실제 그룹 ID(real group ID)       프로그램 소유자: EGID 실효 그룹 ID(effective group ID)           get{uid,euid,gid,egid}():2 현재 자격 증명 획득    #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt;  uid_t getuid(void);\t\"현재 프로세스의 실제 사용자 ID를 반환\" uid_t geteuid(void);\t\"현재 프로세스의 실효 사용자 ID를 반환\" gid_t getgid(void);\t\"현재 프로세스의 실제 그룹 ID를 반환\" gid_t getegid(void);\t\"현재 프로세스의 실효 그룹 ID를 반환\"   위 시스템 콜은 절대 실패하지 않는다.   getgroups():2 보조 그룹 ID 얻기   #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt;  int getgroups(int bufsize, gid_t *buf);     기능: 현재 프로세스의 보조 그룹 ID를 buf에 쓴다. 그러나 프로세스의 보조 그룹 ID가 bufsize로 지정한 개수보다 많으면, buf 에 아무 것도 쓰지 않고 오류반환한다.                  return       value                 성공       보조 그룹 ID 수(0 이상)                 실패       -1, errno set           set{uid,gid}(), initgroups():2 다른 자격 증명으로 이행하기      현재의 권한 버리고 새로운 자격 증명 이행: setuid(), setgid(), initgroups()   #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt;  int setuid(uid_t id); int setgid(gid_t id);     setuid(): 현재 프로세스의 실제 사용자 ID와 실효 사용자 ID를 id로 변경한다.   setgid(): 현재 프로세스의 실제 그룹 ID와 실효 그룹 ID를 id로 변경한다.   #define _BSD_SOURCE #include &lt;grp.h&gt; #include &lt;sys/types.h&gt;  int initgroups(const char *user, gid_t group);     /etc/group 등의 데이터베이스를 보고, user가 속한 보조 그룹을 현재 프로세스의 보조 그룹으로 설정   두 번째 아규먼트 group을 추가한다.   group은 일반적으로 사용자 그룹(primary group)을 보조 그룹에도 추가하기 위해 사용한다.   주의! 슈퍼 사용자가 아니면 성공 할 수 없음!                  return       value                 성공       0                 실패       -1, errno set           위의 API를 사용해 완전히 다른 사용자가 되게 하려면 다음의 순서를 따른다.     슈퍼 사용자(root)로서 프로그램을 시작한다.   원하는 사용자의 사용자명과 ID, 그룹 ID를 얻어 둔다.   setgid(변경할 그룹 ID)   initgroup(변경할 사용자명, 그룹 ID)   setuid(변경할 사용자 ID)   사용자와 그룹     사용자나 그룹에 대한 정보 취급은 커널이 관리 X   getpw{uid,nam}():3 사용자 정보 검색    #include &lt;pwd.h&gt; #include &lt;sys/types.h&gt;  struct passwd *getpwuid(uid_t id); struct passwd *getpwnam(const char *name);  struct passwd{ \tchar *pw_name;\t\t\"사용자 이름\" \tchar *pw_passwd;\t\"패스워드\" \tuid_t pw_uid;\t\t\"사용자 ID\" \tgid_t pw_gid;\t\t\"그룹 ID\" \tchar *pw_gecos;\t\t\"본명\" \tchar *pw_dir;\t\t\"홈 디렉터리\" \tchar *pw_shell;\t\t\"셸\" }     getpwuid(): 지정한 id로 사용자 정보 검색   getpwnam(): 지정한 이름로 사용자 정보 검색                  return       value                 성공       사용자 정보를 struct passwd 타입으로 반환                 실패       NULL, errno set           주의! 다시 getpw{uid,nam}()을 호출하면 덮어 쓰일 수 있음   getgr{gid,nam}():3 그룹 정보 검색    #include &lt;grp.h&gt; #include &lt;sys/types.h&gt;  struct group *getgrgid(gid_t id); struct group *getgrnam(const char *name);  struct group{ \tchar *gr_name;\t\t\"그룹명\" \tchar *gr_passwd;\t\"그룹 패스워드\" \tgid_t gr_gid;\t\t\"그룹 ID\" \tchar **gr_mem;\t\t\"그룹에 속하는 멤버(사용자명 리스트)\" };     getgrgid(): 지정한 id로 그룹 정보 검색   getgrnam(): 그룹 이름으로 그룹 정보 검색                  return       value                 성공       사용자 정보를 struct group 타입으로 반환                 실패       NULL, errno set           주의! 다시 getpw{uid,nam}()을 호출하면 덮어 쓰일 수 있음  ","categories": ["file"],
        "tags": [],
        "url": "https://markyang920413.github.io//file/system_programming-file-process_env_3/",
        "teaser": null
      },{
        "title": "SSH 설정, 공개키 설정, PORT 및 SSH 관리",
        "excerpt":"IP 셋팅     고정 IP할당(GUI)            IP: 143.248.111.111       Subnet Mask: 255.255.255.0       Gateway: 143.248.11.1       DNS: 143.248.1.177, 143.248.2.177  IP는 막 지어냄           만약 공유기 안쓰면 IP 그대로 연결하면 됨              IP설정에 고정 IP 넣기         바로 연결가능           IP를 공유기에 연결한 경우               이 경우 당연히 바로 접속X 포트 포워딩 설정해야함       그냥 꼽고 DHCP로 설정해보자       ifconfig    192.168.0.23으로 나오는데, 이것은 공유기가 준 동적 IP         공유기 설정 페이지 가자 DHCP로 받은 IP에 끝자리 1                    192.168.0.1   외부 IP 주소 확인   설정     NAT -&gt; 포트포워딩   4번외부포트 설정! 나중에 ssh로 접속할 포트 ssh -p8888 143.248.111.111 5번내부 포트는 22&lt;–ssh용 리눅스 포트                           최종   결국 외부 IP:포트 로 접속하면 됨 내부에선 공유기가준 IP로 인식   공개키 설정  공개키 어떻게 작동?        My Com에서 id_rsa.pub가 공개키            id_rsa.pub를 target에 보내 authorized_keys에 맨 밑줄에 넣는다.           그 후, 접속하면 자동으로 이제 서버.pub 공개키가 내 컴퓨터의 known_hosts에 넣음   이 후, 비번 없이 됨   HOST(Target) Server에서 먼저 할 일: ssh 설치, ssh 대몬, ssh restart      ssh 서버 설치     $ sudo apt install openssh-server $ sudo apt install ssh           sshd/ssh Daemon Process 실행     $ sudo service ssh start # 혹은 $ sudo systemctl start ssh                 ssh 서비스를 시작할 때마다 실행해야 하면 매우 빡친다.                 시스템이 ssh 연결을 받을 때마다 자동으로 sshd를 열어주고 실행하자          $ sudo systemctl enable ssh                       ssh restart         $ sudo service ssh restart # 혹은 $ sudo systemctl restart ssh                           공개키 만들기  공개키 만들기 Windows      만약 OpenSSH가 Windows에 안깔린 경우  Powershell을 관리자 권한으로 실행   Get-WindowsCapability -Online | ? Name -like 'OpenSSH*' # 입력 # This should return the following output:  Name  : OpenSSH.Client~~~~0.0.1.0 State : NotPresent Name  : OpenSSH.Server~~~~0.0.1.0 State : NotPresent  # 그런 다음 서버 및/또는 클라이언트 기능을 설치합니다.  # Install the OpenSSH Client Add-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0  # Install the OpenSSH Server Add-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0  # Both of these should return the following output:  Path          : Online        : True RestartNeeded : False     cmd창 켜서 공개키 경로로 가봄!!     C:\\Users\\UserID\\.ssh                위 경로에 ssh파일을 두는데 만약 아래 처럼, 이미 id_rsa파일 이있다면 공개키가 있는 거임        처음 만드는 경우 아래와 같이 한다.     공개키 Target에 전송 Windows      공개키를 target에 전송한다.            보낼 파일: C:\\User\\pllpo.ssh\\id_rsa.pub                    반드시 .pub파일을 보내야함                       scp 명령어로 보내자           $ scp [-P[PORT]] C:\\User\\pllpo\\.ssh\\id_rsa.pub HOST_ID@HOST_IP:[SAVE PATH]                      예) Target IP가 125.131.74.188, Target Port가 50622라면            $ scp -P50622 C:\\User\\pllpo\\.ssh\\id_rsa.pub pllpokko@125.131.74.188:~/tmp.pub                           그다음은 Target 공개키 셋팅 참고   공개키 만들기 Ubuntu      Ubuntu Client에서 공개키 만들기            먼저 있는지 체크  ~/.ssh/id_rsa.pub 가 있으면 이미 있는거       없다면 만들자!         $ ssh-keygen -t rsa -b 4096 $ 엔터 연타 $ ${HOME}/.ssh/id_rsa{,.pub} 로 생성됨                           공개키 Target에 전송 Ubuntu      공개키를 target에 전송한다.            보낼 파일: ${HOME}/.ssh/id_rsa.pub                    반드시 .pub파일을 보내야함                       scp 명령어로 보내자           $ scp [-P[PORT]] ${HOME}/.ssh/id_rsa.pub HOST_ID@HOST_IP:[SAVE PATH]                      예) Target IP가 125.131.74.188, Target Port가 50622라면            $ scp -P50622 ${HOME}/.ssh/id_rsa.pub pllpokko@125.131.74.188:~/tmp.pub                           그다음은 Target 공개키 셋팅 참고   TARGET에서 공개키 셋팅      Target host에 ssh 접속한다.     $ ssh -p 50622 pllpokko@125.131.74.188           아래와 같이 authorized_keys에 공개키를 셋팅한다.            참고로 보낸 공개키 위치와 파일명은 ~/tmp.pub이다.         $ mkdir -p ~/.ssh $ chmod 700 ~/.ssh $ cat ~/tmp.pub &gt;&gt; ~/.ssh/authorized_keys $ chmod 600 ~/.ssh/authorized_keys $ rm -f ~/tmp.pub                           공개키 오류  WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!        WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! 메시지로 ssh 접속이 안된다.   이유는 192.168.0.7이라는 IP로 기존에 접속한 적이 있는 서버와 RSA 공유키를 교환한 상태에서, 192.168.0.7이라는 서버가 바뀌었기 때문이다.            ex) 192.168.0.7 IP를 가진 라즈베리 파이에 꼽혀있는 LAN으로 SSH 접속을 하다가, 이 LAN을 다른 컴퓨터에 꽂아 같은 IP를 쓰게 된 상황           Man in the Middle Attack이라는 중간자 공격에 대해 경고한다.            즉, 기존에 서버가 알고 있는 정보를 찾아가 따라갔더니 전혀 다른 서버로 접속된 것이다.           이 경우 내가 잘못 관리한 것 이기 때문에 스푸핑 현상이다. 아래와 같은 명령어를 통해 초기화 시킨다.   # My computer $ ssh-keygen -R [상대 IP]  혹은 $ ${HOME}/.ssh/known_hosts 에서 상대IP 제거   hosts.deny error      target ssh에 접속이 hosts.deny error를 뱉으면서  안될 때, Target 컴퓨터를 직접 킨다.   다음 파일을 편집     $ sudo vim /etc/hosts.deny                 ssh restart 해야 적용 됨            ssh restart방법 여기 참고           TARGET ssh key 바뀌었을 때 error      내 컴퓨터에 .ssh/known_hosts에서 알고 있는 타겟의 isa가 바뀌어 isa.pub가 바뀜   아래 키워드 입력   # My Computer $ ssh-keygen -f ${HOME}/.ssh/known_hosts -R [상대 IP]  ex) $ ssh-keygen -f ${HOME}/.ssh/known_hosts -R 143.248.147.13   ssh 관리  ssh server 내부 PORT 바꾸기      ssh용 내부 Port는 22   /etc/ssh/sshd_config에서 ssh 서버 포트를 바꿀 수 있다.     line 13: Port 22           여기서 원하는 포트 번호를 바꾸고 저장하고 나가기            ssh용 내부 port번호는 22, 1024~65535 추천           sshd 대몬을 restart해야 적용된다.            ssh restart방법 여기 참고           사용중인 PORT 검색      프로세스 이름으로 검색   $ cat /etc/services | grep [PROCESS NAME]  ex) $ cat /etc/services | grep ssh ssh\t\t22/tcp\t\t\t# ssh Remote Login Protocol     특정 PORT 사용중? 인지 검색   $ ss -tulpn | grep 2222 $ netstat -tulpn | grep 2222     LISTEN 중인 port 전부 찾기   $ lsof -i -P -n | grep -i listen   ssh 잘 동작하는지 상태 체크   $ systemctl status sshd       잘 동작함   SSH로 원격 명령 내려보기     target에 root 로그인 허용 Target에 들어가서 아래와 같이 실행     $ sudo vi /etc/ssh/sshd_config                       저 곳을 주석 해제 한 후 ssh restart       타겟에서 원격으로 실행 시키고 싶은 커맨드를 client에서 배시 셸 스크립트로 만든다.                    command.sh를 만들고 아래와 같이 remote 실행 커맨드를 작성해보자                           #!/bin bash  LD_PRELOAD=\"/home/root/libHybridCL.so\" \\ /home/root/clExample 16 16 1024 1024  주의! 절대 경로를 줘야하며, server내의 쉘 파일을 열어 그안의  커맨드를 실행하는 것은 안됨     아래와 같은 커맨드로 Remote command를 실행한다. client에서 아래 커맨드 실행     $ ssh [-p PORT] [TARGET ID]@[TARGET IP] 'bash -s' &lt; [REMOTE COMMAND SCRIPT FILE]           우리가 만든 command.sh을 서버에 리모트 명령 실행 해보자.     $ ssh -p8022 root@143.248.147.22 'bash -s' &lt; command.sh           ","categories": ["linux-system"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-system/linux_linux-system_ssh-setting/",
        "teaser": null
      },{
        "title": "프로세스가 사용하는 리소스, 날짜, 시간, 로그인 기록 명령 및  API",
        "excerpt":"프로세스가 사용하는 리소스     프로세스가 동작하기 위해선 여러가지 리소스가 필요하다.            CPU, 메모리, 버스(디바이스 입출력) …           getrusage():2 리소스 사용량 get    #include &lt;sys/time.h&gt; #include &lt;sys/resource.h&gt;  int getrusage(int who, struct rusage *usage);     기능: 프로세스 리소스 사용량을 두 번째 인자 usage 에 기록한다.                  return       value                 성공       0                 실패       -1, errno set                          parameter       Description                       who       RUSAGE_SELF 현재 프로세스의 리소스 사용량 기록 RUSAGE_CHILDREN 자식 프로세스의 리소스 사용량 기록. 자식 프로세스는 ‘현재 프로세스에서 fork()한 모든 자식 프로세스 중에서 wait() 중인 것’                 *usage       who에서 선택한 설정을 기록하는 곳           man getrusage에는 struct rusage에 많은 멤버 필드가 있는데, 리눅스에서는 그중 일부에만 정확한 값이 기재된다.                  타입       멤버 이름       의미                       struct timeval       ru_utime       사용된 사용자 시간                 struct timeval       ru_stime       사용된 시스템 시간                 long       ru_maxrss       최대 RSS 크기(KB 단위)                 long       ru_majflt       메이저 폴트* 횟수                 long       ru_minflt       마이너 폴트** 횟수                 long       ru_inblock       블록 입력 오프레이션 횟수                 long       ru_oublock       블록 출력 오프레이션 횟수           메이저 폴트*: 물리 주소에 연결되지 않은 가상 주소에 접근한 결과 물리 페이지 할당이 일어난 횟수 + 저장소와의 입출력이 수반  마이너 폴트**: 물리 주소에 연결되지 않은 가상 주소에 접근한 결과 물리 페이지 할당이 일너난 횟수 + 저장소와의 입출력이 수반X   날짜와 시간     시스템 시간(System time): 프로세스를 위해 커널이 작업한 시간            ex) 시스템 콜           사용자 시간(User time): 프로세스가 스스로를 위해 소비한 시간     UNIX epoch: 1970년 1월 1일 0:00 AM UTC            이 시간을 저장하는 변수 타입이 time_t signed long이라 32bit           time():2    #include &lt;time.h&gt;  time_t time(time_t *tptr);     기능: UNIX epoch으로 부터 현재까지의 경과 초 수 반환 및 *tptr에도 같은 값 기록 　Sec 단위 밖에 안되는 점 주의!                  return       value                 성공       UNIX epoch으로 부터 현재까지의 경과 초 수 반환                 실패       NULL           gettimeofday():2    #include &lt;sys/time.h&gt;  int gettimeofday(struct timeval *tv, struct timezone *tz);  struct timeval{ \ttime_t tv_sec;\t\"초\" \tsuseconds_t tv_usec;\t\"마이크로 초(μSec 1x10^-6)\" }     기능: UNIX epoch으로 부터 현재까지 경과 시간을 첫 번째 인자 tv에 기록한다.            struct timeval의 tv_sec에는 초 단위 시간 기록       struct timeval의 tv_usec에는 마이크로 초(μ 1x10-6 1.0e-6)[sec] 단위 시간이 기록       예) 1234.987632 sec                    tv_sec: 1234           tv_usec: 987632 로 각각 기록됨                       두 번째 인자 *tz는 항상 NULL                          return       value                 성공       0                 실패       -1, errno set           실제 사용시 아래 처럼 함수로 만들어 사용하자   #include &lt;sys/time.h&gt; #include &lt;unistd.h&gt;  double timer(void){ \tstruct timeval Tvalue; \tstruct timezone dummy; \tgettimeofday(&amp;Tvalue, &amp;dummy); \tdouble etime = (double)Tvalue.tv_sec + 1.0e-6*((double)Tvalue.tv_usec); \treturn etime; }  int main(void){ \tdouble startTime = timer(); \tdouble endTime = timer();  \tprintf(\"%lf,lf,lf\",startTime,endTime,(endTime-startTime)); }   localtime(), gmtime():3      time_t 값을 년월일 표현으로 바꿔준다.   #include &lt;time.h&gt;  struct tm *localtime(const time_t *timep); struct tm *gmtime(const time_t *timep);     기능: time\\t(초 단위) 시간을 struct tm 타입으로 변환            localtime(): 시스템 로컬 시간대(한국에 있다면 KST, UTC+9)       gmtime(): 협정 세계시(UTC)                          return       value                 성공       struct tm 타입으로 변환                 실패       NULL, errno set           struct tm 타입은 각각 멤버가 연/월/일/시/분/초 로 가진다.   #include &lt;time.h&gt;  struct tm {    int tm_sec;    /* Seconds (0-60) */    int tm_min;    /* Minutes (0-59) */    int tm_hour;   /* Hours (0-23) */    int tm_mday;   /* Day of the month (1-31) */    int tm_mon;    /* Month (0-11) */    int tm_year;   /* Year - 1900 */    int tm_wday;   /* Day of the week (0-6, Sunday = 0) */    int tm_yday;   /* Day in the year (0-365, 1 Jan = 0) */    int tm_isdst;  /* Daylight saving time */ };   mktime():3 struct tm -&gt; time_t    #include &lt;time.h&gt;  time_t mktime(struct tm *tm);     기능: struct tm 타입 -&gt; time_t(초 단위)                  return       value                 성공       struct tm 타입 -&gt; time_t(초 단위)                 실패       -1           asctime(), ctime():3 time_t, struct tm 값 문자열 변환    #include &lt;time.h&gt;  char *asctime(const struct tm *tm); char *ctime(const time_t *timep);     기능: time_t나 struct tm 타입을 문자열로 변환            ex) “Sat Sep 25 00:43:37 2017\\n”           strftime():3    #include &lt;time.h&gt;  size_t strftime(char *buf, size_t bufsize, const char *fmt, const struct tm *tm);     기능: *tm 인자로 지정한 시간을 *fmt에 따라 포맷하고, *buf에 기록한다. 단, bufsize까지만 입력  　　 *fmt는 printf()와 비슷하게 구성하여, 출력하고 싶은 시간의 요소를 ['%'+1 문자]로 지정한다.                  return       value                 성공       buf에 써넣은 Byte 수                 실패       0           *fmt                  문자       로케일 의존       의미                       %a       O       요일 축약형(LC_TIME=C 일 때 Mon, Tue, Wed, Thu, Fri, Sat, Sun)                 %A       O       요일(LC_TIME=C 일 때 Monday, Tuesday, Wednesday, Thursday, Saturday, Sunday)                 %b       O       월 축약형(LC_TIME=C 일 때 Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec)                 %B       O       월(LC_TIME=C 일 때 January, February, March, April, May, Jun, July, August, September, October, November, December)                 %c       O       현재 로케일에서 가장 자연스러운 형식의 날짜와 시간                 %C               년의 백자리 이상                 %d               날짜, 두 자릿수를 맞춰 앞에 0을 넣음(01~31)                 %D               %m/%d/%y와 동일                 %e               날짜, 두 자릿수를 맞춰 앞에 스페이스를 넣음(\"1\"~31)                 %F               %Y-%m-%d와 동일                 %h       O       %b의 별명                 %H               24시간 단위 시간, 두 자릿수를 맞추기 위해 앞에 0을 넣음(01~23)                 %I               12시간 단위 시간, 두 자릿수를 맞추기 위해 앞에 0을 넣음(01~12)                 %i               1월 1일을 기점으로 한 일수. 세 자릿수를 맞추기 위해 앞에 0을 넣음(001~366)                 %k               24시간 단위 시간. 두 자릿수를 맞추기 위해 앞에 스페이스를 넣음(\"1\"~23)                 %l               12시간 단위 시간. 두 자릿수를 맞추기 위해 앞에 스페이스를 넣음(\"1\"~12)                 %m               월 숫자 표시(01~12)                 %M               분(00~59)                 %n               '\\n'                 %p       O       오전/오후 표기(LC_TIME=C에서는 “AM” 또는 “PM”)                 %P       O       오전/오후 표기(LC_TIME=C에서는 “am” 또는 “pm”)                 %r       O       오전/오후가 붙어 있는 시간(예: 01:15:41 AM)                 %R               24시간 표기의 시분. (HH:MM). %H:%M과 동일                 %s               유닉스 에폭 이후의 경과 초수                 %S               초. 두 자릿수를 맞춰 앞에 0을 넣음(00~61). 60과 61은 윤초                 %t               '\\t'                 %T               %H:%M:%S와 동일                 %u               요일을 나타내는 번호(1~7). 월요일이 1, 일요일이 7                 %W               요일을 나타내는 번호(0~6). 일요일이 0, 토요일이 6                 %x       O       연월일                 %X       O       시분초                 %y               연의 마지막 두 자리(00~99)                 %Y               연                 %z               메일 형식으로 표현한 UTC와 시차(-1200~+1200). 한국은 +0900                 %Z       O       타임존(LC_TIME=C일 때 GMT나 KST)                 %%               '%' 문자 자체           c, C, x X, y, Y는 %와 문자 사이에 ‘E’를 놓으면 로케일 의존의 다른 표기를 사용할 수 있다.  d, e, H, I, m, M, S, u, U, v, w, W, y는 %와 문자 사이에 ‘O’를 놓으면 숫자의 다른 표기를 출력한다.  예를 들면 아라비아 숫자가 로마 숫자나 한자 숫자가 되는 경우가 있을 수 있다.   시간 포맷에 대한 표준      ISO 8601이 범용적            2017년 8월 9일 오후 2시 45분 31초(KST)       2017-08-09T14:45:31+09:00           이러한 표기법은 다음과 같은 특징이 있다.     연도는 항상 네자리   월, 일, 시, 분, 초는 항상 0을 채움으로 두 자리   연월일의 구분 문자는 슬래시가 아니고 하이픈   날짜와 시간 사이는 'T'가 들어감   시는 항상 24시간제   UTC와의 시차를 ‘+09:00’과 같은 형식으로 추가   ISO 8601 포맷은 항상 연도가 네 자리이고 구분 기호과 규칙적이어서 사람이 읽기에도 쉽고, 프로그램에서 파싱하기에도 좋다.  strftime()으로 ISO 8601 포맷으로 시간을 출력할 때는 포맷 문자열 ‘%FT%T%z’를 사용하여 포맷한 후, 마지막 두 문자 앞에 ‘:’을 추가   시간 관련 API 정리      로그인     systemd 또는 init이 단말 수만큼 getty 명령어 가동   getty는 단말로부터 사용자 이름을 입력하는 것을 기다려, login 명령어를 시작   login 명령어가 사용자를 인증   셸 시작   1. systemd, getty     systemd참고, 그런데 systemd는 로그인을 기다리는 getty라는 프로그램을 시작하는 역할도 가지고 있다.      getty            단말을 open()하고 read()해서, 사용자가 사용자명을 입력하는 것을 기다린다.       사용자명이 입력되면 getty는 dup()를 사용하여 fd 0,1,2에 단말을 연결하고 새로운 프로그램 login을 exec한다.           2,3. 인증        login은 사용자 인증을 해야한다.   사용자 DB의 위치는 설정에 따라 달라진다.            일반적으로 /etc/passwd, 최근에는 /etc/shadow로 분리하는 섀도 패스워드(shadow password)       기업이나 대학에서는 여러 시스템 간 DB 공유 위해 NIS, LDAP 등 사용       통합하기 위해 getpwuid() API 있고, /etc/nsswitch.conf에 있다.              시스템별 커스터마이즈: 리눅스는 다양한 장소, 다양한 용도로 사용되므로 시스템별로 커스터마이즈 사항            패스워드 종류. 문자 수 제한, 암호화 방법       로그인할 수 있는 날짜나 시간의 제한       로그인할 수 있는 사용자 제한           전통적인 login 명령어는 위 항목들은 모두 /etc/login.defs에서 설정            단점: 로그인을 취급하는 다른 명령어, 예를 들어 telnet이나 ssh, ftp 등에 같은 설정 항목을 중복 입력해야 한다.           최근 PAM(Pluggable Authentication Module) 사용            PAM에는 사용자를 인증하는 PAM이라는 API가 있어, 명령어가 이것을 부르는 것만으로 인증이 진행된다.       PAM 시스템의 실체는 공유 라이브러리인데, 위와 같은 설정을 유연하게 하기 위해 동적 로드를 사용하고 있다.       동적 로드되는 라이브러리의 장소는 /lib/x86_64-linux-gnu/security(Ubuntu), /lib64/security(CentOS)                    즉, libc가 놓여있는 디렉터리 바로 밑의 security 디렉터리 안이다.                           4. 로그인 셸      인증 후, 셸을 exec하는 일만 남았다.   다소 특이한 것은, exec할 때 명령어 이름의 앞에 '-'를 붙여 시작하는 것이다.     execl(\"/bin/sh\", \"-sh\", ....);           시작한 셸을 로그인 셸라고 한다.            동작이 다소 느리다.           로그인 기록 w, last, lastlog 명령      리눅스에는 w나 last와 같이, 누가 어떤 단말로 로그인했는지 기록을 출력하는 명령어가 있다. 　다음은 w명령을 실행한 결과다. 현재 aamine 사용자가 로그인하고 있는 것을 알 수 있다.     $ w 17:25:12\tup\t7:35,\t2 users,\tload average: 0.03, 0.03, 0.00 USER\t\tTTY\tFROM\t\tLOGIN@\tIDLE\tJCPU\tPCPU\tWHAT aamine\t\tpts/18\t192.168.10.54\tWed00\t0.00s\t1.45s\t0.00s\tw           이런 로그인 기록은 login, systemd가 파일로 관리            w 명령은 현재 로그인된 사용자를 출력, /var/run/utmp에 위치       last 명령은 과거 로그인 정보, /var/log/wtmp       lastlog 명령어는 /var/log/lastlog 기록 보마           ","categories": ["file"],
        "tags": [],
        "url": "https://markyang920413.github.io//file/system_programming-file-process_env_4/",
        "teaser": null
      },{
        "title": "WWW와 HTTP",
        "excerpt":"HTTP 1.1     HTTP(HyperText Transfer Protocol): 브라우저가 서버로부터 HTML 문서나 이미지를 요청하고 받아들일 때 사용하는 프로토콜            HTTP서버는 HTML 문서, 이미지를 제공해주는 SW       유명한 http 서버로는 Apache, Nginx, IIS(microsoft)           현재는 차세대 HTTP로 HTTP/2가 등장   WWW       웹 브라우저(index.html)            웹 페이지는 HTML로 작성           위 페이지(index.html)의 코드는 아래와 같다.   &lt;!DOCTYPE html&gt; &lt;html lang=\"ja-JP\"&gt; &lt;head&gt; \t&lt;title&gt;Test Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Test Page&lt;/h1&gt; &lt;p&gt;&lt;a href=\"other.html\"&gt;Other Page&lt;/a&gt;&lt;/p&gt;\t# \"Other Page텍스트와 other.html에 하이퍼링크 연결 코드\" &lt;/body&gt; &lt;/html&gt;      이 페이지의 Other Page텍스트는 other.html에 하이퍼링크로 연결            href로 지정한 주소가 상대 URL(relative URL)로 표시되었으므로 서버(호스트), 포트, 디렉터리 경로는 현재 표시중인 페이지와 동일하다고 판단.       웹 브라우저는 index.html과 동일한 서버, 동일한 포트에 TCP 소켓을 연결하여 통신 시도                TCP 접속이 완료되면 HTTP 서버 프로세스와 HTTP 클라이언트 프로세스(웹 브라우저)의 사이에 스트림이 연결된다.        이 스트림을 통해 브라우저와 HTTP서버가 아래 코드처럼 정보 교환한다.            ‘→’ 서버로 부터 클라이언트로 보내는 데이터, ‘←’ 클라이언트로 부터 서버로 보내는 데이터              &lt;!DOCTYPE html&gt; &lt;html lang=\"ja-JP\"&gt; &lt;head&gt; \t&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; \t&lt;title&gt;Other Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Other Page&lt;/h1&gt; &lt;p&gt;또다른 페이지&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;        브라우저는 렌더링해서 위와같은 화면(other.html)을 표시한다.   이미지나 CSS 파일도 이와 같은 방식으로 획득하여 표시한다.   HTTP     위에서 WWW가 대략적 구조가 이해되었다면, HTTP의 내용을 좀더 자세히 살펴보자.    처음에 client가 쓰는 HTTP 요청   그다음 server가 쓰는 HTTP 응답   요청 -&gt; 응답의 반복이 HTTP   HTTP 요청   \"GET /ja/linuxprog/test/other.html HTTP/1.1\\r\\n\"\t# 1) \"Connection: close\\r\\n\"\t\t\t\t\t# 2) \"Accept: */*\\r\\n\" \"Host: i.loveruby.net\\r\\n\" \"\\r\\n\"     1) 요청라인(request line)            GET : 데이터가 필요하다.       /ja/linuxprog/test/other.html : 데이터의 경로       HTTP/1.1 : HTTP 1.1 버전이다.           2) HTTP 헤더 : 부가적인 정보, '항목명: 값'의 형태로 부가적인 정보가 기재            “Connection: close” : 응답 후 TCP 연결을 끊어달라       “Accpet: */*“ : 어떤 종류의 데이터라도 받겠다.       \"\\r\\n\" : 끝(개행문자 CR LF)           HTTP 응답   \"HTTP/1.1 200 OK\\r\\n\"\t\t\t\t\t# 1) \"Date: Fri, 11 Aug 2017 11:50:28 GMT\\r\\n\"\t\t# 2) \"Server: Apache/2.4.10 (Debian)\\r\\n\" \"Last-Modified: Fri, 11 Aug 2017 11:48:32 GMT\\r\\n\" \"ETag: \\\"a3-55678fde663c0\\\"\\r\\n\" \"Accept-Ranges: bytes\\r\\n\" \"Content-Length: 163\\r\\n\" \"Vary: Accept-Encoding\\r\\n\" \"Connection: close\\r\\n\" \"Content-Type: text/html\\r\\n\" \"\\r\\n\" (HTML)\t\t\t\t\t\t\t# 3)     1) 상태 라인: 응답의 결과            200 OK : 문제없이 내용을 반환할 수 있다.                    200 : 문제 없는 결과를 나타내는 상태 코드(status code)                            이외 상태코드 : ‘404 Not Found’(URL에 대응하는 데이터가 존재하지 않음), ‘403Forbidden’(액세스 권한 없음)                                   OK : 사람이 볼 수 있는 보너스 메시지                           2) HTTP 헤더 : 응답 자체에 관한 정보나 반환하려는 데이터에 관한 정보            “Date: Fri, 11 Aug 2017 11:50:28 GMT” : 응답을 반환하는 시간       “Content-Length: 163” : 반환하려는 데이터 길이가 163Byte       “\\r\\n” : 종료           3) 엔터티 본문, body : 반환하려는 데이터 자체가 전송   HTTP 정리      HTTP는 요청과 응답으로 구성                  HTTP 요청       HTTP 응답                       요청 라인       상태 라인                 HTTP 헤더       HTTP 헤더                 \\r\\n       \\r\\n                 엔터티본문       엔터티본문              HTTP 요청에서 GET요청 방식은 엔터티 본문을 필요로 하지 않지만, POST 요청 등에서는 엔터티 본문이 붙는다.   GET 요청 방식 이외            HEAD 요청: HTTP 헤더만 요구       POST 요청: 데이터 게시에 사용       PUT, DELETE …           HTTP 서버 개략  HTTP 서버의 목적      HTTP의 구조와 파일 시스템이 굉장히 닮음            URL: 파일 시스템에서의 경로       GET 명령: cat 명령어       HEAD 요청: stat():2       POST 요청: 명령어의 실행               http://www.example.com/path/to/file.html에 엑세스하면 www.example.com이라는 호스트에 있는 파일 '/ ..../path/to/file.html'에 접근한다.   '/ ..../' 이 붙는 이유?            서버의 모든 파일이 웹을 통해 공개되는 것은 곤란하다.       HTTP 서버의 역할은 HTTP 요청에 대응하는 파일을 문서 루트 밑에서 찾아서 반환하는 것이다.              구현 방침      네트워크 접속 부분 생략   표준 입력으로 HTTP 요청을 읽어들이고, 그 응답을 표준 출력으로 출력하는 것이다.   단말에서 HTTP 요청을 입력하면서 디버그 하기 좋다.   inetd를 사용하면, 네트워크에 연결할 수도 있다.   에러와 로그      에러 발생 시 함수 log_exit() 를 호출하고 종료한다.   /* log_exit() */  static void log_exit(char *fmt, ...){ \tva_list ap;  \tva_start(ap, fmt); \tvfprintf(stderr, fmt, ap); \tfputc('\\n', stderr); \tva_end(ap); \texit(1); }   메모리 관리      메모리 사용 시 malloc()을 사용하자.   /* xmalloc() */ static void* xmalloc(size_t sz){ \tvoid *p;  \tp=malloc(sz); \tif (!p) log_exit(\"failed to allocate memory\"); \treturn p; }   시그널 처리      네트워크 프로그램에서 소켓 연결은 언제든 갑자기 끊어질 수 있다.   소켓이 끊어지면, inetd에서 시작한 경우 시그널 SIGPIPE가 전달된다.   시그널을 포착해 exit()하자   /* install_signal_handlers() */  static void install_signal_handlers(void){ \ttrap_signal(SIGPIPE, signal_exit); }  static void trap_signal(int sig, sighandler_t handler){ \tstruct sigaction act; \tact.sa_handler = handler; \tsigemptyset(&amp;act.sa_mask); \tact.sa_flags = SA_RESTART; \tif (sigaction(sig, &amp;act, NULL &lt; 0) \t\tlog_exit(\"sigaction() failed: %s\", strerror(errno)); }  static void signal_exit(int sig){ \tlog_exit(\"exit by signal %d\", sig); }   서비스 개시까지  main()    int main(int argc, char *argv[]){ \tif(argc != 2){ \t\tfprintf(stderr, \"Usage: %s &lt;docroot&gt;\\n\", argv[0]); \t\texit(1); \t}  \tinstall_signal_handlers(); \tservice(stdin, stdout, argv[1]); \texit(0); }     하나의 실행 인자가 필요한데, 문서 루트의 경로이다.            경로가 디렉터리 여부 체크는 stat()참고           service()      HTTP의 동작 구조를 보여 준다.   static void service(FILE *in, FILE *out, char *docroot){ \tstruct HTTPRequest *req;  \treq=read_request(in); \trespond_to(req, out, docroot); \tfree_request(req); }     FILE *in: HTTP 요청 읽음   그 정보를 struct HTTP Request 구조체의 포인터에 저장하고 반환   respond_to(): HTTP 요청 req에 대한 응답을 두 번째 인자 out 스트림에 써넣는다. 이때 참고할 문서루트가 docroot 다.   ","categories": ["http"],
        "tags": [],
        "url": "https://markyang920413.github.io//http/http_1/",
        "teaser": null
      },{
        "title": "가변 인자",
        "excerpt":"가변 인자 사용하기     함수에서 가변 인자를 정의            고정 매개변수가 한 개 이상                    가변 인수 몇 개인지 지정해야함…                       고정 매개변수 뒤 ' … '를 붙여 매개변수의 개수가 정해지지 않았다는 표시 해줌       주의! '…' 뒤에는 다른 매개변수를 지정할 수 없음           foo(4, 10, 20, 30, 40); 사용  foo(int args, …)선언 이면 　　　args = 4 들어가고 나머지 값들은 … 부분에 들어간다.   #include &lt;stdio.h&gt; #include &lt;stdarg.h&gt;  void printNumbers(int dummy, int args, ...){ \tva_list ap;\t\t\t\t\t// 가변인자 담을 포인터  \tva_start(ap, args);\t\t\t\t// 포인터와 가변인자 갯수 지정 \tprintf(\"&lt;dummy: %d&gt; \",dummy); \tprintf(\"Num of variables: %d [ \", args); \tfor(int i=0; i&lt;args; i++)\t{ \t\tint num=va_arg(ap, int);\t\t// 포인터와 자료형크기를 넣어서 순방향 이동 \t\tprintf(\"%d \", num); \t} \tva_end(ap);\t\t\t\t\t// 가변인자 포인터 NULL \tprintf(\"]\\n\"); }  int main(){ \tprintNumbers(0, 1, 10); \tprintNumbers(0, 2, 10, 20); \tprintNumbers(0, 3, 10, 20, 30); \tprintNumbers(0, 4, 10, 20, 30, 40);  \treturn 0; }        va_list: 가변 인자 목록 포인터   va_start (포인터, 갯수): 가변 인자 포인터 설정         va_arg (포인터, 자료형): 가변 인자 포인터에서 '자료형' 크기만큼 하나의 인덱스 데이터가져옴.  　　　　　　　　　　　순방향 이동!!        va_end (포인터): 가변 인자 처리 끝난 후, 지정한 포인터를 NULL로 만듬   자료형이 다른 가변 인자 함수      자료형이 다르면 switch文을 사용하자.     고정 변수에, switch에서 case로 구분할 문자열 보냄   #include &lt;stdio.h&gt; #include &lt;stdarg.h&gt;    // va_list, va_start, va_arg, va_end가 정의된 헤더 파일  void printValues(char *types, ...)    // 가변 인자의 자료형을 받음, ...로 가변 인자 설정 {     va_list ap;    // 가변 인자 목록     int i = 0;      va_start(ap, types);        // types 문자열에서 문자 개수를 구해서 가변 인자 포인터 설정     while (types[i] != '\\0')    // 가변 인자 자료형이 없을 때까지 반복     {         switch (types[i])       // 가변 인자 자료형으로 분기         {         case 'i':                                // int형일 때             printf(\"%d \", va_arg(ap, int));      // int 크기만큼 값을 가져옴                                                  // ap를 int 크기만큼 순방향으로 이동             break;         case 'd':                                // double형일 때             printf(\"%f \", va_arg(ap, double));   // double 크기만큼 값을 가져옴                                                  // ap를 double 크기만큼 순방향으로 이동             break;         case 'c':                                // char형 문자일 때             printf(\"%c \", va_arg(ap, int));      // char 크기만큼 값을 가져옴                                                  // ap를 char 크기만큼 순방향으로 이동             break;         case 's':                                // char *형 문자열일 때             printf(\"%s \", va_arg(ap, char*));    // char * 크기만큼 값을 가져옴                                                  // ap를 char * 크기만큼 순방향으로 이동             break;         default:             break;         }         i++;     }     va_end(ap);    // 가변 인자 포인터를 NULL로 초기화      printf(\"\\n\");    // 줄바꿈 }  int main() {     printValues(\"i\", 10);                                       // 정수     printValues(\"ci\", 'a', 10);                                 // 문자, 정수     printValues(\"dci\", 1.234567, 'a', 10);                      // 실수, 문자, 정수     printValues(\"sicd\", \"Hello, world!\", 10, 'a', 1.234567);    // 문자열, 정수, 문자, 실수      return 0; }   주의!!: gcc에서는!!   va_arg(ap, 자료형);     char,bool -&gt; int   short -&gt; int   float -&gt; double   vfprintf():3 사용하기      switch는 너무 귀찮다면 vfprintf() 사용하자!  ","categories": ["c"],
        "tags": [],
        "url": "https://markyang920413.github.io//c/variable_argument/",
        "teaser": null
      },{
        "title": "컴파일 <3> CMake",
        "excerpt":"1. CMake 기본     CMakeLists.txt: CMake는 이  파일을 처리해 네이티브 빌드 시스템을 생성, 빌드 도구 사용해 SW를 실제로 컴파일            사용자가 작성할 파일           Makefile: 생성된 Makefile   CMakeCache.txt: 텍스트 기반 설정 파일. 해당 빌드 머신을 위해 자동으로 생성된 기본 설정이 저장되어 있다.        CMakeFiles/: 자동으로 생성된 프레임워크 파일들이 있다. 생성된 파일들은 메인 makefile에서 사용된다.          모든 명령은 스페이스로 argument 구분            command ( arg1 arg2 … )           스페이스바가 포함된 argument가 한 개 arg라면 \" \" 사용            command ( \"Helloˇworld\" )           command에 따라 어떤 argument가 쓰일지 결정       project: 빌드 이름, 사용할 언어   project(basic-syntax C)     빌드 시스템을 식별할 수 있는 고유한 이름            여기서 정의된 이름은 이클립스와 같은 프로젝트 이름이 필요한 네이티브 빌드 도구에서 그대로 사용       basic-syntax C: 사용할 프로그래밍 언어 지정           cmake_minimum_required: CMake 버전   cmake_minimum_required(VERSION 버전)   set: 변수 정의      변수 정의:　set(변수 값)   변수 사용:　${변수}   set_property: 속성 값 설정   set_property (SROURCE 소스 PROPERTY 속성 값)     소스 파일에 속성 값을 저장            설정된 속성은 파일 내용에 영향 X       속성 값은 다른 명령에서 접근 가능           set_property (SROURCE add.c PROPERTY Author Peter)            add.c 소스 파일의 Author 속성에 Peter 값 할당           get_property: 속성 값 얻기   get_property (할당할 변수 SROURCE 소스 PROPERTY 속성)     소스 파일에 속성 값을 가져와 할당할 변수에 저장   get_property (author_name SROURCE add.c PROPERTY Author)            add.c 소스 파일의 Author 속성의 값의 내용을 author_name 에 할당           add_executable: 실행 프로그램 생성     add_executable (실행파일 이름 src1 src2 src3 …)  \".c\", \".cpp\"는 붙여도 되고 안해도 됨       소스 파일들을 빌드해  실행파일 생성   add_executable (calculator add sub mult calc)            add.c sub.c mult.c calc.c 소스 파일을 이용해       실행파일 \"calculator\" 생성           example 1      현재 main.c print.h 소스 코드가 있고 간단하게 빌드하는 CMakeLists.txt만들어 본다.     cmake_minimum_required(VERSION 2.6)  set(author \"Dong-Hyeon Yang\")\t# author 변수에 \"Dong-Hyeon Yang\" 문자열 넣어봄  message(${author})\t\t# author 변수를 message 함수를 통해 변수 내용을 출력해봄 add_executable(main main)\t# 실행 파일 명: main \t\t\t\t# 소스 파일 명: main.c (.c 생략 가능)   $ cmake PATH     PATH에 CMakeLists.txt 파일의 위치 경로 지정   지정한 위치의 CMakeLists.txt를 읽어 현재 내 위치에 빌드      add_library: 라이브러리 생성     add_library (라이브러리 이름 [STATIC | SHARED | MODULE] src1 src2 src3 …)  \".c\", \".cpp\"는 붙여도 되고 안해도 됨       소스 파일들을 빌드해  라이브러리 생성   add_library (math STATIC add sub mul)            add.c sub.c mult.c 소스 파일을 이용해       STATIC 라이브러리(정적 라이브러리)       라이브러리 \"math\" 생성 =&gt; 결과물: libclsched.a             add_libary(clsched STATIC clsched.c clsched_interceptor.c)     libclsched.a 생성   add_libary(clsched SHARED clsched.c clsched_interceptor.c)     libclsched.so 생성   2. sub디렉터리, -L, -I, -l 플래그      add_subdirectory: 하위 디렉터리 CMakeLists.txt   add_subdirectory (sub dir1　sub dir2)       하위 디렉터리의 CMakeLists.txt를 선행 빌드   include_directories: -I 참조 include 디렉터리 지정      참조할 include 디렉터리 지정  -I 옵션     $ gcc -I./include foo.c -o bar # gcc -I 옵션           include_directories (include dir1　include dir2)     link_directories: -L 참조 라이브러리 디렉터리 지정      링크할 라이브러리가 있는 디렉터리 지정  -L 옵션     $ gcc -L./lib main.c -lclsched # gcc -L 옵션           link_directories (link dir 1　link dir 2)   target_link_libraries: -l 라이브러리 링크 걸기      링크할 라이브러리 지정  -l 옵션     $ gcc main.c -lclsched # gcc -l 옵션           target_link_libraries (library 1　library 2)   set     CMAKE_BUILD_TYPE: 빌드 형상              Debug: 디버깅 목적 빌드 -g 플래그       Release: 배포 목적 빌드       RelWithDebInfo: 배포 목적 빌드 + 디버깅 정보 포함       MinSizeRel: 최소 크기로 최적화한 배포 목적 빌드           set_property     COMPILE_DEFINITIONS: 심볼 정의     set_property(DIRECTORY  PROPERTY COMPILE_DEFINITIONS TEST=1)            현재 DIRECTORY의 모든 C파일을 컴파일할 때 TEST 심볼 정의           set_property(SOURCE  add.c PROPERTY COMPILE_DEFINITIONS QUICKADD=1)            특정 SOURCE인 add.c에 QUICKADD 심볼 정의           if/elseif/endif       if()　elseif()　 else()　 endif()     EQUAL, NOT, AND, OR          EXISTS: 파일 존재 유무            주의: 파일 확인하는 시점은 빌드가 실행되는 시점이 아닌 생성되는 시점                  MATCHES: 정규식 사용   크로스플랫폼 지원     Cross Platform 을 지원하려면 CMake의 빌드 기술은 플랫폼 중립적이어야한다.            빌드 프로세스에서 사용되는 도구와 파일 위치를 상세히 기술하지 않는다.       CMake에 의해 찾게한다.              ls프로그램, stdio.h 헤더파일, math라이브러리를 찾는 예제이다.   find_program(LS_PATH ls)\t# ls 프로그램을 찾아 LS_PATH 변수에 담는다. message(\"ls path: ${LS_PATH}\")  find_file(STDIO_H_PATH stdio.h)\t# stdio.h 파일을 찾아서 STDIO_H_PATH 변수에 담는다. message(\"stdio path: ${STDIO_H_PATH}\")  find_library(LIB_MATH_PATH m /usr/local/lib /usr/lib64)\t# lib'm'.so 를 찾기 위해 /usr/local/lib /usr/lib64를 찾아봐라 message(\"math lib path: ${LIB_MATH_PATH}\")  ls path: /bin/ls stdio path: /usr/include/stdio.h math lib path: /usr/lib/libm.so   매크로 입력      -G: 기본 생성 빌드 시스템 변경   $ cmake -G \"Visual Studio 10\" ../src   ccmake     ccmake 명령으로 네이티브 빌드 시스템을 더욱 자세히 설정할 수 있다.        패키지 이름: cmake-curses-gui       캐시 변수들은 오브젝트 디렉터리에 있는 CMakeCache.txt에 저장되어 있다.   다음은 일반적으로 사용되는 캐시 변수                  Cache Variable       Description                       CMAKE_AR       라이브러리를 묶는 아카이버 도구                 CMAKE_C_COMPILER       C 컴파일러                 CMAKE_LINKER       오브젝트 링커                 CMAKE_MAKE_PROGRAM       /usr/bin/gmake와 같은 네이티브 빌드 도구의 절대 경로                 CMAKE_BUILD_TYPE       생성하고 싶은 빌드 트리의 타입 지정, 다음과 같이 설정할 수 있다. Debug, Release, RelWithDebInfo, MinSizeRel                 CMAKE_C_FLAGS_*       C 컴파일 옵션, 위 CMAKE_BUILD_TYPE에 따라 CMake는 캐시 변수에 저장된 C 컴파일 옵션을 사용하게 된다.                 CMAKE_EXE_LINKER_FLAGS_*       링커 옵션, 위 CMAKE_BUILD_TYPE에 따라 타입에 따른 링커 옵션을 나타낸다.              새로운 캐시 변수를 정의할 수 있다.   CMakeLists.txt 빌드 기술 내부에서 캐시 변수는 일반 변수와 같이 사용될 수 있다.      각 옵션에 대한 설명과 들어가는 옵션 값들을 잘 설명해주고 교체할 수 있다.  ","categories": ["linux-compile"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-compile/compile_3_cmake/",
        "teaser": null
      },{
        "title": "컴파일 <4> RPM 패키지",
        "excerpt":"소프트웨어 패키징과 설치     빌드 프로세스의 마지막 단계는 릴리스 패키지 생성이다.            타겟 머신상에 설치할 파일의 완전한 집합을 포함해야 한다.           아카이브 파일     zip, tar 과 같은 큰 파일을 묶는 프로그램            필요한 파일을 오브젝트 트리 밖으로 복사       임시 보관 디렉터리 보냄       디렉터리에 담긴 모든 내용을 아카이빙 툴을 이용해 하나의 파일로 패키징                    하위 디렉터리 파일 위치 기록 됨                           RPM 패키지 관리 포맷      실행 프로그램 바이너리 RPM 패키지 장점            컴파일 수행할 필요 없이 수 초 안에 소프트웨어 설치 가능       일관성 있는 메타 정보                    각 RPM 파일은 패키지 이름, 패키지 버전, 생성 날짜, 작성자 이름과 이메일, 패키지 다운 URL, SW 사용권 계약 등을 README 혹은 일관된 필드에 맞춘 포맷을 저장해 외부 프로그램이 이를 활용할 수 있다.                       내장 스크립트                    .zip .tar 와 달리 다양한 내장 스크립트를 포함한다.                       종속성 검사           rpmbuild 프로세스      4개 파일 패키징하는 예제         example.spec(RPM 명세 파일): 패키징되어야 하는 파일의 목록, 패키지 메타 정보, 설치 스크립트   소스코드 아카이브: tar.gz 파일로 제공되는 원본 소스코드 아카이브.            패키징 프로세스는 소스 파일을 추출, 필요한 실행 파일을 만들기 위해 빌드와 설치의 표준 절차를 따른다.       example-2.3.4.tar.gz           rpmbuild 도구가 RPM 파일 만듦            example.spec 지시 사항을 읽어 제품 소스코드 구성       최종 실행 프로그램 빌드       메타 정보, 설치 스크립트를 RPM 파일에 넣는다.       example-2.3.4-1.586.rpm           RPM 명세 파일(example.spec)의 예   rpmbuild 도구가 사용할 디렉터리 구조     /usr/src/packages 안에 누구나 쓰기가 가능한 디렉터리가 있다.   $ ls -l /usr/src/packages/ total 20 drwxrwxrwt\t4\troot\troot\t4096\t2009-09-14\t15:30\tBUILD drwxrwxrwt\t9\troot\troot\t4096\t2009-09-14\t15:30\tRPMS drwxrwxrwt\t2\troot\troot\t4096\t2009-09-14\t15:30\tSOURCES drwxrwxrwt\t2\troot\troot\t4096\t2009-09-14\t15:30\tSPECS drwxrwxrwt\t2\troot\troot\t4096\t2009-09-14\t15:30\tSRPMS     BUILD            rpmbuild가 원본 소스코드 아카이브(example-2.3.4.tar.gz)를 컴파일하며 생성한 소스코드와 오브젝트 트리 저장하는 곳           RPMS            이 디렉터리는 최종 출력 파일인 example-2.3.4-1.586.rpm이 위치하는 디렉터리           SOURCES            원본 소스코드 아카이브(example-2.3.4.tar.gz)는 rpmbuild가 찾을 수 있게 반드시 이 디렉터리에 저장되어야 한다.           SPECS            example.spec 구성 파일은 이 디렉터리에 저장된다.           SRPMS            RPMS 디렉터리와 유사하지만, 바이너리 RPM 파일 대신 소스 RPM 파일을 저장하는 데 사용된다는 점이 다르다.                Name: 이 패키지를 고유하게 설명 식별자   Version: 이 소프트웨어의 릴리즈 버전   Release: 릴리즈 버전 식별. 같은 Version이라도 Release 버전이 다르게 배포할 수 있음   Group: 최종 사용자가 GUI 도구를 통해 SW를 설치하면 SW의 그룹 필드는 이 SW가 어떤 항목 안에 나타나야 하는지에 관한 정보를 제공한다. 이 파일에서는 RPM이 발행 애플리케이션(publishing application)으로 분류되어야 한다고 요청하고 있다.   Vendor, URL, Packager: 어떤 단체가 패키지를 만들었는지, 어디서 다운로드할 수 있는지, 누가 패키징을 했는지 세부 정보 제공. 시스템에 이미 설치된 패키지에 관한 정보를 찾아볼 때 유용   Summary: 이 필드는 패키지 안의 소프트웨어에 관한 간략한 설명을 제공한다. 보통 GUI 도구가 소프트웨어에 관한 한 줄의 개요를 표시하는 데 사용된다. 더 자세한 정보는 여러 줄의 텍스트를 담을 수 있는 %description 절을 사용할 수 있다.   License: 라이선스 표시   Source: SOURCES 디렉터리 안에 위치해야 하는, 소스코드의 타르볼tar-ball 파일이름     12 Source: %{name}-%{version}.tar.gz           Buildroot: rpmbuild에 프로그램의 실행 파일이 설치되야하는 위치를 알려준다. 소스코드의 압축을 풀고 컴파일하는 BUILD 디렉터리와는 다르다. 빌드 루트build root가 타겟 머신상의 설치 디렉터리를 미러링하는 임시 보관 디렉터리     15 Buildroot: %{_tmppath}/%{name}-%{version}-buildroot                 컴파일된 프로그램을 빌드 머신상의 /usr/bin에 설치하는 대신, 이를 /tmp/example-2.3.4-buildroot/usr/bin에 위치시킨다. 아카이브에 포함될 모든 파일을 모으기 쉬운 위치를 선택해서 타겟 머신에 설치할 준비를 하는 편이 더 편하다.           Requires: example 패키지를 설치하기 위해 glibc 패키지가 반드시 필요함을 나타낸다.     16 Requires: glibc &gt; 2.6           %description: 패키지에 관한 임의의 텍스트 기반 설명을 기재   %prep: 소프트웨어의 소스코드 트리를 준비하기 위한 명령의 목록 제공 타르볼의 압축을 풀어 소스코드를 가져오기 위해 표준 동작을 사용하고 빌드가 BUILD 하위 디렉터리에서 이뤄지기 때문에, 기본 제공 명령인 %setup -q를 사용해 파일을 추출할 수 있다.     25 %prep 26 %setup -q           %build: 소스코드를 컴파일해 실행 프로그램을 만드는 셸 명령을 제공한다. 이 예제에서는 이미 만들어진 makefile을 사용한다. 두 개의 다른 빌드 시스템을 따로 사용하는 상황은 별다른 의미가 없어 rpmbuild를 통해 기존 시스템을 호출하는 방법이 최선     28 %build 31 make           %install: 소프트웨어를 설치하는 명령을 제공한다. 하지만 실행 프로그램을 빌드 머신에 설치하지 않고, 대신 $RPM_BUILD_ROOT가 나타내는 임시 보관 디렉터리에 설치한다.     34 %install 36 make install PREFIX=$RPM_BUILD_ROOT                 기존 make install 빌드 타겟을 재사용해 타겟 머신이 요청한 디렉터리 구조로 정확히 SW를 위치시킨다. 여기서도 필요한 출력 파일을 설치되기만 한다면 어떤 식으로든 셸 명령을 나열할 수 있다.             여기 이후로는 RPM 아카이브로 패키징할 모든 파일 나열       39 %files 43 %attr(0750,root,root) /usr/bin/example 44 %attr(0755,root,root) /usr/lib/libexample.so.1 45 %attr(0755,root,root) /usr/lib/libhelper.so.4 46 %attr(0644,root,root) %doc /usr/share/doc/manual/example.pdf                 파일의 접근 제어 정보(권한 비트, 파일 소유자, 파일 그룹) 지정       %doc 지시어, 어떤 설치 파일이 단순한 문서인지(무시 가능한) 구분           정리     48 %clean 49 rm -r $RPM_BUILD_ROOT          %pre: 파일을 설치하기 전에 실행하는 셸 스크립트  %post: 파일을 설치한 후에 실행하는 셸 스크립트  %preun: 파일을 시스템에서 제거하기 전에 실행하는 셸 스크립트  %postun: 파일을 시스템에서 제거한 후에 실행하는 셸 스크립트      50 %post 51 groupadd exgroup 52 chgrp exgroup /usr/bin/example 54 %preun 55 groupdel exgroup           새로운 유닉스 그룹(exgroup)을 추가하는 설치 후 스크립트를 포함하고 있다.            이 그룹의 구성원만이 /usr/bin/example 프로그램을 실행할 수 있게 제한한다.           명세 파일로 부터 RPM 파일 작성      example.spec을 입력으로 사용해 rpmbuild 명령을 실행한 결과를 나타낸다.   소스코드를 BUILD 디렉터리로 추출하는 gzip 명령 확인   마지막 부분에 rpmbuild 도구가 소스코드를 컴파일할 때 사용하게 지정했던 make 명령을 찾을 수 있다.   $ rpmbuild -bb example.spec Executing(%prep): /bin/sh -e /var/tmp/rpm-tmp.68587 + umask 022 + cd /usr/src/packages/BUILD + cd /usr/src/packages/BUILD + rm -rf example-2.3.4 + /usr/bin/gzip -dc /usr/src/packages/SOURCES/example-2.3.4.tar.gz + tar -xf - + STATUS=0 + '[' 0 -ne 0 ']' + cd example-2.3.4 ++ /usr/bin/id -u + '[' 1000 = 0 ']' ++ /usr/bin/id -u + '[' 1000 = 0 ']' + /bin/chmod -Rf a+rX,u+w,g-w,o-w . + exit 0 Executing(%build): /bin/sh -e /var/tmp/rpm-tmp.68587 + umask 022 + cd /usr/src/packages/BUILD + /bin/rm -rf /var/tmp/example-2.3.4-buildroot ++ dirname /var/tmp/example-2.3.4-buildroot + /bin/mkdir -p /var/tmp + /bin/mkdir /var/tmp/example-2.3.4-buildroot + cd example-2.3.4 + make Building all example code. ... Remaining output truncated ...   모든 사항이 올바르게 동작했는지 다시 한 번 확인하기 위해 RPMS 하위 디렉터리에서 RPM 파일을 찾아봐야 한다.  $ cd /usr/src/packages/RPMS/i586 $ ls -l total 4 -rw-r--r-- 1 psmith users 2706 2009-09-14 15:16 example-2.3.4-1.i586.rpm     이 도구를 통해 example.spec 파일에 명시적으로 나열되지 않은 파일이 빌드 루트 디렉터리에 설치되었는지 확인 할 수 있다.            이런 에러를 잡으면 하나 이상의 중요한 파일이 빠진 소프트웨어를 릴리스하는 실수를 피할 수 있다.           다음은 에러 메시지를 보여준다.   $ rpmbuild -bb example.spec ... Checking for unpackaged file(s): /usr/lib/rpm/check-files /var/tmp/example-2.3.4-buildroot error: Installed (but unpackaged) file(s) found: \t/usr/lib/libhelper.so.4  RPM build errors: \tInstalled (but unpackaged) file(s) found: \t/usr/lib/libhelper.so.4  RPM 예제 설치      RPM 파일은 지정된 OS와 CPU타입을 대상으로 하므로 어렵지 않게 RPM파일을 타겟 머신에 설치할 수 있다.   RPM 패키지의 내용을 살펴본다.            -q: RPM 파일의 내용 질의                    -i: 모든 메타 정보 확인             $ rpm -q -p -i example-2.3.4-1.1586.rpm Name\t: example\tRelocations: (not relocatable) Version\t: 2.3.4\t\tVendor: Arapiki Solutions, Inc.  Release : 1\t\tBuild Date: Mon 14 Sep 2009 03:16:06 PM Install Date: (not installed)\tBuild Host: linux Group\t: Applications/Publishing Source RPM: example-2.3.4-1.src.rpm  Size : 12\t\tLicense: Exampleware  Signature : (none) Packager : Peter Smith psmith@arapiki.com  URL: http://www.arapiki.com  Summary : This is an example program to show how RPMS work.  Description :  This is an example program that demonstrates how RPMS work... ... prerequsite packages are already installed.  Distribution: (none)                                   -l: 아카이브 내의 파일 목록 확인             $ rpm -q -p -l example-2.3.4-1.i586.rpm /usr/bin/example /usr/lib/libexample.so.1 /usr/lib/libhelper.so.4 /usr/share/doc/manual/example.pdf                                                   RPM 설치            -i: 이 옵션과 함께 rpm명령을 내리면 패키지 설치         $ sudo -s # rpm -i example-2.3.4-1.i586.rpm                  이 명령 실행 후 아무 내용도 출력되지 않으면, 잘 완료된 것                   RPM 설치된 패키지 보이기            -q: RPM 파일의 내용 질의                    -a: 현재 시스템에 설치된 모든 패키지 보여라.             $ sudo -s # rpm -qa | grep example example-2.3.4-1                                                   RPM 패키지 삭제            -e: 설치된 모든 파일을 시스템에서 제거하고, 설치 제거 스크립트는 exgroup을 유닉스 그룹에서 삭제한다.         $ sudo -s # rpm -e example-2.3.4                  아무 내용도 출력되지 않으면, 잘 완료된 것                   ","categories": ["linux-compile"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-compile/compile_4_package/",
        "teaser": null
      },{
        "title": "mmap()",
        "excerpt":"Map a file on memory       Process address space: 프로세스 주소 공간 프로세스는 자신만의 가상 주소 공간(Virtual Address Space)를 가지고 있다고 생각하고 동작   mmap()은 특정 파일 내용 일부를 프로세스 주소 공간에 매핑함!            Originally, file I/O는 FILE* API 혹은 저수준 I/O systemcall 사용       당연히 메모리상에 매핑 시키면, pointer로 왔다갔다 접근하면 되어서 빠름       dev file을 매핑 시키면, Memory Mapped I/O       파일을 메모리에을 매핑 시키면, 자원 공유 가능!           mmap():2   #include &lt;sys/mman.h&gt;  void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);     기능: fd의 파일을 매핑 시킴                  return       value                       성공       Mapping된 주소                 실패       MAP_FAILED                          parameter       Description                       *addr       매핑이 될 주소(시작 주소), 보통 강제성 없이 hint로 줌                 length       매핑할 길이                 prot       PROT_EXEC: 페이지 실행 用 PROT_READ: 페이지 읽기 用 PROT_WRITE: 페이지 쓰기 用 PROT_NONE: 페이지는 액세스 되지 않는다.                 flags       MAP_SHARED: P1과 P2가 동시에 매핑한다고 할 때, Update를 서로가 알 수 있으며 파일에도 적용 됨(msync()의 사용이 요구됨) MAP_SHARED_VALIDATE: MAP_SHARED에서 flags 의 알려지지 않은 flags를 무시하는 것만 제외하고는 MAP_SHARED와 동일 MAP_PRIVATE: P1과 P2가 동시에 매핑한다고 할 때, Update를 서로가 알 수 없으며 파일에 전달되지 않는다.  MAP_FIXED:addr을 힌트로써 interpret하지 마라. 그 주소로 정확하게 매핑해라.  MAP_ANONYMOUS: 매핑이 어떠한 파일에 의해 지원되지 않는다. Zero로 초기화된다. fd는 무시된다. 더 많은 내용은 man page참고                 fd       매핑 시킬 파일의 fd                 offset       Page의 배수           munmap():2   #include &lt;sys/mman.h&gt;  int munmap(void *addr, size_t length);     기능: mmap()을 통해 매핑된 어드레스 해제, 맵 언맵                  return       value                       성공       0                 실패       -1                          parameter       Description                       addr       mapped address                 length       해제할 length           Example 1. mmap_basic.c    #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/mman.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt;  typedef struct{ \tchar name[16]; \tint age; }PERSON;  static int write_info(PERSON *p){ \tint fd; \tssize_t ret;  \tfd=open(\"person_info\", O_CREAT | O_WRONLY | O_APPEND, 0644); \tif(fd==-1){ \t\tperror(\"open() fail\\n\"); \t\treturn -1; \t}  \tret=write(fd, p, sizeof(PERSON)); \tif(ret==-1){ \t\tperror(\"write() fail\\n\"); \t\tclose(fd); \t\treturn -1; \t} else if(ret != sizeof(PERSON)){ \t\tperror(\"write() was written partially\\n\"); \t\tclose(fd); \t\treturn -1; \t} \tclose(fd); \treturn 0;  }  static int dump_info(void){ \t// 1. Open file as FD \tint fd; \tstruct stat sb; \tPERSON *p; \tint i;  \tfd=open(\"person_info\", O_RDONLY); \tif(fd==-1){ \t\tperror(\"open() fail\\n\"); \t\treturn -1; \t} \t// 2. mmap을 통해 얼마나 매핑할 것 인지 알아야하는데, 이를 위해 파일의 크기를 얻는다. \tif(fstat(fd,&amp;sb)==-1){ \t\tprintf(\"stat() fail\\n\"); \t\tclose(fd); \t\treturn -1; \t} \t/*  \t * 3. struct stat의 st_size 멤버는 파일의 사이즈 \t * 4. st_size만큼 length를 요구한다 \t * 5. offset은 파일의 처음부터 읽어올 것 이기 때문에 0 \t */ \tp=mmap(NULL, sb.st_size, PROT_READ, MAP_SHARED, fd, 0); \tif(p==MAP_FAILED){ \t\tprintf(\"mmap() fail\\n\"); \t\tclose(fd); \t\treturn -1; \t}  \t// Now P is starting point at the file \tprintf(\"file size: %ld\\n\",sb.st_size);  \tfor(i=0; i&lt; sb.st_size / sizeof(PERSON); i++){ \t\tprintf(\"name: %s, age: %d\\n\",p[i].name, p[i].age); \t} \tclose(fd);  \tmunmap(p,sb.st_size); \treturn 0; }  int main(int argc, char *argv[]){ \tPERSON persons[]={ \t\t{\"kim\", 40}, \t\t{\"mike\", 23} \t};  \twrite_info(&amp;persons[0]); \twrite_info(&amp;persons[1]); \tdump_info();  \treturn 0; }         mmap의 length는 파일의 사이즈로 가져온다.   파일의 사이즈는 stat()으로 가져옴  ","categories": ["file"],
        "tags": [],
        "url": "https://markyang920413.github.io//file/system_programming-file-mmap/",
        "teaser": null
      },{
        "title": "파일을 이용한 동기화",
        "excerpt":"파일을 이용한 동기화     Race condition(경쟁 상태)            둘 이상의 프로세스/Thread가 동시에 어떤 작업을 수행 시, 타이밍 등에 의해 의도치 않은 결과가 나올 수 있는 상태           Critical Section(임계 영역)            둘 이상의 프로세스/Thread가 동시에 접근하면 안되는 공유데이터를 접근하는 코드 영역       즉, Race Condition을 발생 시킬 수 있는 코드 영역                 Race condition을 해결하기 위한 간단한 방법: Lock mechanism            Thread가 critical section code에 진입할 수 있는 열쇠를(Lock을 획득) 얻어야 Critical section code에 진입할 수 있다.             파일을 이용한 동기화에서는 파일 디스크립터(fd)가 lock의 역할을 한다.   #include &lt;sys/file.h&gt;  int flock(int fd, int operation);                  return       value                       성공       0                 실패       -1                          parameter       Description                       fd       파일 디스크립터                 operation       LOCK_SH: shared lock 걸기 - 여러개의 프로세스(스레드)가 lock을 획득 할 수 있다. LOCK_EX: exclusive lock 걸기 -어느 프로세스(스레드)가 lock을 소유한다면 다른 프로세스(스레드)는 lock을 획득 할 수 없다. LOCK_UN: lock 풀기 shared, exclusive 둘다 풂 LOCK_NB: non-block(획득에 실패한 P/T는 대기아닌 바로 Error Return-errno 필요). 다른 값과 ORing(|)하여 사용                              　       shared lock 획득 시도       exclusive lock 획득 시도                       lock 없음       즉시 성공       즉시 성공                 어떤 프로세스/스레드에 의해 shared locked 상태       즉시 성공       모든 shared lock이 풀릴 때까지 대기                 어떤 프로세스/스레드에 의해 exclusive lock 상태       exclusive lock이 풀릴 때까지 대기       exclusive lock이 풀릴 때까지 대기           ex 1. simple_flock.c    #include &lt;stdio.h&gt; #include &lt;sys/file.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt;  #define NON_BLOCK 1  static void print_usage(char *progname){ \tprintf(\"usage: %s {ex | sh}\\nex: exclussive lock\\nsh: shared lock\\n\", progname); \texit(-1); }  int main(int argc, char *argv[]){ \tint fd; \tint ops;  \tif(argc&lt;2){ \t\tprint_usage(argv[0]); \t}  \tif(!strcmp(argv[1], \"sh\")){ \t\tops = LOCK_SH; \t} else if (!strcmp(argv[1], \"ex\")){ \t\tops = LOCK_EX; \t} else{ \t\tprint_usage(argv[0]); \t}  \tfd=open(\"lockfile\", O_RDWR | O_CREAT, 0600); \tif(fd&lt;0){ \t\tperror(\"open fail\\n\"); \t\treturn -1; \t}  \tprintf(\"trying to grab the lock\\n\"); #if NON_BLOCK == 0 \tif(flock(fd, ops){ // Lock \t\tprintf(\"flock(ops %d)\\n\", ops); \t\tgoto out; \t} #elif NON_BLOCK == 1 \tif(flock(fd, ops | LOCK_NB)!=0){ // Lock \t\tprintf(\"flock(ops %d), errno=%d(%s)\\n\", ops, errno, strerror(errno)); \t\tgoto out; \t} #endif \tprintf(\"got the lock!\\n\"); \tint ch=getc(stdin); // Wait for inserting key from User.  \tif(flock(fd, LOCK_UN)!=0){ // Unlock \t\tprintf(\"flock(unlock)\\n\"); \t\tgoto out; \t} \tprintf(\"unlock!\\n\");  \treturn 0; out: \tclose(fd); \treturn -1;   }         두 Process 모두 Shared Lock grab 시도            두 Process 모두 lock 소유 가능       두 Process 모두 critical section에 들어와있다.                P1 Shared Lock 먼저 lock획득, P2 Exclusive Lock grab 시도            P1이 먼저 lock 획득 시, P2는 나중에 lock 획득 시도 -&gt; 대기 상태된다.       P1이 Unlock 해야 P2는 Lock 획득                P2 Exclusive Lock 먼저 lock획득, P1은 Shared Lock            P2가 먼저 Ex-lock 획득, P1은 나중에 lock 획득 시도 하지만 대기 상태된다.       P2이 Unlock 해야 P1는 Lock 획득                P1, P2 Exclusive Lock            뒤늦게 lock 획득 시도 시, 대기 상태                LOCK_NB set! 시!, 뒤늦게 lock 획득 시도하는 프로세스는 error!  ","categories": ["ipc"],
        "tags": [],
        "url": "https://markyang920413.github.io//ipc/system_programming-ipc-synchronization_using_file/",
        "teaser": null
      },{
        "title": "tmux",
        "excerpt":"Tmux install   # ubuntu $ sudo apt install tmux  # mac $ brew install tmux   Tmux components      session: tmux의 실행 단위. tmux의 각각의 프로세스라고 보면 편함             tmux ls를 통해 조회한 실행 중인 tmux       0번 세션: 2개의 윈도우                    즉, 여러 윈도우가 모여 하나의 세션을 가짐                           window: tmux로 보고 있는 하나가 윈도우임               한 세션에서 #0, #1 윈도우           pane: 한 윈도우안에서 각 분할창   Tmux shortcut      prefix key: tmux의 prefix키는 사용자 설정 마다 다르다.            default: ctrl + b       본인은 ` 키           session      새 세션 설정     $ tmux new -s &lt;session-name&gt;           세션 종료     # (해당 tmux 세션에서) $ exit           열려 있는 tmux 세션들 조회     $ tmux ls           세션 detach (잠시 빠져 나감)     $ prefix + d           세션 attach     $ tmux a -t &lt;session-num | session-name&gt;           window      새 윈도우 생성     $ prefix + c           윈도우 이동     $ prefix + &lt;option&gt; 　 option: 0-9\t\twindow number n\t\tnext window p\t\tprev window l\t\tlast window w\t\twindow selector f\t\tfind by name           윈도우 종료     $ prefix + &amp; or $ ctrl + d or $ exit (해당 윈도우에서 모든 pane이 사라질 때 까지 계속 치면 됨)           pane      pane 나누기     $ prefix + % : vertical 나누기            \" : horizental 나누기           pane 이동     $ prefix + 화살표 키           pane 삭제     $ prefix + x or $ ctrl + d or  exit (해당 pane에서)           copy      terminal copy모드 진입     $ prefix + [           terminal  부분 복사            본인 설정에선 Vim과 같게 셋팅           terminal copy모드 나가기     $ q (terminal copy모드 내애서)           copy 모드에서 복사한 것 paste     $ prefix + ]           My setting     ~/.tmux.conf   set-option -g mouse on set-option -g history-limit 10000 unbind C-b unbind l set -g prefix ` bind-key o last-window bind-key ` send-prefix bind-key k kill-window set -g default-terminal \"screen-256color\" set -g history-limit 1000 #set -g status-left '#[fg=brightwhite]###I #[fg=brightyellow,bg=black]#(hostname) #[fg=brightwhite,bg=brightblue]#W' set -g status-left '#[fg=colour015]###I #[fg=colour229,bg=black]#(hostname) #[fg=colour015,bg=colour026]#W' set -g status-left-length 50 set -g status-right '[%H:%M %Y-%m-%d]' #set -g status-right-bg brightwhite set -g status-justify right #set -wg window-status-bg brightwhite set -wg window-status-current-format '#I#F #W ' set -wg window-status-format '#I#F #W ' set -wg mode-keys vi  bind P paste-buffer bind-key -T copy-mode-vi v send-keys -X begin-selection bind-key -T copy-mode-vi y send-keys -X copy-selection bind-key -T copy-mode-vi r send-keys -X rectangle-toggle   bind r source-file ~/.tmux.conf   vim copy/paste     vim에서 paste할 때, 계단현상 발생     :set paste!           ","categories": ["linux-tools"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-tools/tmux/",
        "teaser": null
      },{
        "title": "유저 정보, PW얻기: getpwent(), getspent(), getspnam()",
        "excerpt":"유저 파일          adduser명령: user 생성            /etc: 유저 관련 파일 관리 및 설정                      /etc 이하 파일       Description                       passwd       유저 이름 PW관리 PW 제외한 정보들 관리(최근)                 shadow       passwd와 비슷하지만 보안 강화 실제 PW 저장                 group       그룹 정보 저장                 adduser.conf       유저생성과 관련된 변수들 정의           passwd, shadow      /etc/passwd: 유저 이름 및 PW제외 정보들 저장   # cat /etc/passwd yundream:x:1000:1000:yundream,,,:/home/yundream:bin/bash mysql:x:110:121:MySQL Server,,,:/var/lib/mysql:/bin/false  \"유저:패스워드:UID:GID:GECOS:디렉터리:쉘\"     유저: 시스템 내에서 사용되는 유저이름   passwd: 유저가 사용할 패스워드   UID: 유저에게 부여되는 ID   GID: 유저가 포함되는 그룹의 ID   GECOS: 유저의 부가정보(생략가능)   디렉터리: 해당 유저의 홈 디렉터리        쉘: 해당 유저가 사용하는 기본 shell       sudo 권한이 있다면, /etc/passwd를 편집할 수 있어서 어렵지 않게 유저를 추가시킬 수 있다.   파일 권한 설정등에 사용되는 값은 유저이름, UID이다.   패스워드는 x로 되어있다. 패스워드는 shadow에 저장된다.   $ ls -al /etc/shadow -rw-r----- 1 root shadow 966 2008-01-09 23:34 /etc/shadow     오직 root만 읽을 수 있다.   getpwent(): 사용자 정보 얻어오기      /etc/passwd를 읽어와서 유저 정보를 얻어주는 표준 라이브러리가 있다. getpwent() 함수   #include &lt;pwd.h&gt; #include &lt;sys/types.h&gt;  struct passwd *getpwent(void);     getpwent() 함수는 /etc/passwd에서 패스워드 정보를 읽어들여 passwd 구조체에 저장하고, 포인터를 돌려준다.   struct passwd{ \tchar *pw_name;\t\t/* 유저 이름 */ \tchar *pw_passwd;\t/* 유저 패스워드 */ \tuid_t pw_uid;\t\t/* 유저 ID(UID) */ \tuid_t pw_gid;\t\t/* 그룹 ID(UID) */ \tchar *pw_gecos;\t\t/* 실제 이름 */ \tchar *pw_dir;\t\t/* 홈 디렉터리 */ \tchar *pw_shell\t\t/* 사용자 쉘 */ };   getpwent()를 사용해 유저 정보를 읽어오는 예제    #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;pwd.h&gt; #include &lt;sys/types.h&gt;  int main(int argc, char *argv[]){ \tchar *name; \tif(argc!=2){ \t\tprintf(\"Usage: %s username\\n\", argv[0]); \t\treturn 1; \t} \tname=argv[1];  \t/* 유저 정보를 담을 passwd 구조체 */ \tstruct passwd *pass_info=NULL;  \twhile((pass_info=getpwent())!=NULL){ \t\tif(strncmp(name, pass_info-&gt;pw_name, strlen(name))==0){ \t\t\tprintf(\"%12s uid(%d) gid(%d) home(%s)\\n\", \t\t\t\tpass_info-&gt;pw_name, \t\t\t\tpass_info-&gt;pw_uid, \t\t\t\tpass_info-&gt;pw_gid, \t\t\t\tpass_info-&gt;pw_dir); \t\t\treturn 0; \t\t} \t} \tprintf(\"Can't find User : %s\\n\",name); \treturn 1; }      getspendt(), getspnam(): 사용자 패스워드 얻어오기     만약 유저인증을 위한 프로그램 만들기를 원한다면, 패스워드까지 가져오는 프로그램을 만들어야한다.   패스워드는 /etc/shadow에 저장되어 있음            getspent()를 사용하면 간단하게 정보를 얻을 수 있다.       단 shadow파일은 root만 읽을 수 있다.           #include &lt;shadow.h&gt;  struct spwd *getspent(); struct spwd *getspnam(char *name);   사용자 로그인 기록     리눅스는 다중 사용자 OS인 만큼, 현재 시스템에 어떤 사용자가 들어와있는지에 대한 정보가 중요하게 취급된다.   이러한 정보는 사용자 점검, 보안 점검등에서 잘 사용된다.   커맨드 w      w라는 명령으로 현재 로그인된 사용자 정보를 얻을 수 있다.   $ w  23:27:41  up 35 days, 12:51,  1 user,  load average: 0.13, 0.42, 0.65 USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU  WHAT root     pts/4    202.150.176.150  11:27pm  0.00s  0.05s  0.00s  w  yundream pts/1    :0               22:59    6.00s  0.34s  0.16s  w3m      IP, 로그인한 시간, 자원 사용율, 현재 어떤 프로그램을 실행 중 정보를 보여줌   getutent(): 로그인 기록    #include &lt;utmp.h&gt;  struct utmp *getutent(void);     로그인 기록시스템을 얻을 수 있다.   /var/run/utmp 파일에 기록된다.   getutent는 읽어들인 정보를 utmp 구조체에 채워서 되돌려 준다.   struct utmp{ \tshort ut_type;\t\t\t\"로그인 타입\" \tpid_t ut_pid;\t\t\t\"로그인 프로세스의 pid\" \tchar ut_line[UT_LINESIZE];\t\" tty의 디바이스 이름 - \"/dev/\" \" \tchar ut_id[4];\t\t\t\"초기 id 혹은 abbrev. ttyname\" \tchar ut_user[UT_NAMESIZE];\t\"user 이름\" \tchar ut_host[UT_HOSTSIZE];\t\"remote login에 대한 호스트 이름\" \tstruct exit_status ut_exit;\t\"DEAD_PROCESS 같이 마킹되는 프로세스의 exit status\" \tlong ut_session;\t\t\"세선 ID\" \tstruct timeval ut_tv;\t\t\"만들어진 타임 etnry\" \tint32_t ut_addr_v6[4];\t\t\"remote host의 IP 주소\" \tchar pad[20];\t\t\t\"나중에 사용될 예약 번호\" };     예제   #include &lt;unistd.h&gt; #include &lt;utmp.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;time.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt;  int get_current_pid(int login_pid); char *get_current_procname(int proc_num);  int main(int argc, char *argv[]){ \tstruct utmp *utmpfp; \tstruct utmp *myutmp;  \tchar *tty_name=NULL; \tchar *host_ip;  \tchar now_local_time[50];  \ttime_t the_time; \tstruct tm *tm_ptr;  \tsetutent();  \t// getutent()를 이용해서 utmp 정보를 얻어온다 \twhile((utmpfp=getutent())!=NULL){ \t\t// ut_time은 유닉스 시간으로 저장되는데, localtime 함수를 이용해서 \t\t// 우리가 쉽게 읽을 수 있는 시간으로 변경 \t\tthe_time=utmpfp-&gt;ut_time; \t\ttm_ptr=localtime(&amp;the_time); \t\tsprintf(now_local_time, \"%d/%02d/%02d %02d:%02d\", tm_ptr-&gt;tm_year+1900, tm_ptr-&gt;tm_mon+1,  \t\t\t\ttm_ptr-&gt;tm_mday, tm_ptr-&gt;tm_hour, tm_ptr-&gt;tm_min);  \t\thost_ip=utmpfp-&gt;ut_host; \t\tif(strlen(host_ip)&lt;1) \t\t\thost_ip=\"-\"; \t\tif(utmpfp-&gt;ut_type == USER_PROCESS){ \t\t\tprintf(\"%-12s %-8s %-12s %s\t%s\\n\", \t\t\tutmpfp-&gt;ut_user, \t\t\tutmpfp-&gt;ut_line, \t\t\thost_ip, \t\t\tnow_local_time, \t\t\tget_current_procname(get_current_pid(utmpfp-&gt;ut_pid))); \t\t} \t}  \treturn 1; }  int get_current_pid(int login_pid){ \tint fd; \tchar buf[255]; \tchar stat_file[25]; \tint field_num=7; \tint i, j; \tint buf_index; \tchar current_pid[11];  \tmemset(buf, '\\0', 255); \tsprintf(stat_file, \"/proc/%d/stat\", login_pid);  \tif((fd=open(stat_file, O_RDONLY))==-1){ \t\tprintf(\"error\\n\"); \t\treturn -1; \t}  \tread(fd, buf, 255); \tj=0; \tfor(i=0, buf_index=0; i &lt; 255; i++){ \t\tif(buf[i]==' ') \t\t\tj++; \t\telse{ \t\t\tif(j == field_num){ \t\t\t\tcurrent_pid[buf_index] = buf[i]; \t\t\t\tbuf_index++; \t\t\t} \t\t\tif(j&gt;field_num) \t\t\t\tbreak; \t\t} \t} \tclose(fd); \treturn atoi(current_pid); }  char *get_current_procname(int proc_num){ \tchar *buf; \tchar proc_file[256];  \tbuf=(char*)malloc(256); \tmemset(buf, '\\0', 256);  \tmemset(proc_file, '\\0', 256); \tsprintf(proc_file, \"/proc/%d/exe\", proc_num);  \treadlink(proc_file, buf, 256); \treturn buf; }      다음은 실행 시킨 결과   $ ./myw yundream     :0       -            2008/01/17 22:59    yundream     pts/1    :0           2008/01/17 22:59    yundream     pts/2    :0           2008/01/17 23:17   ","categories": ["env"],
        "tags": [],
        "url": "https://markyang920413.github.io//env/add_user/",
        "teaser": null
      },{
        "title": "리눅스 ls, 권한, pstree",
        "excerpt":"파일의 종류     리눅스에서는 다양한 파일이 있다.   \"ls -al\"명령을 참조하여 살펴본다.        \"ls -al\"의 첫 필드로 파일의 종류를 알 수 있다.                  first field       type       Example                 -       일반 파일       txt, jpg, wave, pdf…                 d       디렉터리                         l       링크       심볼릭, 하드링크                 c       디바이스 파일       프린터, 사운드 카드 등                 s       소켓       소켓                 p       pipe       파이프              권한: 소유자(user), 그룹(group), Other            -rwxrw-r-x                          rwx       r-x       –x       -w-       –x                       421       401       001       020       001                 7       6       1       2       1              chmod: 권한 변경            chmod o-rwx [file] : 파일의 other의 rwx 삭제       chmod g-x [file] : 파일의 group의 x 삭제       chmod u+x [file] : 파일의 user의 x 가능           pstree: 프로세스 트리     예를 들어 실행 파일이 여러 자식 프로세스를 만든다고 가정   $ ./fork_omit_switch [0] PID(24090) PPID(24089) [1] PID(24091) PPID(24090) [2] PID(24092) PPID(24091) [2] PID(24091) PPID(24090) [1] PID(24090) PPID(24089) ...     프로세스의 PID와 PPID관계를 보기 쉽지 않다.      pstree -pl: 프로세스 트리 조회   $ ./fork_omit_switch&amp; $ pstree -pl ... fork_omit_switch(20489) ... fork_omit_switch(24090) ... fork_omit_switch(24091) ... fork_omit_switch(24092)                                                         fork_omit_switch(24093)                         ... fork_omit_switch(24094) ... fork_omit_switch(24095)                         ... fork_omit_switch(24096)   ","categories": ["linux-system"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-system/linux_linux-system_linuxfile/",
        "teaser": null
      },{
        "title": "thread <1> pthread, mutex, API",
        "excerpt":"Thread     새로운 프로세스를 만들지 않고 특정 문맥만 병렬로 실행할 수 있도록한다.                  Thread       Process                       프로세스의 서브셋       독립적 프로세스                 코드, 데이터, 힙을 다른 스레드와 공유 각자의 스택, pc가짐       자신만의 주소 영역                 -       IPC로만 다른 프로세스와 통신 가능하다.                 context switching 속도 빠름       context switching 속도 스레드보다 느림              fork가 copy-on-write방식으로 자식에게 복사하는데 비해 스레드는 많은 부분 공유하기 때문에 빠르다.                  platform       fork real        user        sys       pthread real        user        sys                 AMD 2.4 GHz Opteron (8cpus/node)       41.07       60.08       9.91       0.66       0.19       0.43                 IBM 1.9 GHz POWER5 p5-575 (8cpus/node)       64.24       30.78       27.68       1.75       0.69       1.10                 IBM 1.5 GHz POWER4 (8cpus/node)       104.05       48.64       47.21       2.01       1.00       1.52                 INTEL 2.4 GHz Xeon (2 cpus/node)       54.95       1.54       20.78       1.64       0.67       0.90                 INTEL 1.4 GHz Itanium2 (4 cpus/node)       54.54       1.07       22.22       2.03       1.26       0.67              kernel thread            하나의 프로세스=적어도 1개의 커널 스레드 가짐             User thread            유저레벨에서 사용하는 스레드           각 스레드가 각각 가지는 자원            errno       스레드 우선순위       스택       tid       레지스터 및 sp           스레드끼리 공유하는 자원            작업 디렉토리       fd       전역변수와 데이터들       UID, GID       signal              Multi thread 프로그램 단점      하나의 Thread에서 발생된 문제가 전체 Process에 영향   디버깅이 어렵다.   Pthread      리눅스에서는 pthread(Posix thread) 지원            컴파일 때 \"-lpthread\" 링크 옵션           signal은 프로세스단위로 작동한다.   Thread은 각 스레드마다 다른 시그널 정책이 필요하므로, 스레드 전용의 시그널 제어 함수가 필요      Pthread  pthread_create: 스레드 생성   #include &lt;pthread.h&gt;  int pthread_create(pthreads_t *thread, pthread_attr_t *attr, void *(*start_routin)(void *), void *arg);                  parameter       Description                 *thread       스레드가 성공적으로 생성됬을 때, 넘겨주는 쓰레드 식별 번호                 *attr       스레드 특성 설정하기 위해 사용. NULL일 경우 기본 특성                 *start_routine       스레드가 수행할 함수, 함수포인터를 넘긴다.                 *arg       스레드 함수 start_routine을 실행시킬 때, 넘겨줄 아규먼트                          return       value                 성공       0                 실패       errno              pthread_create( &amp;tid, attr, function, (void *)arg);            thread의 argument는 void *       64bit system에서는 thread에 보내는 정수형 argument는 long arg으로 할 것           pthread_join: 스레드 정리   #include &lt;pthread.h&gt;  int pthread_join(pthread_t th, void **thread_return);                  parameter       Description                 th       pthread_create에 의해 생성된 식별번호 th를 기다린다.                 thread_return       식별번호 th의 return 값              pthread_create  때 detach하게 생성 시            생성된 스레드는 나중에 join되지 않을 것이라고 생각       종료하자마자 모든 자원을 해제하며 pthread_join으로 기다릴 수 없다.       부모 스레드와 떨어져서 완전히 독립적으로 작용           join시, BLOCKING!   pthread_create(), pthread_join()에서 argument        왼) long 형　오) long * 형　arg 주고 받기   각 함수 선언 원형대로 Type casing해서 보내면됨   예제 1. 간단한 pthread    #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;pthread.h&gt;  // 쓰레드 함수 void *t_function(void *data){  \tlong id=*((long *)data);  \tprintf(\"thread: %ld\\n\",id);   \treturn (void**)id; }  int main(void){ \tpthread_t p_thread[2]; \tint t_id; \tlong a=1, b=3; // x64 system에서는 long 쓰자!!  \t// 스레드 생성 아규먼트로 1을 넘긴다. \tt_id=pthread_create(&amp;p_thread[0], NULL, t_function, &amp;a); \tif(t_id&lt;0){ \t\tperror(\"thread create error: \"); \t\texit(0); \t}  \t// 스레드 생성 아규먼트로 2를 넘긴다. \tt_id=pthread_create(&amp;p_thread[1], NULL, t_function, &amp;b); \tif(t_id&lt;0){ \t\tperror(\"thread create error: \"); \t\texit(0); \t}  \tlong status1; \tlong status2;  \tpthread_join(p_thread[0], (void**)&amp;status1); \tpthread_join(p_thread[1], (void**)&amp;status2);  \tprintf(\"status1: %ld\\n\", status1); \tprintf(\"status2: %ld\\n\", status2);  \treturn 0; }   $ gcc simple_thread.c -lpthread -o simple_thread $ ./simple_thread thread1: 1 thread2: 3 status1: 1 status2: 3   예제 2. double pointer arg 사용하는 스레드    #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt;   typedef struct{ \tint **arr; }PARAM;  void *t_func(void *args){ \tPARAM *param=(PARAM *)args; \t(param-&gt;arr)[0][0]=5;  \treturn param; }  int main(void){ \tpthread_t tid; \tpthread_attr_t attr; \tPARAM *param;  \tparam=(PARAM*)malloc(sizeof(PARAM)); \tparam-&gt;arr=(int**)malloc(sizeof(int)*1); \tparam-&gt;arr[0]=(int*)malloc(sizeof(int)*1);  \tpthread_attr_init(&amp;attr); \tpthread_create(&amp;tid, &amp;attr, t_func, (void *)param);  \tPARAM* return_param; \tpthread_join(tid, (void **)&amp;return_param);  \tprintf(\"%d\\n\", (return_param-&gt;arr)[0][0]);  \treturn 0;  }     2 차원 배열은 structure 안에 넣어서 전달해야한다.   pthread_detach(): 자식, 부모 스레드 분리하기      pthread_detach를 이용해서, 자식 스레드와 부모 스레드와 완전히 분리한다.            자식 스레드가 종료시, 모든 자원이 즉시 반납된다.       detach 시, 자식 종료 상태를 알 수 없다.           #include &lt;pthread.h&gt;  int pthread_detach(pthread_t thread);     detach할 thread넣기   #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;pthread.h&gt;  // 쓰레드 함수 // 1초를 기다린 후, 아규먼트^2를 리턴한다. void *t_function(void *data){ \tchar a[100000]; \tint num=*((int *)data); \tprintf(\"Thread Start\\n\"); \tsleep(5); \tprintf(\"Thread end\\n\"); }  int main(void){ \tpthread_t p_thread; \tint thr_id; \tint status; \tint a=100;  \tprintf(\"Before Thread\\n\"); \tthr_id=pthread_create(&amp;p_thread,NULL,t_function,(void *)&amp;a); \tif(thr_id&lt;0){ \t\tperror(\"thread create error : \"); \t\texit(0); \t}  \t// 식별번호 p_thread를 가지는 스레드를 detach \t// 시켜준다. \tpthread_detach(p_thread); \tpause(); \treturn 0; }   Synchronization  mutex 잠금       Race condition(경쟁 상태)            둘 이상의 프로세스/Thread가 동시에 어떤 작업을 수행 시, 타이밍 등에 의해 의도치 않은 결과가 나올 수 있는 상태           Critical Section(임계 영역)            둘 이상의 프로세스/Thread가 동시에 접근하면 안되는 공유데이터를 접근하는 코드 영역       즉, Race Condition을 발생 시킬 수 있는 코드 영역                 Race condition을 해결하기 위한 간단한 방법: Lock mechanism            Thread가 critical section code에 진입할 수 있는 열쇠를(Lock을 획득) 얻어야 Critical section code에 진입할 수 있다.             Mutex을 이용한 동기화에서는 Mutex가 lock의 역할을 한다.         Mutex사용을 위해서는 다음의 4가지 함수가 필요하다.            Mutex 잠금객체를 만드는 함수       Mutex 잠금을 얻는 함수       Mutex 잠금을 되돌려 주는 함수       Mutex 잠금객체를 제거하는 함수             mutex는 아래 요소들을 보장함으로써 임계영역(Critical Section)을 잠금다.            Atomicity: mutex 잠금은 최소단위 연적 - Atomic operation - 을 보장한다.                    Atomic operation은 일련의 연산 즉 mutex 잠금 연산이 끝날 때까지 다른 프로세스가 그 연산의 변화를 알 수 없는 상태가 되는 연산                       전체 연산 중 하나라도 실패할 경우 모든 연산이 실패하며, 시스템은 전체 연산이 시작하기 전의 상태로 복구된다.       Singularity: 한 스레드가 뮤택스 lock을 획득했다면, 이 스레드가 뮤택스 잠금을 내놓기 전까지는 다른 스레드가 뮤텍스 lock을 얻을 수 없도록한다.       None Busy Wait: 성능 관련, Busy wait (X)           pthread_mutex_init      pthread_mutex_init()으로 잠금 객체를 만든다.   #include &lt;pthread.h&gt;  pthread_mutex_t mutex; // mutex object  int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutex_attr *attr);                  parameter       Description                 *mutex       mutex 잠금객체                 *attr       mutex type 결정, () 매크로 fast (PTHREAD_MUTEX_INITIALIZER): 하나의 스레드가 하나의 잠금만을 얻을 수 있는 일반적 형태  recursive (PTHREAD_RECURSIVE_MUTEX_INITIALIZER): 잠금을 얻은 스레드가 다시 잠금을 얻을 수 있다. 이 경우 잠금에 대한 카운트가 증가하게 된다.  error checking (PTHREAD_RECURSIVE_MUTEX_INITIALIZER):   NULL: 기본값 fast           선언 방법 1.     pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;   선언 방법 2.     pthread_mutex_t mutex; pthread_mutex_init(&amp;mutex, NULL);   pthread_mutex_destroy    #include &lt;pthread.h&gt;  int pthread_mutex_destroy(pthread_mutex_t *mutex);     기능: mutex 객체 파괴. 주의!!: locked mutex를 파괴 시도 시, EBUSY 에러 코드                  return       Value                 성공       0                 실패       errno              뮤텍스를 사용할 일이 없다면 제거(free)하자.   pthread_mutex_{,try_}lock    #include &lt;pthread.h&gt;  int pthread_mutex_lock(pthread_mutex_t *mutex);     pthread_mutex_lock으로 lock을 요청한다.   만약 lock을 선점한 스레드가 있다면, 요청한 스레드는 대기 상태가 된다.   #include &lt;pthread.h&gt;  int pthread_mutex_try_lock(pthread_mutex_t *mutex);     만약 잠금을 얻을 수 있는지만 체크하고 대기(블럭)상태로 되지 않고 다음 코드로 넘어가야한다면..   pthread_mutex_unlock    #include &lt;pthread.h&gt;  int pthread_mutex_unlock(pthread_mutex_t *mutex);     mutex lock을 되돌려준다.   뮤텍스 잠금 예제    #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt;  int ncount; // 스레드가 공유되는 자원 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; // 스레드 초기화  /* mutex object를 전역으로 선언해 어디서든 사용될 수 있게 하자. */  // 스레드 함수 1 void* do_loop(void *data){ \tint i; \tpthread_mutex_lock(&amp;mutex); // 뮤텍스 락 \tfor(i=0;i&lt;10;i++){ \t\tprintf(\"loop1 : %d \",ncount); \t\tncount ++; \t\tsleep(1); \t} \tpthread_mutex_unlock(&amp;mutex); // 잠금을 해제 }  // 스레드 함수 2 void *do_loop2(void *data){ \tint i;  \t/* 잠금을 얻으려고 하지만 do_loop에서 이미 잠금을 얻었으므로 \t   잠금이 해제될때까지 기다린다. */ \tpthread_mutex_lock(&amp;mutex); // 잠금을 생성한다. \tfor(i=0; i&lt;10; i++){ \t\tprintf(\"loop2 : %d \", ncount); \t\tncount++; \t\tsleep(1); \t} \tpthread_mutex_unlock(&amp;mutex); // 잠금 해제 }  int main(void){ \tint thr_id; \tpthread_t p_thread[2]; \tint status; \tint a = 1;  \tncount=0; \tthr_id=pthread_create(&amp;p_thread[0], NULL, do_loop, (void *)&amp;a); \tsleep(1); \tthr_id=pthread_create(&amp;p_thread[1], NULL, do_loop2, (void *)&amp;a);  \tpthread_join(p_thread[0], (void *)&amp;status); \tpthread_join(p_thread[1], (void *)&amp;status);  \tstatus=pthread_mutex_destroy(&amp;mutex); \tprintf(\"code = %d\\n\", status); \tprintf(\"programing is end\\n\"); \treturn 0;  }      pthread API II.  pthread_exit(): 현재 실행 중인 스레드 종료          주의!!　Mutex 영역에서 pthread_exit()가 호출되어 버릴 경우, 다른 스레드는 영원히 block 될 수 있다.   pthread_cleanup_push(): 스레드 종료시 호출할 루틴    #include &lt;pthread.h&gt;  void pthread_cleanup_push(void (*routine) (void *), void *arg);     기능: cleanup handler를 인스톨한다.            pthread_exit()가 호출되어 스레드 종료시, pthread_cleanup_push()에 의해 인스톨된 함수가 호출된다.       routine이 스레드가 종료될때 호출되는 함수. arg는 아규먼트이다.       cleanup handler 는 자원을 돌려주거나, Mutex 잠금 등의 해제를 위한 용도로 사용                    Mutex 영역에서 pthread_exit()가 호출되어 버릴 경우, 다른 스레드는 영원히 block 될 수 있다.           malloc으로 할당 받은 메모리, 열린 fd를 닫기 위해서로 사용한다.                           pthread_cleanup_pop(): cleanup handler제거    #include &lt;pthread.h&gt;  void pthread_cleanup_pop(int execute);     기능            execute == 0, pthread_cleanup_push() 에 의해 인스톨된 cleanup handler를 실행치 않고, 삭제만 시킨다.       execute != 00, cleanup handler를 실행하고, 삭제한다.           &lt;주의!&gt; pthread_cleanup_push()와 pthread_cleanup_pop()은 반드시 같은 함수 내의 같은 레벨의 블럭에서 한 쌍으로 사용   pthread_cleanup_{push,pop}() 예제       pthread_self():    #include &lt;pthread.h&gt;  pthread_t pthread_self(void);     기능: pthread_self 를 호출하는 현재 스레드의 스레드 식별자를 되돌려준다.   #include &lt;stdio.h&gt; #include &lt;pthread.h&gt;  void *func(void *a){ \tpthread_t id; \tid=pthread_self(); // 스레드 함수 자신의 pthread id \tprintf(\"pthread id in thread func: %ld\\n\", id); }  int main(int argc, char *argv[]){ \tpthread_t p_thread[2]; \tpthread_create(&amp;p_thread[0], NULL, func, (void *)NULL); \tprintf(\"pthread id in main: %ld\\n\", p_thread[0]); \tpthread_create(&amp;p_thread[1], NULL, func, (void *)NULL); \tprintf(\"pthread id in main: %ld\\n\", p_thread[1]);  \treturn 0; }   ","categories": ["thread"],
        "tags": [],
        "url": "https://markyang920413.github.io//thread/system_programming-thread-thread_1/",
        "teaser": null
      },{
        "title": "파일시스템 API <5> 임시파일 생성, 파일삭제, 변경 tmpnam(), tmpfile(), remove(), rename()",
        "excerpt":"임시파일 생성     임시파일은 /tmp 에 만들어진다.   보통은 모든 응용프로그램들이 사용해야 하므로 권한은 777이다.            하지만 root가 만들어 놓은 임시파일을 다른 유저가 접근하면 안된다.           UNIX는 stikey bit 도입하여 문제 해결            누구나 자신의 파일을 만들 수 있지만, 자신의 권한이 아닌 파일에는 접근 못하게한다.           UNIX에서 아래와 같이 랜덤하게 임시파일 이름을 만드는 함수를 제공한다.   #include &lt;stdio.h&gt;  char *tmpnam(char *s); FILE *tmpfile(void);     tmpnam을 사용하면 절대 경로를 가지는 랜덤한 이름의 파일 이름을 아규먼트로 되돌려 준다.            ex) \"/tmp/file8pwCL\"           tmpfile은 임시 파일을 read/write모드로 생성하고, 여기에 대한 파일 스트림 포인터를 되돌려준다.            이 파일은 프로그램이 종료될 때 자동적으로 삭제된다.       만약 유일한 파일이름이 만들어지지 않는다면 NULL을 되돌려준다.           #include &lt;stdio.h&gt;  int main(){ \tchar name[255]; \tint i; \tmkstemp(name); \tprintf(\"%s\\n\",name); }   파일 지우기 및 이름 변경   #include &lt;stdio.h&gt;  int remove(char *path); int rename(char *oldpath, const char *newpath);     remove: 파일 삭제   rename: 파일 이름 변경  ","categories": ["file"],
        "tags": [],
        "url": "https://markyang920413.github.io//file/system_programming-file-filesystemAPI_5/",
        "teaser": null
      },{
        "title": "Signal <2> RTS",
        "excerpt":"POSIX RTS  RTS      RTS: 비동기(asynchronous) 이벤트를 전달하기 위한 목적, 실시간성 유지하며 대기열부재 문제를 해결.            polling에 비해 월등한 성능 향상                    select, poll과 같은 I/O 방식은 메시지가 도착하기를 계속 체크방식           poll은 이벤트를 받기 위해 커널 스페이스 -&gt; 유저스페이스로 이벤트를 복사한다.           업데이트된 이벤트 리스트를 유저스페이스 -&gt; 커널스페이스로 다시 복사           즉, 하나의 이벤트를 전달받기 위해 2번의 복사가 일어난다.                           UNIX 표준 시그널은 시그널 발생 시, 단지 시그널 전달 사실+ 시그널 번호만 알 수 있다.            표준 시그널은 시그널의 대기열 유지 불가, 시그널 핸들러가 리턴되기 전에 여러 개의 동일한 시그널이 전달되면 그 중 하나의 시그널만 전달될 뿐이며 나머지 시그널은 잃어 버린다.           RTS는 구조체에 시그널 관련 여러 정보 포함해 전달            RTS는 시그널 대기열 유지 가능하여, 동시에 여러 시그널이 전달되어도 대기열에 담아둘 수 있다.           struct siginfo는 sigaction 구조체 내 sa_sigaction에서 사용된다.   typedef struct siginfo{ \tint si_signo;\t/* Signal number */ \tint si_errno;\t/* Error code */ \tint si_code; \tpid_t si_pid; \tuid_t si_uid; \tvoid *si_addr; \tunion sigval si_value; \tunion { \t\t/* Skipping other fields */ \t\tstruct { \t\t\tint _band;\t/* Socket event flags (similar to poll) */ \t\t\tint _fd;\t/* Socket fd where event occurred */ \t\t} _sigpoll; \t} _sifields; } siginfo_t;  #define si_fd\t_sifields._sigpoll._fd     위 구조체를 보면 시그널 번호, 어떤 소켓에서 이벤트를 발생시켰는지 등의 정보를 포함한다.                  struct siginfo_t의 멤버       description                 si_signo       시그널 번호                 si_errno       errno 값                 si_code       시그널을 받았을 때 어떤 이유로 시그널이 발생했는지 관련된 값 SI_ASYNCIO: 소켓으로 비동기 입출력 이벤트 발생 SI_QUEUE: sigqueue()함수를 통한 시그널 발생 SI_TIMER: 시간 초과 SI_USER: kill()함수 등에 의한 시그널 발생                 si_pid       시그널을 발생시킨 PID                 si_uid       시그널을 발생시킨 프로세스의 UID로, si_code가 SI_USER일 경우에만 값이 설정된다.                 si_status       자식 프로세스에서 SIGCHLD시그널이 발생시키고 종료했을 경우 자식 프로세스의 종료 값                 si_value       sigqueue()함수를 이용해서 시그널을 발생시킬 경우 사용자가 보낸 값이 저장된다.                 si_addr       메모리 참조주소의 포인터를 포함. 이것은 SIGSEGV, SIGBUS, SIGILL, SIGFPE 등이 발생했을 때만 적용된다.                 si_fd       이벤트를 발생시킨 file discriptor           typedef union sigval{ \tint sival_int; \tvoid *sival_ptr; } sigval_t;   RTS 지원 확인     kill -l 커맨드로 확인한다.            1~31: UNIX 표준 시그널       32~63: RTS를 위해 예약된 영역, 이 중 하나를 사용하면된다.           [root@joinc /root]# kill -l   1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL   5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE    9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2    13) SIGPIPE     14) SIGALRM     15) SIGTERM     17) SIGCHLD   18) SIGCONT     19) SIGSTOP     20) SIGTSTP     21) SIGTTIN   22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ   26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO   30) SIGPWR      31) SIGSYS      32) SIGRTMIN    33) SIGRTMIN+1   34) SIGRTMIN+2  35) SIGRTMIN+3  36) SIGRTMIN+4  37) SIGRTMIN+5   38) SIGRTMIN+6  39) SIGRTMIN+7  40) SIGRTMIN+8  41) SIGRTMIN+9   42) SIGRTMIN+10 43) SIGRTMIN+11 44) SIGRTMIN+12 45) SIGRTMIN+13   46) SIGRTMIN+14 47) SIGRTMIN+15 48) SIGRTMAX-15 49) SIGRTMAX-14   50) SIGRTMAX-13 51) SIGRTMAX-12 52) SIGRTMAX-11 53) SIGRTMAX-10   54) SIGRTMAX-9  55) SIGRTMAX-8  56) SIGRTMAX-7  57) SIGRTMAX-6   58) SIGRTMAX-5  59) SIGRTMAX-4  60) SIGRTMAX-3  61) SIGRTMAX-2   62) SIGRTMAX-1  63) SIGRTMAX                           RTS를 통한 네트워크 I/O 처리  RTS API      select없이 소켓에 이벤트 시그널이 발생한 것 어떻게 아는가?   소켓파일이 RTS에 반응하도록 한다.            fcntl()을 사용한다.                    해당 소켓을 논 블럭+비동기로 셋팅           시그널 번호 &gt;= SIGRTMIN (SIGRTMIN 부터 RTS 시그널 가능)              int sockfd = accept(...);   \"소켓을 논블럭, 비동기로 설정한다.\"  fcntl(sockfd, F_SETFL, O_RDWR | O_NONBLOCK | O_ASYNC);   \"SIGRTMIN보다 더 큰 RTS시그널이 전달되도록 한다.\"  fcntl(sockfd, F_SETSIG, SIGRTMIN);   \"시그널을 보낼 프로세스 ID를 설정한다. 여기서는 자기 프로세스로 보내도록 했다.\"  fcntl(sockfd, F_SETOWN, getpid());  fcntl(sockfd, F_SETAUXFL, O_ONESIGFD);                                                   위 설정으로 소켓 fd는 SIGRTMIN 이벤트 감지 가능   이제, 소켓에 RTS가 통지되었을 때 필요한 작업을 하도록 코드를 추가            RTS가 통지되었는지 확인하는 함수가 필요하다.       UNIX는 sigwaitinfo()와 sigtimedwait()함수를 제공하며, 이 함수들로 RTS통지 확인           #include &lt;signal.h&gt;    int sigwaitinfo(const sigset_t *set, siginfo_t *info);   int sigtimedwait(const sigset_t *set, siginfo_t *info, const struct timespec *timeout);   int sigqueue(pid_t pid, int sig, const union sigval value);                             set은 기다릴 시그널 정보가 설정되는 구조체           set에 설정한 시그널이 통지되면 해당 정보가 info에 복사된다.                            sigtimewait()는 기다리는 시간을 설정할 수 있다는 점을 제외하고는 sigwaitinfo()와 완전 동일                                   사용법은 아래 UDP에서 RTS 블록으로 정보 얻기 참고                           kill()이 시그널을 보내는 것 처럼, RTS Signal도 다른 프로세스로 시그널을 보낼 수 있는데 바로 sigqueue()이다.   UDP에서 RTS 블록으로 정보 얻기          sigaddset()을 이용해서 RTS를 대응하도록 설정. sigprocmask()을 이용해서 동일한 RTS가 들어왔을 때, 인터럽트가 걸리지 않고 블럭되도록 설정한다.            만약 sigprocmask()를 사용해서 RTS를 블럭하지 않는다면 sigwaitinfo()가 호출되어 RTS를 기다리기 전에 RTS가 프로세스로 전달될 경우 프로세스에 인터럽트가 걸리고 프로세스는 종료되어 버릴 것이다.           소켓 fd를 fcntl()을 이용해 RTS에 대응하도록 만든다.   sigwaitinfo()를 통해 RTS를 기다린다. 소켓에 이벤트발생 시, RTS가 전달 되고, sigwaitinfo()는 리턴한다. 리턴 시, siginfo를 채워 이벤트 발생한 파일과 정보등을 담는다.   siginfo 정보를 이용해 어느 소켓, 어떤 이벤트 발생했는지 파악해 데이터 통신   프로세스간 신호 전달  sigqueue():2      RTS는 파일에 대한 좋은 이벤트 전달 도구 이기도 하지만, 프로세스간 신호 전달 목적으로도 사용가능하다.            장점: 시그널이 대기열에 쌓이므로 잃어버릴 염려 없다. 부가적인 정보 전달 가능하다.           sigqueue(): 다른 프로세스로 RTS 전달   sifinfo_t 구조체의 sigvalue로 부가적인 정보 전달       union sigval{       int sival_int;       void *sival_ptr;   }                 sival_int는 int형 값 전달 위해 사용       *sival_ptr는 주소값을 전달하기 위해 사용한다고 되어 있는데, 실제 어디에 사용가능한지 확인 할 수 없다.           sigaction의 sa_falgs를 SA_SIGINFO로 sigaction 참고설정하고 적당한 시그널 핸들러를 등록하기만 하면된다. 그리고 RTS가 전달되었을 경우 si_code가 SI_QUEUE인지를 확인하고 원하는 작업을 하면 된다.            확인하는 이유는 RTS가 아닌 표준 시그널이 도착할 수 있고, 이를 구별해서 작업해야할 필요가 있기 때문이다.           RTS 반응 App 예제  rcv_rts.c       snd_rts.c       RTS 대기열의 크기에 따른 문제     RTS 대기열의 크기는 무한하지 않다.            대기열이 다차지않게 해야한다.       RTS 대기열은 프로세스 단위로 유지된다.                    클라이언트의 데이터량을 계산해서 RTS+스레드, RTS+fork의 식으로 서버를 작성하라(스레드/프로세스 풀 사용).                           RTS 대기열 Overflow            Overflow가 발생할 수 있다.                    RTS overflow 발생 시, 프로세스로 SIGIO 시그널이 전달된다.           SIGIO 시그널 핸들러를 등록해 이벤트 발생시 복구 작업                            모든 소켓에 대한 RTS대응을 하지 않도록 설정               모든 시그널 대기열로 부터 모든 시그널을 제거               잃어버린 소켓 이벤트를 복구                                                      시그널 대기열에 있는 소켓 fd 당 하나의 이벤트만 허용하도록 커널 수정            fcntl을 사용하여 하나의 소켓당 하나의 이벤트가 대기열에 들어가도록 조작                    fcntl(sockfd, F_SETAUXFL, O_ONESIGFD);                           예제      ","categories": ["signal"],
        "tags": [],
        "url": "https://markyang920413.github.io//signal/system_programming-signal-signal_2/",
        "teaser": null
      },{
        "title": "thread <2> cond 조건변수, attribute, signal, cancel",
        "excerpt":"pthread API III: cond  cond      스레드가 3개있다고 가정한다.            main 스레드                    스레드 1, 2를 생성하고 join한다.                       스레드 1                    2개의 int형 멤버를 가진 구조체에 접근해 특정한 숫자를 입력                       스레드 2                    구조체에 접근해 멤버를 읽어와 “덧셈”하고 이를 화면에 출력한다.                           critical section            스레드들이 동시에 접근하는 영역                    구조체 영역: 스레드 1과 2가 접근하는 영역 -&gt; Mutex 필요                           cond            스레드 2는 스레드 1에 의해 구조체의 값이 변경되는 것을 감지해야함                    변경이 감지된 후 구조체에 접근해야함           변경될 때까지 기다려야한다.                            이 “기다림”이 조건변수 cond 필요함                                   cond은 마치 시그널을 주고 받는 것과 같다.                             cond 사용의 이점            cond를 사용하지 않으면, 스레드 2는 busy wait해야한다.                스레드 2 에서 wait로 BLOCK한걸 다른 스레드의 signal이 깨워줌!   \"thread 1\" { \tmutex lock 얻음 \t// 임계영역 시작 =========================================== \t구조체에 접근해서 값 변경 \tpthread_cond_signal \t// 임계영역 끝 ============================================= \tmutex unlock }  \"thread2\" { \tmutex lock 얻음 \t// 임계영역 시작 =========================================== \tpthread_cond_wait \tif( cond_signal 왔다면){ \t\t구조체 값 더함 \t} \t// 임계영역 끝 ============================================= \tmutex unlock }  cond 주의사항      과연 신호가 실시간으로 전달 될 것을 신뢰할 수 있는가?            스레드 1이 스레드 2가 신호를 잘 받았는지 확인X 진행             위 예제를 while文으로 돌리면 예상치 못한 결과가 발생            스레드 1이 빨리 한번 더 돌아 작업을 한번 더 한 뒤, 스레드 2가 작업할 수도 있음             따라서 양방향으로 signal을 주고 받자   pthread_cond_init()    #include &lt;pthread.h&gt;  int pthread_cond_init(pthread_cont_t *cond, const pthread_cond_attr *attr);     기능: pthread_cond_init()은 조건 변수(condition variable)cond를 초기화하기 위해 사용한다.            attr 을 이용해서 조건 변수의 특성을 변경할 수 있다.       NULL을 주면, 기본특성으로 초기화한다.       조건 변수(condition variable)cond는 상수 PTHREAD_COND_INITIALIZER를 이용해서도 초기화할 수 있다.           #include &lt;pthread.h&gt;  pthread_cond_t cond = PTHREAD_COND_INITIALIZER; // 둘 다 동일한 기능 pthrad_cond_init(&amp;cond, NULL);   pthread_cond_signal()    #include &lt;pthread.h&gt;  int pthread_cond_signal(pthread_cont_t *cond);     기능: 조건 변수(condition variable) cond 에 시그널을 보낸다.            시그널을 보낼 경우 cond 에서 기다리는(wait) 스레드가 있다면 스레드를 깨운다.                    여러 스레드가 기다리고 있다면 그 중 하나의 스레드에게만 전달되며 어떤 스레드에 신호가 전달될지 알 수 없다.                       cond 를 기다리는 스레드가 없다면, 아무 일도 일어나지 않는다.           pthread_cond_broadcast()    #include &lt;pthread.h&gt;  int pthread_cond_broadcast(pthread_cont_t *cond);     기능: 조건 변수 cond 에서 기다리는(wait) 모든 스레드에게 시그널을 보내 깨운다.   pthread_cond_wait()    #include &lt;pthread.h&gt;  int pthread_cond_wait(pthread_cont_t *cond, pthread_mutex_t *mutex);     기능: 조건 변수 cond 를 통해 신호가 전달될 때까지 블럭된다.            신호가 전달되지 않으면, 영원히 블럭된다.       pthread_cond_wait()는 블럭되기 전에 mutex잠금을 자동으로 돌려준다.       블럭에서 깨면 mutex 획득              pthread_cond_timedwait()    #include &lt;pthread.h&gt;  int pthread_cond_timedwait(pthread_cont_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);     기능: 조건 변수 cond 를 통해 신호가 전달될 때까지 블럭되고, 자동으로 Mutex를 돌려준다는 점에서 pthread_cond_wait()와 동일            abstime시간 동안 신호가 도착하지 않는다면 error를 발생하면서 리턴                    ETIMEDOUT: errno가 아닌 리턴 값으로 에러가 넘어옴!                       pthread_cond_timedwait()함수는 다른 시그널에 의해 interrupted될 수 있으며(EINTR) 이 상황에 대한 처리 해야한다.           pthread_cond_destroy()    #include &lt;pthread.h&gt;  int pthread_cond_destroy(pthread_cont_t *cond);     기능: pthread_cond_init()으로 생성된 조건 변수 cond 자원 해제            pthread_cond_destroy() 함수를 호출하기 전에 어떤 스레드도 cond 에서의 시그널을 기다리지 않는 걸 확인해야 한다.       cond 시그널 을 기다리는 스레드가 존재하면, 이 함수는 실패하고 EBUSY를 리턴한다.           cond example         pong 스레드 실행 후 바로 wait   ping 스레드 실행 후 \"ping\" 출력 후 signal 보내고 sleep   주의! pong 이 먼저 실행되야 하기 때문에, &amp;sync_cond로 제어   pthread API IV: Attribute  pthread_attr_init():    #include &lt;pthread.h&gt;  int pthread_attr_init(pthread_attr_t *attr);     pthread_attr_init은 attr 을 디폴트 값으로 초기화 시킨다.   성공 0, 실패 -1   pthread_attr_destroy():    #include &lt;pthread.h&gt;  int pthread_attr_destroy(pthread_attr_t *attr);     attr 객체 제거   pthread_attr_getscope()    #include &lt;pthread.h&gt;  int pthread_attr_getscope(const pthread_attr_t *attr, int *scope);     스레드가 어떤 영역(scope)에서 다루어지고 있는지 얻어오기 위해 사용            PTHREAD_SCOPE_SYSTEM: user 모드 스레드                    LINUX에서는 스레드 라이브러리를 통해 스케줄링하는 user 모드 스레드                       PTHREAD_SCOPE_PROCESS: kernel 모드 스레드                    Solaris에서는 커널 모드 스레드                           #include &lt;stdio.h&gt; #include &lt;pthread.h&gt;  int main(void){ \tpthread_attr_t pattr; \tint scope;  \tpthread_attr_init(&amp;pattr); \tpthread_attr_getscope(&amp;pattr, &amp;scope); \tif (scope == PTHREAD_SCOPE_SYSTEM) \t\tprintf(\"user mode thread\\n\") \telse if (scope == PTHREAD_SCOPE_PROCESS) \t\tprintf(\"kernel mode thread\\n\"); \treturn 0; }   pthread_attr_setscope    #include &lt;pthread.h&gt;  int pthread_attr_setscope(pthread_attr_t *attr, int scope);     기능: 스레드가 어떤 영역(scope)에서 작동하게 할 것인지 결정            LINUX는 user mode에서만 동작한다.       Solaris는 둘다 선택 가능하다.           #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt;  int main(void){ \tpthread_attr_t pattr; \tint scope; \tpthread_attr_init(&amp;pattr);  \tpthread_attr_setscope(&amp;pattr, PTHREAD_SCOPE_PROCESS); \tpthread_attr_getscope(&amp;pattr, &amp;scope); \tif(scope == PTHREAD_SCOPE_SYSTEM) \t\tprintf(\"user mode thread\\n\"); \telse if(scope == PTHREAD_SCOPE_PROCESS) \t\tprintf(\"kernel mode thread\\n\");  \treturn 0; }   pthread_attr_getdetachstate   #include &lt;pthread.h&gt;  int pthread_attr_getdetachstate(pthread_attr_t *attr, int detachstate);     기능: 스레드가 join가능 한지, detached 상태인지 알아낸다. 알아낸 값은 detachstate에 저장된다.            PTHREAD_CREATE_JOINABLE: (default), 스레드가 join 가능함       PTHREAD_CREATE_DETACHED: 스레드가 pthread_detach를 이용해서 생성되었거나 혹은 pthread_attr_setdetachstate()함수를 이용해서 스레드를 detache 상태로 변경 시켰을 경우           #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt;  pthread_attr_t attr; void *test(void *a){ \tint policy; \tprintf(\"Thread create\\n\"); \tpthread_attr_getdetachstate(&amp;attr, &amp;policy); \tif(policy == PTHREAD_CREATE_JOINABLE) \t\tprintf(\"joinable\\n\"); \telse if (policy == PTHREAD_CREATE_DETACHED) \t\tprintf(\"detache\\n\"); }  int main(void){ \tint status; \tpthread_t p_thread; \tpthread_attr_init(&amp;attr); \tif(pthread_create(&amp;p_thread, NULL, test, (void *)NULL)&lt;0){ \t\tperror(\"pthread_create error: \"); \t\texit(1); \t} \tpthread_join(p_thread, (void **)&amp;status);  \treturn 0; }   pthread_attr_setdetachstate    #include &lt;pthread.h&gt;  int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);     기능: 스레드의 상태를 PTHREAD_CREATE_JOINABLE 혹은 PTHREAD_CREATE_DETACHED로 변경   ...  pthread_attr_t attr;  \"JOINABLE 상태로 변경\" pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);  \"DETACHED 상태로 변경\" pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);   pthread API V: signal  pthread_sigmask()    #include &lt;pthread.h&gt; #include &lt;signal.h&gt;  int pthread_sigmask(int how, const sigset_t *newmask, sigset_t *oldmask);     기능: 스레드는 시그널 공유 따라서 프로세스에서 스레드로 시그널을 전달하면, 모든 스레드로 시그널이 전달된다.            특정 스레드만 시그널을 받도록 하고 싶을 때 사용한다.           pthread_kill()    #include &lt;pthread.h&gt; #include &lt;signal.h&gt;  int pthread_kill(pthread_t thread, int signo);     기능: 스레드 식별 번호 thread 로 시그널 signo를 전달한다.   sigwait()    #include &lt;pthread.h&gt; #include &lt;signal.h&gt;  int sigwait(const sigset_t *set, int* signo);     기능: set, signo   pthread API VI: cancel  pthread_cancel()    #include &lt;pthread.h&gt;  int pthread_cancel(pthread_t thread);   pthread_setcancelstate()    #include &lt;pthread.h&gt;  int pthread_setcancelstate(int state, int *oldstate);   pthread_setcanceltype()    #include &lt;pthread.h&gt;  int pthread_setcanceltype(int type, int *oldtype);   pthread_testcancel()    #include &lt;pthread.h&gt;  void pthread_testcancel(void);   ","categories": ["thread"],
        "tags": [],
        "url": "https://markyang920413.github.io//thread/system_programming-thread-thread_2/",
        "teaser": null
      },{
        "title": "thread <3> Thread Pooling",
        "excerpt":"조건 변수 이용 Thread Pool  개념      thread pool?            미리 스레드를 할당시켜 놓는 기법       요청 -&gt; pthread_create()의 반복은 생각보다 overhead       따라서 미리 100여 개의 스레드를 만들어 두고 연결하는 방식이라 생각하면 된다.              다중 접속 네트워크 프로그램            지정된 수만큼 미리 스레드 만듬           　　　　　\t   　빨간 스레드: 작업 중인 스레드  　노란 스레드: 휴식 중인 스레드 \t- accept()로 클라이언트 연결을 가져오면, 휴식 중인 스레드를 하나 깨운다. 이 때, 연결 소켓 get!!!        스레드 풀 구현에서 중요한 것            작업 지시가 있을때 까지 자식 스레드 블럭                    자식 스레드는 pthread_cond_wait()로 부모 스레드가 깨울때까지 대기           부모 스레드가 깨우는 시점                            accept()함수가 반환하는 시점               pthread_cond_ signal()을 이용해 자식 깨움                                               해당 자식 스레드 블럭이 풀려서 작업 중일 때는 해당 자식 스레드를 호출하지 않도록 할 것                    해당 자식 스레드가 블럭이 풀려서 작업 중인 것을 어떻게 아는가?                            pthread_mutex_trylock()을 실시                                    부모 프로세스가 진입 가능함: 자식스레드는 노는 중                   부모 프로세스 진입 불가: 자식 스레드 작업중 -&gt; 호출 금지                                                                                      자료구조      부모스레드와 자식스레드가 공유            이 자료구조는 자식 스레드 갯수만큼 생성해야 하므로 배열로 관리한다(cpp vector).           class ThreadInfo{ \tprivate: \t\tpthread_cond_t mcond;\t\"스레드가 사용할 조건변수\" \t\tpthread_mutex_t mmutex;\t\"스레드가 사용할 뮤텍스\" \t\tint msocket; \tpublic: \t\tThreadInfo(pthread_cond_t, pthread_mutex_t); \t\tint TryLock();\t\"조건변수와 함께 사용할 뮤텍스 잠금을 얻기위한 메서드\" \t\tint Job();\t\"자식 스레드가 수행할 코드를 가진 메서드\" \t\tint UnLock();\t\"자식 스레드가 작업을 마치고 잠금을 되돌려주기 위해 사용\" };  vector&lt;ThreadInfo&gt; ThreadList;   스레드 풀 프로세스      스레드 풀 프로세스: 네트워크 서버            스레드 풀 만든다.       지정한 갯수만큼 스레드 풀 만든다.           메인 스레드와 자식 스레드는 ThreadInfo클래스로 조건변수와 뮤텍스를 공유한다.   스레드는 조건변수와 뮤텍스를 초기화 하고, Job메서드를 실행한다. Job메서드는 대략 다음과 같다.   Job(){ \tGetLock(&amp;mutex);\t\t\"잠금을 얻는다.\" \twhile(1){ \t\t\"조건 변수로 기다린다. 조건 변수를 기다리면서 mutex잠금을 내놓으면, \t\t부모 스레드는 mutex 잠금을 얻을 수 있는 상태가 된다. \t\t이는 선택한 자식 스레드가 작업을 할 수 있는 상태를 의미한다.\" \t\tpthread_cond_wait(&amp;cond, &amp;mutex); \t\t\"부모 스레드가 cond_signal을 전송하면, _cond_wait는 반환하고 잠금을 얻는다\"  \t\t\"작업을 한다.\"  \t\t\"작업을 마치면, while 문 처음으로 가서 pthread_cond_wait를 호출한다.\" \t} }     작업을 하는 동안은 자식스레드가 뮤텍스 잠금을 얻은 상태이므로 부모는 trylock 메서드를 호출하는 것으로 이 스레드가 작업 중임을 알 수 있다.   작업을 마치면 다시 조건변수에서 기다린다.   반복 …   이 방식은 자식스레드가 잠금 권한을 가지고 실행하기 때문에, 동기화 문제에서 자유롭다는 장점을 가진다.  자식 스레드는 단지 pthread_cond_wait()를 호출할 때만 Unlock!!! 잠금을 내놓는다.   리얼 타임 시그널 thread pool  스레드 정보 구조체 struct ph{ \tint sockfd;\t// 처리 중인 소켓 지정번호 \tint index_num;\t// 스레드의 인덱스 번호 };  스레드 구조체 MAP multimap&lt;int, struct ph&gt; phinfo;  struct schedul_info{ \tint client_num;\t// 총 연결중인 클라이언트 수 \tint current_sockfd;\t// 가장 최근에 연결된 소켓 지정 번호 \tphinfo mphinfo;\t// 스레드 구조체 multimap };  스레줄관련 자료구조 { \t현재 연결된 클라이언트 수 \t현재 처리해야될 클라이언트 소켓지시자  \t스레드 풀에 만들어진 스레드 상태: 스레드 풀 크기만큼의 배열 \t{ \t\t0 이면 휴식 상태 \t\t1 이면 작업 상태 \t\t처리 중인 소켓 지시자 \t} };  main함수 { \t아규먼트로 몇개의 스레드를 생성할지 받음 \twhile(스레드 생성수만큼){ \t\tpthread_create를 이용해 스레드 생성 \t\t{ // 통신 스레드 함수 \t\t\tWAIT: \t\t\tmain 스레드가 깨우길 기다린다. \t\t\t만약 main 스레드로 부터 깨움이 있다면 \t\t\t{ \t\t\t\t스케줄 자료구조 -&gt; 현재 처리해야될 소켓 지시자를 읽어온다. \t\t\t\t스케줄 자료구조 -&gt; 자신의 상태를 1로 셋팅 \t\t\t\t스케줄 자료구조 -&gt; 처리중인 소켓지시자를 셋팅 \t\t\t\twhile(1) \t\t\t\t{ \t\t\t\t\t클라이언트와 통신한다. \t\t\t\t\t만약 에러가 발생하면 \t\t\t\t\t{ \t\t\t\t\t\t스케줄 자료구조 -&gt; 처리 중인 소켓 지시자를 0으로 셋팅 \t\t\t\t\t\t스케줄 자료구조 -&gt; 자신의 상태를 0으로 셋팅 \t\t\t\t\t\t스케줄 자료구조 -&gt; 현재 연결된 클라이언트수 --; \t\t\t\t\t\tgoto WAIT: \t\t\t\t\t} \t\t\t\t} \t\t\t} \t\t} \t} }  // main 스레드 while(1) { \t만약 accept를 통해서 연결이 발생한다면 \t{ \t\t스케줄 관련 자료구조 -&gt; 현재 연결된 클라이언트 수가 MAX를 초과하지 않았다면 \t\t{ \t\t\t스케줄 관련 자료구조 -&gt; 현재 연결된 클라이언트 수 ++; \t\t\t스케줄 관련 자료구조 -&gt; 현재 처리해야될 클라이언트 소켓 지시자 = accept(); \t\t\t스케줄 관련 자료구조 -&gt; 스레드 풀에 만들어진 스레드 상태가 0인 스레드를 찾아서 해당 스레드 깨움 \t\t} \t\t초과 했을 경우 \t\t{ \t\t\t클라이언트에게 에러메시지를 전송한다. \t\t} \t} }     multimap의 key는 활성화 여부로 1, 0 이다. value는 스레드 정보가 될 것이다.            multimap은 정렬연관 컨테이너로 key를 기준으로 자동적으로 정렬된다.       첫번 째 스레드가 처리중(1)으로 변경되면, 이 원소는 multimap의 가장 뒤로 정렬된다.           예제       ","categories": ["thread"],
        "tags": [],
        "url": "https://markyang920413.github.io//thread/system_programming-thread-thread_3/",
        "teaser": null
      },{
        "title": "aliasing restrict pointer",
        "excerpt":"에일리어싱과 restrict 포인터     에일리어싱: 어떤 한 공간에 대해 복수 개의 접근 경로가 있는 경우를 의미한다.            *P: 포인터 P가 있고 그 객체가 100이라는 길이를 가진다고 가정한다.                    P+1 = Q라고 지칭한다면 이를 에일리어싱 되었다고 합니다.                         형변환(type casting)을 위한 최적화를 방해하거나 문제를 일으킬 소지도 있습니다.                    인수로 받아들이는 주소가 에일리어싱 되었을 때 오류를 방지 위해 미리 검사하는 행위 때문에 성능 저하가 발생           int *i_form 은 int형 변수를 에일리어싱하는 변수                              함수 인수가 다른 곳에서 참조하지 않음을 보장해주다면 1.내부적으로 병렬처리하거나 2.에일리어싱에 대한 검사를 하지 않아도 되므로 상당히 효율적으로 함수를 설계할 수 있다.   restrict 포인터     restrict 포인터: 최적화, 신뢰성 있는 코드를 위해..            API가 최적화나 신뢰성을 높이기 위해 독점적으로 인수로 넘어오는 메모리에 접근해야 할 필요성           \"과거 memcpy\" void *memcpy(void *dest, const void *src, size_t n);  \"C99 이후 memcpy\" void *memcpy(void *restrict s1, const void *restrict s2, size_t n);     restrict 포인터로 객체를 다른 공간에서 에일리어싱하지 않도록 강제함            implementation이 내부적으로 s1, s2 의 접근이 비순차, 비동기적으로 진행, 병렬처리 될 수 있음 암시       과거 memcpy는 비동기적 진행 X, 일일이 메모리 위치를 확인하는 작업도 한다. 이는 심각한 오버헤드 유발              에일리어싱을 사용하지 않음을 확신할 수 없다면, memcpy대신 memmove를 사용하도록 강요   int *p_num, *p_alias; p_num = (int *)malloc(sizeof(int) * 100); p_alias = p_num + 20; /* 에일리어싱 되었음 */  memcpy(p_num, p_alias, sizeof(int) * 50);     p_num, p_alias는 에일리어싱 되었으므로 restrict 포인터 룰 위반, 사이드 이펙트 발생 가능성  ","categories": ["c"],
        "tags": [],
        "url": "https://markyang920413.github.io//c/c-c-pointer/",
        "teaser": null
      },{
        "title": "기본 접근 권한 설정(umask), 특수 접근 권한",
        "excerpt":"기본 접근 권한     리눅스에서 파일, 디렉터리를 생성 시, 기본 접근 권한이 자동적으로 설정            일반 파일                    소유자: r, w           그룹, 기타 사용자: r                       디렉터리                    소유자: r, w, x           그룹, 기타 사용자: r, x                           $ touch ubuntu.txt $ mkdir temp $ ls -l drwxr-xr-x 2 user1 user1 4096 2월 16 03:00 temp -rw-r--r-- 1 user1 user1 0    2월 16 03:00 ubuntu.txt   umask: 기본 접근 권한 확인 및 설정   umask: 기본 접근 권한 확인 및 설정  umask [option] [mask value]   option:  \t-S:\t마스크 값을 문자로 출력한다.              umask의 값은 002, umask -S의 값은 u=rwx, g=rwx, o=rx 무슨말인가?       마스크 값의 의미            파일이나 디렉터리 생성 시 부여하지 않을 권한을 지정해 놓는 것       즉, 위 예제에서 002는 -------w-라는 뜻인데, other에겐 w 권한을 주지 않겠다는 뜻이다.             예시            umask값 022(000 010 010)라고 가정       chmod   666(110 110 110) 부여                 결과 110 100 100 = 644(rw- r– r–)           umask: 마스크 값을 변경해보자    $ umask [umask 값]  # example $ umask 077\t\t# umask 값을 077로 변경 $ umask\t\t\t# umask 값 참조 077\t\t\t# umask 값은 077   특수 접근권한     0777은 u=rwx, g=rwx, o=rwx인데, 그럼 맨 앞 0는 뭘까? 바로 특수 접근 권한이다.            보통은 0인데, 1, 2, 4 이면 특수 접근 권한이 설정된 것                              맨 앞자리       특수 권한 종류       Description                 4       SetUID       SetUID가 설정된 파일을 실행 시, 파일 실행한 사용자의 권한이 아니라 파일 소유자의 권한으로 실행할 수 있다.                 2       SetGID       SetGID가 설정된 파일을 실행 시, 파일 소유 그룹의 권한으로 실행된다.                 1       sticky bit       -           SetUID    $ touch set $ chmod 755 set $ ls -l set -rwxr-xr-x 1 user1 user1 0 2월 24 03:55 set  # 이제 SetUID 설정 해본다. $ chmod 4755 set $ ls -l set -rwsr-xr-x 1 user1 user1 0 2월 24 03:55 set     -rwsr-xr-x: SetUID 시, owner의 x -&gt; s로 바뀐다! set 파일을 실행하면, 항상 user1의 권한을 가지고 실행된다.   passwd명령은 SetUID된 명령(파일)이다. 실행해보자!   $ ls -l /usr/bin/passwd -rwsr-xr-x 1 root root 45420 7월 27 2013 /usr/bin/passwd     passwd는 사용자 계정의 암호를 바꾸는 것이다.            실제 암호가 저장된 파일은 /etc/shadow 파일은 root 계정으로 수정 가능하다.       일반 사용자는 shadow 파일을 바꿀 수 없기 때문에, passwd는 SetUID로 root권한으로 실행해 shadow파일을 수정할 수 있게한다.                SetGID    $ chmod 2755 set $ ls -l set -rwxr-sr-x 1 user1 user1 0 2월 24 03:55 set     -rwxr-sr-x: SetGID 시, group 부분의 x -&gt; s로 바뀐다! set 파일을 실행하면, 항상 소유 그룹의 권한으로 실행된다.        스티키 비트      디렉터리에 설정하는데, 디렉터리에 스티키 비트가 설정되어 있으면 이 디렉터리에는 누구나 파일을 생성할 수 있다.   owner는 파일을 생성한 계정   다른 사용자가 생성한 파일 삭제할 수 없다.   T가 표기된다.   /tmp 에서 사용된다.     $ ls -l | grep tmp drwxrwxrwt\t6\troot\troot\t4096\t2월 24 03:17\ttmp           스티키 set     $ chmod 1755 temp ls -ld temp drwxr-xr-t\t2\tuser1\tuser1\t4096\t2월 24 03:17\ttemp           drwxr-xr-t: 스티키 비트 set, other 부분의 x -&gt; t로 바뀐다.   &lt;주의!&gt;: 특수 권한을 설정하는 파일, 디렉터리 모두 실행 가능한 권한있어야 특수 권한 설정 가능     실행 권한이 없는데 SetUID, GetUID를 설정하면 s S가 표시된다.   실행 권한이 없는데 스티키 비트 를 설정하면 t T가 표시된다.  ","categories": ["linux-system"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-system/linux_linux-system_permission/",
        "teaser": null
      },{
        "title": "패딩(padding)/팩(pack)/XDR",
        "excerpt":"패딩     CPU Alignment 때문에, 특정 바이트 짝수 배수 정렬            구조체처럼 다양한 멤버 변수가 모이는 경우, 각 멤버 변수의 시작하는 주소를 특정한 짝수 바이트의 배수로 주소 경계 맞춤           struct my_st a{ \tchar str[9]; \tchar cnt[4]; } // 9 + 4 = 13Byte  struct my_st b{ \tchar str[9]; \tint cnt; } // 9 + (3) + 4 = 16Byte     이러한 주소 경계를 특정 단위의 배수로 정렬하는 규칙이 XDR(External Data Representation)            Sun Microsystems에서 요구하여 RFC로 제출되었다. (RFC 1014 -&gt; RFC 1832)       서로 다른 아키텍처 간에 데이터 교환 시, 버스 오류나 성능 저하 최소화           XDR, RFC 1832      서로 다른 아키텍처 간에 데이터 교환 시, 버스 오류나 성능 저하 최소화위한 데이터 표현 방식            intel은 2000년 부터 정렬되지 않은 메모리(misaligned memory) 접근에 대한 패널티 개선 현재는 intel 프로세서에 패널티가 없다. 그러나 다른 벤더의 프로세서들은 작동에 실패하거나 패널티가 클 경우가 있으니 주의              통신 데이터는 빅 엔디안이 디폴트   메모리 정렬(memory alignment) XDR은 기본 유닛의 크기를 4Byte로 경계한다.   정렬되지 않은 메모리 출력해본다.  int main(){ \tchar *p_buf; \tif ((p_buf = (char *)malloc(sizeof(char) * 65536)) == NULL) \t\treturn EXIT_FAILURE; \tmemcpy(p_buf, \"1234567890abc\", 13); // 문자열 13바이트 \tp_buf += 13; // p_buf를 p_buf에서 13바이트 이동 \t*((long *)p_buf)=123456; // long형 데이터 하나 저장 \t \treturn EXIT_SUCCESS; }   ","categories": ["file"],
        "tags": [],
        "url": "https://markyang920413.github.io//file/system_programming-file-padding_pack_XDR/",
        "teaser": null
      },{
        "title": "Samba 셋팅",
        "excerpt":"samba     Host: Mac OS   Remote: Ubuntu 20.04 LTS   samba install  samba install(Remote)   $ sudo apt install samba     삼바 계정을 추가하고, 계정에서 접근 가능한 디렉터리를 정한다.   $ sudo useradd -d [share directory] -m [삼바 계정] $ sudo useradd -d /home/pllpokko/share -m share_pllpokko      삼바 계정의 패스워드를 정한다.   $ sudo passwd [삼바 계정] $ sudo passwd share_pllpokko      삼바 공유 폴더에 접근할 아이디와 비밀번호를 설정   $ sudo smbpasswd -a [삼바 계정] $ sudo smbpasswd -a share_pllpokko         삼바 공유용 디렉터리 권한지정      samba configure 파일 설정       삼바서버 설정을 위한 /etc/samba/smb.conf 파일 수정   $ sudo vi /etc/samba/smb.conf  # smb.conf ----아래 맨 마지막 줄에 추가 ------------- [삼바 계정]  comment = samba directory  path = /home/pllpokko/share  writeable = yes  valid users = pllpokko -------------------저장 후 종료----------------------      $ sudo /etc/init.d/smbd restart      ip 얻기   $ ifconfig # eth0의 ip 구하기   host side      finder -&gt; Command + K -&gt; 서버 주소에 smb://[ip] 입력   ","categories": ["linux-system"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-system/linux_linux-system_samba/",
        "teaser": null
      },{
        "title": "프로세스 종류, ps 명령, kill, top, jobs, 작업 전환하기(bg, fg), nohup",
        "excerpt":"프로세스의 종류     daemon 프로세스            특정 서비스를 제공하기 위해 존재       커널에 의해 실행       평소 대기 상태 -&gt; 서비스 요청 -&gt; daemon이 해당 서비스 제공                    sshd: ssh 서버 대몬, 원격 접속 서비스를 제공하기 위해 동작                           고아(orphan) 프로세스            부모가 자식보다 먼저 종료되었을 때,                    부모 프로세스(killed) 자식 프로세스                       자식 프로세스는 고아 프로세스가 된다.       1번(UNIX, Ubuntu: init, Fedora 14: systemd) 대몬 프로세스가 이런 고아프로세스 자원을 회수한다.           Zombie프로세스            자식 프로세스의 자원이 회수 되지 않고 계속 프로세스 테이블에 존재할 때                    자식이 종료되었는 데도 남아 있을 수 있음!!!                       defunct 프로세스라고 나온다.       kill 명령으로 제거할 수 없다.       해결법                    SIGCHLD -&gt; 부모 프로세스로 보내 자식프로세스 정리           부모 프로세스 종료                            자식 프로세스는 고아 프로세스가 되고 1번 프로세스가 이를 처리                                                   프로세스 관리 명령     프로세스 목록 조회: ps                  option       description                 -e       시스템에서 실행 중인 모든 프로세스의 정보를 출력한다.                 -f       프로세스의 자세한 정보를 출력한다.                 -u UID       특정 사용자에 대한 모든 프로세스의 정보를 출력한다.                 -p PID       pid로 지정한 특정 프로세스의 정보를 출력한다.                 a       터미널에서 실행한 프로세스의 정보를 출력한다.                 u       프로세스 소유자의 이름, CPU Usage, 메모리 사용량 등 상세 정보 출력                 x       시스템에서 실행 중인 모든 프로세스 정보 출력                 --pid PID       지정한 특정 PID의 정보를 출력한다.           UID: 프로세스를 실행한 사용자 ID                   항목       Description                 UID       프로세스를 실행한 사용자ID                 PID       프로세스 ID                 PPID       이 프로세스의 부모 PID                 C       CPU 사용량(%값)                 STIME       프로세스의 시작 날짜나 시간                 TTY       프로세스가 실행된 터미널의 종류와 번호                 TIME       프로세스 실행 시간                 CMD       실행되고 있는 프로그램의 이름(명령)                             STAT       Description                 R       Running 실행 중                 S       Sleep 상태 (인터럽트가 가능한 대기)                 s       세션 리더 프로세스                 T       stopped 상태 (작업 제어에 의해 정지)                 Z       Zombie 상태(defunct)                 STIME       프로세스의 시작 날짜나 시간                 +       포 그라운드 프로세스 그룹                 l(소문자 L)       멀티 스레드                          항목       Description                 USER       사용자 계정 이름                 %CPU       CPU 사용량을 퍼센트로 표시                 %MEM       물리적 메모리 사용량을 퍼센트로 표시                 VSZ       사용하고 있는 가상 메모리의 크기(KB)                 RSS       사용하고 있는 물리 메모리 크기(KB)                 START       프로세스 시작 시간              프로세스 종료하기  kill 명령을 이용해 프로세스 종료   $ kill [시그널 번호] [시그널 보낼 PID]                  시그널 번호       Description                 -2       인터럽트 시그널(Ctrl + C)                 -9       프로세스 강제 종료 시그널                 -15       프로세스가 관련된 파일 정리하고 프로세스 종료 시그널. 종료되지 않는 프로세스가 있을 수 있다.           pkill 이용해 프로세스 이름으로 종료   $ pkill [시그널 번호] [시그널 보낼 프로세스 이름]   top   top: 현재 실행 중인 프로세스 정보 주기적 출력   top의 출력정보                  항목       의미                 PID       프로세스 ID                 USER       사용자 계정(owner)                 PR       우선 순위                 NI       Nice 값                 VIRT       프로세스가 사용하는 가상 메모리 크기                 RES       프로세스가 사용하는 메모리 크기                 SHR       프로세스가 사용하는 공유 메모리 크기                 %CPU       CPU 사용량                 %MEM       메모리 사용량(%)                 TIME+       CPU 누적 이용 시간                 COMMAND       명령 이름                             top의 내부 명령       의미                 enter키, space bar       갱신                 h, ?       도움말 화면 출력                 k       프로세스를 종료하는데, 종료할 PID 물어봄                 n       출력할 프로세스 개수를 바꾼다.                 u       User(사용자)로 정렬하여 출력                 M       사용하는 메모리의 크기에 따라 정렬하여 출력                 p       CPU 사용량에 따라 정렬하여 출력                 q       top 명령 종료           jobs     현재 실행 중인 백그라운드 작업을 보여준다.   $ jobs [%작업번호]  %작업번호 \t%번호 : 해당 번호의 작업 정보를 출력한다. \t%+ : 작업 순서가 +인 작업 정보를 출력한다. \t%- : 작업 순서가 -인 작업 정보를 출력한다.      사용 예                     항목       예       의미                 작업 번호       [1]       작업 번호로서 백그라운드로 실행할 때마다 순차적으로 증가한다. [1], [2], [3]…                 작업 순서       +       작업 순서를 나타낸다. +: 가장 최근에 접근한 작업 -: + 작업 보다 바로 전에 접근한 작업 공백: 그 외의 작업                 상태       실행중       작업 상태 Running: 현재 실행 중 Done: 완료 됨, 작업이 정상적으로 종료된다. Terminated: 종료 됨, 작업이 비정상적으로 종료된다. Stopped: 작업이 잠시 중단된다.           작업 전환하기                  작업 전환 명령       의미                 Ctrl + z or stop [%작업번호]       포 그라운드 작업을 중지(종료가 아니라 잠시 중단!!)                 bg [%작업번호]       작업 번호가 지시하는 작업을 백 그라운드로 전환                 fg [%작업번호]       작업 번호가 지시하는 작업을 포 그라운드로 전환           nohup: 로그아웃 후에도 백그라운드 작업 계속 실행     로그아웃한 다음에도 작업이 완료될 때까지 백그라운드 작업 실행한다.   $ nohup 명령&amp;     nohup로 실행한 명령은 반드시 백그라운드로 실행해야 한다.  ","categories": ["process"],
        "tags": [],
        "url": "https://markyang920413.github.io//process/system_programming-process-process/",
        "teaser": null
      },{
        "title": "리눅스 파일 시스템 종류, 지원하는 파일 시스템 확인,스왑 파티션 관리",
        "excerpt":"리눅스 파일 시스템     ext(ext1), Extended File System, extfs            1992년 4월 리눅스 0.96c 발표       파일 시스템 최대 크기: 2GB       파일 이름 길이: 255Byte           ext2            1993년 1월 발표       리눅스 커널 2.6.17이전 파일 시스템 최대 크기: 2TB       현재 파일 시스템 최대 크기: 32TB       현재도 부팅 가능한 USB flash, SSD 사용           ext3            2001년 11월 리눅스 2.4.15에 추가       ext2 파일을 별도 변경없이 이식가능       2~32TB       journaling: 데이터의 복구 기능강화                    디스크 기록 전 먼저 저널에 수정 사항 기록           기록 전에 갑자기 전원 나가거나 충돌 시, 이 저널의 기록을 보고 재빨리 복구                       단점                    inode 동적 할당이나 다양한 블록 크기와 같은 최신 파일 시스템 기능이 부족           온라인 조각 모음 기능이 없다.                           ext4            2008년 12월 25일 리눅스 커널 2.6.28에 포함되어 공개       1EB이상의 볼륨과 16TB 이상의 파일 지원, ext2, ext3 호환                 다른 기타 파일 시스템                  파일 시스템       기능                 msdos       MS-DOS 파티션을 사용하기 위한 파일 시스템                 iso9660       CD-ROM, DVD의 표준 파일 시스템, 읽기 전용으로 사용                 nfs       Network File System으로 원격 서버의 디스크를 연결할 때 사용                 ufs       Unix File System으로 유닉스의 표준 파일 시스템                 vfat       윈도 95, 98, NT를 지원하기 위한 파일 시스템                 hpfs       HPFS를 지원하기 위한 파일 시스템                 ntfs       윈도의 NTFS를 지원하기 위한 파일 시스템                 sysv       유닉스 시스템 V를 지원하기 위한 파일 시스템                 hfs       맥의 hfs 파일 시스템을 지원하기 위한 파일 시스템                  특수 용도의 가상 파일 시스템            디스크가 아니라 메모리에서 생성되어 사용하는 가상 파일 시스템                    생겼다 없어졌다.                                          파일시스템       기능                 swap       스왑영역을 관리하기 위한 스왑 파일 시스템                 tmpfs       Temporary File System으로 메모리에 임시 파일저장 위한 파일 시스템 재부팅 시 기존 내용 없어진다. /run                 proc       커널의 현재 상태를 나타내는 파일 가지고 있음 proc 파일 시스템 /proc                 ramfs       램 디스크를 지원하는 파일 시스템                 rootfs       / 루트 파일 시스템           시스템 지원 파일 시스템 확인     /proc/filesystems 파일 내용에서 현재 커널이 지원하는 파일 시스템 종류 알려줌              nodev은 해당 파일 시스템이 블록 장치(예: 디스크)에 연결되어 있지 않다. = 가상 파일 시스템           스왑 파티션 관리     스왑 파티션: 스왑으로 쓰기위한 디스크의 파티션을 일부 스왑 파티션으로 둠   현재 스왑 영역 확인   $ swapon -s     새로운 디스크 파티션을 스왑 영역으로 추가     fdisk 명령으로 디스크에 스왑 파티션을 생성한다.     $ sudo fdisk /dev/sdd           mkswap 명령으로 스왑 파티션을 포맷하여 스왑 파일 시스템을 생성한다.     $ sudo mkswap /dev/sdd1           스왑 파티션을 활성화한다.     $ sudo swapon /dev/sdd1           스왑 영역이 추가되었는지 확인     $ swapon -s Filename\tType\t\tSize\t\tUsed\t\tPriority /dev/sda5\tpartition\t1046524\t\t7284\t\t-1 /dev/sdd1\tpartition\t307196\t\t0\t\t-2           재부팅 시에도 새 스왑 영역을 활성화하려면 /etc/fstab 파일에 정보를 추가한다.     /dev/sdd1 swap swap defaults 0 0           기존 파티션에 스왑 파일 추가하기     생성할 스왑 파일의 크기를 정한 후, 1024 X 블록 개수를 산정한다.            128MB = 1024 x 131,072           빈 파일을 dd 명령으로 생성한다. count 다음에는 위에서 계산한 블록 개수를 지정한다.     $ sudo dd if=/dev/zero of=/swapfile bs=1024 count=131072           mkswap 명령으로 위에서 생성한 파일을 스왑 파일로 만든다.     $ sudo mkswap /swapfile           스왑 파일을 활성화한다.     $ sudo swapon /swapfile           스왑 파일이 추가되어있는지 확인한다.     $ swapon -s Filename\tType\t\tSize\t\tUsed\t\tPriority /dev/sda5\tpartition\t1046524\t\t11520\t\t-1 /dev/sdd1\tpartition\t307196\t\t0\t\t-2 /swapfile\tfile\t\t131068\t\t0\t\t-3           재부팅 시에도 새 스왑 영역을 활성화하려면 /etc/fstab 파일에 정보를 추가한다.     /swapfile swap swap defaults 0 0          ","categories": ["linux-filesystem"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-filesystem/linux-linux_filesystem-filesystem/",
        "teaser": null
      },{
        "title": "리눅스 파일 시스템 구조, inode, mount 명령, fdisk로 파티션 생성, mkfs mke2fs 파일 시스템 생성",
        "excerpt":"리눅스 파일 시스템 구조     파일은 inode로 관리한다.   디렉터리는 단순히 파일의 목록을 가지고 있는 파일일 뿐이다.        특수 파일을 통해 장치에 접근할 수 있다.       ext4 파일 시스템의 구조            ext4 파일 시스템은 효율적으로 디스크를 사용하기 위해 저장 장치를 논리적인 블록의 집합(블록 그룹)으로 구분한다.       일반적으로 블록은 4KB이고 실제 크기는 시스템의 설정에 따라 달라질 수 있다.               블록 그룹 0: 파일 시스템의 첫 번째 블록 그룹으로 특별하게 그룹 0 패딩과 수퍼블록, 그룹 디스크립터를 가지고 있다.            그룹 0 패딩: 블록 그룹 0의 첫 1024Byte는 특별한 용도로 사용, x86 부트 섹터와 부가 정보 저장       수퍼블록: 파일 시스템에 대한 다양한 정보가 저장된다.                    전체 inode 개수, 할당되지 않은 블록(free block) 개수, 첫 번째 데이터 블록의 주소, 그룹당 블록의 개수, 파일 시스템의 생태, 전체 블록의 개수, 할당되지 않은 inode(free inode)개수, 블록의 크기, 마운트 시간,  그룹 디스크립터의 크기           수퍼 블록에 문제가 생길 경우 전체 파일 시스템을 사용할 수 없게된다. 따라서 수퍼 블록을 다른 블록 그룹에 복사하고, 블록 그룹 0의 수퍼블록을 읽을 수 없는 경우 복사본을 사용하여 복구한다.                       그룹 디스크립터                    블록 비트맵의 주소, inode 비트맵의 주소, inode 테이블의 주소, 할당되지 않은 블록의 개수, 할당되지 않은 inode의 개수, 디렉터리의 개수, 블록 비트맵, inode 비트맵 체크섬           이 것도 copy되어 블록 그룹0이 문제가 있을 때 복구하는 데 사용된다.                       GDT 예약 블록                    그룹 디스크립터의 확장을 위한 예비공간                       데이터 블록 비트맵                    블록 그룹에 포함된 데이터 블록의 사용 여부 확인하는데 사용됨                       inode 비트맵                    inode 테이블의 항목(inode)가 사용 중인지를 표시한다.           비트맵에서 각 데이터 블록과 inode 테이블 항목은 1bit로 표시한다.                       inode 테이블                    inode에 파일 정보를 저장한다.                       데이터 블록                    실제 데이터가 저장된다.           일반적인 파일: 데이터 블록에 실제 파일 내용 저장           디렉터리: 해당 디렉터리에 있는 파일이나 서브 디렉터리의 이름과 inode를 저장한다.                                블록 그룹 a: 그룹 0 패딩이 없지만 수퍼블록과 그룹 디스크립터에 대한 복사본을 가지고 있다.   블록 그룹 b: 데이터 블록 비트맵 ~ 데이터 블록 copy본   inode 구조       inode는 파일 정보 저장 부분, 데이터 블록(파일 내용 실제 저장) 주소 저장 부분 나뉨   데이터 블록 주소 저장            직접 블록(direct block): 데이터 블록에 대한 주소를 ‘직접 가지고 있음’       간접 블록(indirect block): 데이터 블록에 대한 주소를 가지고 있는 블록에 대한 주소를 저장한다.       이중 간접 블록(double indirect block)       데이터 블록의 크기는 시스템 설정에 따라 1KB ~ 8KB까지 정의           파일 시스템과 디렉터리 계층 구조        한 파일 시스템으로 구성하기        여러 파일 시스템으로 구성하기            파일 시스템1: / 디렉터리에 연결       파일 시스템2: /usr 디렉터리에 연결       파일 시스템3: /home 디렉터리에 연결       윈도우에서 파티션 C, D로 나누는 것과 유사           파일 시스템 마운트     파일 시스템이 디렉터리 계층 구조와 연결되지 않으면 사용자가 해당 파일 시스템에 접근할 수 없다.        파일 시스템을 디렉터리 계층 구조의 특정 디렉터리와 연결하는 것을 마운트라고 한다.       마운트 포인트            디렉터리 계층 구조에서 파일 시스템이 연결되는 디렉터리를 마운트 포인트라고 한다.           파일 시스템 마운트 설정 파일            리눅스에서 자동으로 파일 시스템 마운트 하려면 /etc/fstab 파일에 설정해야한다.           /etc/fstab 파일의 구조            /etc/fstab 파일은 아래와 같이 여섯 항목으로 구성되어 있다.                    장치명           마운트 포인트           파일 시스템의 종류           옵션           덤프 관련 설정           파일 점검 옵션                                장치명            /etc/fstab 파일의 첫 번째 항목에는 파일 시스템 장치명을 설정한다.       예를들어 /dev/hda1, /dev/sda1과 같이 특정 디스크를 지정하는 것이다.       UUID(Universally unique identifier), 로컬 시스템과 다른 시스템에서 파일 시스템을 유일하게 구분해주는 128비트 숫자                    UUID는 시스템의 HW 정보와 시간 정보를 조합하여 랜덤으로 생성된다.           디스크가 추가될 때 부트 로더를 가지고 있는 부트 장치의 이름이 바뀌는 것을 방지하기 위해 사용된다.           UUID로 지정된 장치는 /dev/disk/by-uuid 디렉터리에서 찾을 수 있다.               $ ls -l /dev/disk/by-uuid   합계 0   lrwxrwxrwx\t1\troot\troot\t10\t2월 22\t10:30\t0c662594-1f44-4da5-a063-fe4da3219ad1 -&gt; ../../sda5   lrwxrwxrwx\t1\troot\troot\t10\t2월 22\t10:30\t4c270aab-6780-4f53-87a9-b8824b6d8b50 -&gt; ../../sda1                          UUID로 지정한 부트 장치가 /dev/sda1 장치의 심볼릭 링크임을 알 수 있다. (/는 /dev/sda1의 심볼릭 링크)                                       마운트 포인트            어디에 마운트 시킬 것인가?           파일 시스템의 종류            ext2, ext3, ext4외에 지원 파일 시스템 사용 가능           옵션            파일 시스템의 속성 지정                                      속성           의미                             defaults           일반적인 파일 시스템에서 지정하는 속성. rw, nouser, auto, exec, suid 속성을 모두 포함한다.                             auto           부팅 시 자동으로 마운트 된다.                             exec           실행 파일이 실행되는 것을 허용한다.                             suid           setuid, setgid의 사용을 허용한다.                             ro           읽기 전용 파일 시스템                             rw           읽기, 쓰기가 가능한 파일 시스템                             user           일반 사용자도 마운트가 가능하다.                             nouser           일반 사용자의 마운트가 불가능하다. root 계정만 마운트할 수 있다.                             noauto           부팅 시 자동으로 마운트하지 않는다.                             noexec           실행 파일이 실행되는 것을 허용하지 않는다.                             nosuid           setuid, setgid의 사용을 금한다.                             usrquota           사용자별로 디스크 쿼터 설정이 가능하다.                             grpquota           그룹별로 디스크 쿼터 설정이 가능하다.                           errors=remount-ro는 오류 발생 시, 읽기 전용으로 다시 마운트해라       덤프 관련 설정            0/1 을 설정한다.       0: dump 명령으로 파일 시스템의 내용이 덤프되지 않는 파일 시스템       1: 데이터 백업 등을 위해 dump명령의 사용이 가능한 파일 시스템           파일 점검 옵션            0/1/2 지정한다.       0: 부팅 시, fsck 명령으로 파일 시스템을 점검하지 않도록 하는 설정       1: 부팅 시, fsck 명령으로 루트 파일 시스템 점검       2: 부팅 시, fsck 명령으로 루트 파일 시스템 이외의 파일 시스템 점검           여기 옵션이 1이므로, 루트 파일 시스템으로 부팅할 때 파일 시스템을 점검해야함       mount: 마운트 명령         mount 명령만 사용하는 경우            현재 마운트되어 있는 정보가 출력된다.           /etc/mtab 파일 내용과 동일하다.                    현재 시스템에 마운트된 파일 시스템에 대한 정보가 저장되어 있다.           /proc/mounts에 대한 심볼릭 링크로서, 읽기 전용 파일이다.           여기도 /etc/fstab 처럼 구조로 이루어져있다.           &lt;장치명&gt; &lt;마운트 포인트&gt; &lt;파일 시스템 종류&gt; &lt;마운트 옵션&gt; &lt;사용하지 않는 항목 두개 0 0&gt;                            마지막 사용하지 않는 항목 두 개는 /etc/fstab과 호환성을 위해 추가한 것                                                      mount 명령으로 장치를 연결하는 방법     $ mount /dev/sdb1 /mnt                 /dev/sdb 장치이고 1이 파티션 번호       /mnt 가 장치의 마운트 포인트                다양한 mount 명령의 예                                  장치           mount 명령                             ext2           mount -t ext2 /dev/sdb1 /mnt                             ext3           mount -t ext3 /dev/sdb1 /mnt                             ext4           mount -t ext4 /dev/sdb1 /mnt mount /dev/sdb1 /mnt                             CD-ROM           mount -t iso9660 /dev/cdrom /mnt/cdrom                             윈도 디스크           mount -t vfat /dev/hdc /mnt                             USB 메모리           mount /dev/sdc1 /mnt (리눅스용 USB 메모리) mount -t vfat /dev/sdc1 /mnt(윈도우용 USB 메모리)                             읽기 전용 마운트           mount -r /dev/sdb1 /mnt                             읽기/쓰기 마운트           mount -w /dev/sdb1 /mnt                             원격 디스크 마운트           mount -t nfs 서버주소:/NFA 서버측 디렉터리 /mnt                           USB 메모리 연결하기      기존에 사용하던 USB 메모리면 자동으로 디렉터리에 마운트될 수 있다. mount명령을 실행해보면 마지막에 장치가 추가되어 있음을 확인할 수 있다.     $ mount (생략) /dev/sdb1 on /media/user1/5255-B26B type vfat (rw,nosuid,nodev,uid=1000,gid=1000,shortname=mixed,dmask=0077,utf8=1,showexec,flush,uhelper=udisk2)           리눅스에서 사용하는 USB 메모리가 아니라면, 마운트 해제하고 파일 시스템 생성 작업해야한다.   마운트 해제     USB 메모리 파티션 생성      fdisk -l(소문자 L)            fdisk: 리눅스 시스템에 연결된 저장 장치의 장치명 확인                    fdisk 명령은 하드디스크의 파티션을 나눌 때 사용하는 것으로, root 권한 필요                             $ sudo fdisk -l   (생략)   Disk /dev/sdb: 2056 MB, 2056257536 bytes   16 heads, 32 sectors/track, 7844 cylinders, total 4016128 sectors   Units = sectors of 1 * 512 = 512 bytes   Sector size (logical/physical): 512 bytes / 512 bytes   I/O size (minimum/optimal): 512 bytes / 512 bytes   Disk identifier: 0x4595dc7f \t   Device Boot\tStart\tEnd\tBlocks\tId\tSystem   /dev/sdb1\t32\t4016127\t2008048\t6\tFAT16                 USB 장치 명: /dev/sdb1 확인           fdisk 로 새로운 파티션 생성       $ sudo fdisk /dev/sdb    Command (m for help):\t# 여기서 fdisk는 커맨드를 기다린다.       a\ttoggle a bootable flag       b\tedit bsd disklabel       c\ttoggle the dos compatibility flag       d\tlist known partition types       l\tlist known partition types       m\tprint this menu       n\tadd a new partition       o\tcreate a new empty DOS partition table       p\tprint the partition table       q\tquit without saving changes       s\tcreate a new empty Sun disklabel       t\tchange a partition's system id       u\tchange display/entry units       v\tverify the partition table       w\twrite table to disk and exit       x\textra functionality (experts only)    Command (m for help):           새로운 파티션을 생성하려는 것이므로 n을 입력한다.            n을 입력하면 파티션을 기본(primary) 파티션으로 할 것인지, 확장(extended) 파티션으로 할 것인지를 선택한다.       기본 값은 기본(p) 파티션이다.             Command (m for help): n   Partition type:       p\tprimary (1 primary, 0 extended, 3 free)       e\textended   Select (default p):           다음으로 생성할 파티션 번호를 지정한다.            아래와 같이 1번을 선택했는데 이미 사용중이라면, USB 메모리가 새것이 아니라 이미 파티션이 생성되어 있다는 뜻이므로 삭제 후 다시 생성해야한다.             Select (default p): p   Partition number (1-4, default 2): 1   Partition 1 is already defined. Delete it before re-adding it.    Command (m for help):                d를 선택하면 파티션 삭제         Command (m for help): d   Selected partition 1    Command (m for help):           다시 n 입력하여 새로운 파티션을 생성한다.            파티션 번호: 1       시작 섹터와 마지막 섹터를 지정한다. 특별한 이유가 없는 한 기본 값 사용             Command (m for help): n   Partition type:       p\tprimary (1 primary, 0 extended, 3 free)       e\textended   Select (default p):\t# 걍 엔터   Using default response p   Partition number (1-4, default 1):\t# 걍 엔터   Using default value 1   First sector (2048-4016127, default 2048):   Using default value 2048   Last sector, +sectors or +sizeK,M,G (2048-4016127, default 4016127):   Using default value 4016127    Command (m for help):                p명령을 사용하여 파티션이 제대로 설정되었는지 확인         Command (m for help): p \t   Disk /dev/sdb: 2056 MB, 205625736 bytes   16 heads, 32 sectors/track, 7844 cylinders, total 4016128 sectors   Units = sectors of 1 * 512 = 512 bytes   Sector size (logical/physical): 512 bytes / 512 bytes   I/O size (minimum/optimal): 512 bytes / 512 bytes   Disk identifier: 0x4595dc7f    Device Boot\tStart\tEnd\tBlocks\tId\tSystem   /dev/sdb1\t2048\t4016127\t2007040\t83\tLinux    Command (m for help)           w를 입력하여 파티션 설정 정보를 파티션 테이블에 기록한다.            파티션 테이블에 기록되면 이전에 있던 정보는 없어진다.       이제 USB메모리에 파티션이 생성되었다.             Command (m for help): w   The partition table has been altered!    Calling ioctl() to re-read partition table.    WARNING: Re-reading the partition table failed with error 16: 장치나 자원이 동작 중.   The kernel still uses the old table. The new table will be used at   the next reboot or after you run partprobe(8) or kpartx(8)   Syncing disks.           생성한 파티션을 포맷하여 파일 시스템 생성            파티션을 만든 후에 바로 USB메모리에 파일을 저장할 수 없다.       먼저 포맷을 통해 파일 시스템을 생성해야 한다.       파일 시스템을 생성하는 데는 mke2fs 명령을 사용             $ sudo mke2fs -t ext4 /dev/sdb1   mke2fs 1.42.8 (20-Jun-2013)   Filesystem label=   OS type: Linux   .....(생략)                마운트 한다.         $ sudo mount /dev/sdb1 /mnt \t# 마운트!    $ mount\t\t\t# 마운트 확인   ..(생략)..   /dev/sdb1 on /mnt type ext4 (rw)                장치 해제              CD-ROM 연결      CD-ROM 장치를 USB로 연결하여 리눅스 시스템에 인식시킨다.   CD-ROM을 마운트한다. CD-ROM의 장치명은 기본적으로 /dev/cdrom을 사용한다.        파일 시스템 종류는 iso9660이며, 기본적으로 읽기 전용으로 마운트된다.         $ sudo mount -t iso9660 /dev/cdrom /mnt   mount: block device /dev/sr0 is write-protected, mounting read-only   $ ls -l /dev/cdrom   lrwxrwxrwx\t1\troot\troot\t3\t2월 22 10:30 /dev/cdrom -&gt; sr0           메시지에 /sr0로 표시 된 것은 /dev/cdrom이 /sr0에 대한 심벌릭 링크   디스크 추가 설치     HDD를 추가 장착 해보자!        새 디스크 장착 -&gt; 디스크 파티션 나눔 -&gt; 포맷 -&gt; 마운트       디바이스 인터페이스            IDE, SATA, SCSI                    SCSI: 서버급 장치                       현재 가상머신에서 현재 디스크는 SCSI 0번 컨트롤러의 첫 번째 슬롯에 연결 (SCSI 0:0), CD-ROM은 SATA에 연결          여기서 SCSI 디스크 세개 추가              디스크 파티션 나누기      새로운 디스크 장착이 완료되었으므로 이제 디스크의 파티션을 생성해야한다.            디스크 하나를 하나의 파티션으로 사용할 수도 있고, 여러 개의 파티션으로 나눌 수도 있다.           디스크 장치 이름      IDE 컨트롤러: /dev/hdXXX   SCSI/SATA : /dev/sdXXX            최근 추세는 구분 없이 /dev/sdXXX 로 넣는 추세           sda(첫 번째), sdb(두 번째) …            sda0 첫 번째 디스크의 첫째 파티션       sda1 첫 번째 디스크의 두번째 파티션           fdisk명령  fdisk: 디스크의 파티션 생성   $ fdisk [option] 장치명  option: \t-b &lt;크기&gt;\t: 섹터 크기를 지정한다(512, 1024, 2048, 4096). \t-l\t\t: 파티션 테이블을 출력한다.  사용 예: \tfdisk /dev/sdb \tfdisk -l   fdisk 내부 명령                  내부 명령       기능                 a       부팅 파티션 설정                 b       BSD 디스크 라벨을 편집                 c       도스 호환성 설정                 d       파티션 삭제                 l(소문자 L)       사용 가능한 파티션의 종류 출력                 m       도움말을 출력                 n       새로운 파티션 추가                 o       새로운 빈 DOS 파티션 생성                 p       파티션 테이블 출력                 q       작업 내용을 저장하지 않고 출력한다.                 s       새로운 빈 Sun 디스크 라벨을 출력한다.                 t       파티션의 시스템 ID를 변경한다(파일 시스템 종류 변경).                 u       항목 정보를 변경/출력 한다.                 v       파티션 테이블을 검사한다.                 w       파티션 정보를 디스크에 저장하고 종료한다.                 x       실린더 갯수 변경 등 정문가를 위한 부가적 기능이다.           fdisk로 파티션 정보보기      fdisk -l(소문자 L)을 사용하면 전체 디스크의 파티션 정보를 볼 수 있다.            현재 시스템에 장착된 디스크의 정보를 확인하면, 아래와 같다.               fdisk로 파티션 나누기      fdisk명령 실행한다.   $ sudo fdisk /dev/sdb\t\t# sdb 디바이스를 파티션 나눌 것이다. Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabel Building a new DOS disklabel with disk identifier 0x2fa4c807. Changes will remain in memory only, until you decide to write them. After that, of course, the previous content won't be recoverable.  Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)  Command (m for help):      새로운 파티션을 생성한다. 새로운 파티션을 생성하기 위해서는 n을 입력해야 한다.  n을 입력하면 파티션의 종류를 선택하는 메뉴가 출력된다.   Command (m for help): n Partition type: \tp\tprimay (0 primary, 0 extended, 4 free) \te\textended Select (default p):      파티션의 종류를 선택한다. 파티션은 기본 파티션과 확장 파티션이 있는데,   기본 파티션을 선택하면 파티션의 번호를 선택하는 메뉴가 출력된다.   Select (default p): p Partition number (1-4, default 1):      첫 번째 파티션이므로 1을 선택한다.  파티션 번호를 입력하면 용량 설정하기 위한 메뉴가 출력된다.   Partition number (1-4, default 1): 1 First sector (2048-2097151, default 2048):      파티션의 크기를 설정한다.  시작 섹터는 기본 값을 사용하고, 마지막 섹터를 설정하는 메뉴에서는 크기를 500MB로 할 것이므로 +500M를 입력한다.  이제 파티션의 정보가 설정되었다.   First sector (2048-2097151, default 2048): Using default value 2048 Last sector, +sectors or +sizeK,M,G (2048-2097151, default 2097151): +500M  Command (m for help):      파티션 설정 정보를 확인한다. p를 입력하면 현재 설정된 파티션의 정보가 출력되는데, /dev/sdb1이 설정되었음을 알 수 있다.   Command (m for help): p  Disk /dev/sdb: 1073MB, 10737741824 bytes 255 heads, 63 sectors/track, 130 cylinders, total 2097152 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk identifier: 0x2fa4c807  Device Boot\tStart\tEnd\tBlocks\tId\tSystem /dev/sdb1\t2048\t1026047\t512000\t83\tLinux  Command (m for help):      n을 선택하면 두 번째 파티션을 생성한다.  1번 파티션과 동일하게 기본 파티션(p), 파티션 번호는 2, 용량은 +500M으로 한다.   Command (m for help): n Partition type: \tp\tprimary (1 primary, 0 extended, 3 free) \te\textended Select (default p): p Partition number (1-4, default 2): Using default value 2 First sector (1026048-2097151, default 1026048): Using default value 1026048 Last sector, +sectors or +sizeK,M,G (1026048-2097151, default 2097151): +500M  Command (m for help):      파티션 설정 정보를 확인한다.  p를 입력하면 현재 설정된 파티션의 정보가 출력되는데 /dev/sdb1과 /dev/sdb2가 모두 설정 되었음을 알 수 있다).   Command (m for help): p  Disk /dev/sdb: 1073MB, 10737741824 bytes 255 heads, 63 sectors/track, 130 cylinders, total 2097152 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk identifier: 0x2fa4c807  Device Boot\tStart\tEnd\tBlocks\tId\tSystem /dev/sdb1\t2048\t1026047\t512000\t83\tLinux /dev/sdb2\t1026048\t2050047\t512000\t83\tLinux  Command (m for help):      w를 입력하면 파티션 설정 정보를 디스크에 기록하고 fdisk를 종료한다.   Command (m for help): w The partition table has been altered!  Calling ioctl() to re-read partition table. Syncing disk.   디스크 파티션 작업이 끝나면 파티션에 파일 시스템을 생성해야한다.   mkfs, mke2fs 파일 시스템 생성     리눅스에서 파일 시스템을 생성할 때 사용하는 명령은 mkfs와 mke2fs가 있다.   $ mkfs [option] 장치명  option: \t-t &lt;종류&gt;\t: 파일 시스템의 종류를 지정한다(기본 값은 ext2).  사용 예: \tmkfs /dev/sdb1 \tmkfs -t ext4 /dev/sdb1     mkfs : 리눅스 파일 시스템을 만든다.   $ mke2fs [option] 장치명  option: \t-t &lt;종류&gt;\t\t: 파일 시스템의 종류를 지정한다. 기본 값은 ext2이다. \t-b &lt;블록 크기&gt;\t\t: 블록 크기를 바이트 수로 지정한다. \t-c\t\t\t: 배드 블록을 체크한다. \t-f &lt;프래그먼트 크기&gt;\t: 프래그먼트 크기를 바이트 수로 지정한다. \t-i &lt;inode당 바이트 수&gt;\t: inode당 바이트 수를 지정한다. 기본 값은 4,096byte. \t-m &lt;예약 블록 퍼센트&gt;\t: 슈퍼유저에게 예약해둘 블록의 퍼센트를 지정한다. 기본 값은 5이다.  사용 예: \tmke2fs /dev/sdb1 \tmke2fs -t ext4 /dev/sdb1     mke2fs : 리눅스 개정판 확장 파일 시스템(ext2, ext3, ext4)를 만든다.  mke2fs명령은 별도의 설정 파일이 있다. 이는 /etc/mke2fs.conf 파일로 파일 시스템의 종류에 따라 기본적으로 설정할 값들을 정의하고 있다.   $ cat /etc/mke2fs.conf [defaults]         base_features = sparse_super,large_file,filetype,resize_inode,dir_index,ext_attr         default_mntopts = acl,user_xattr         enable_periodic_fsck = 0         blocksize = 4096         inode_size = 256         inode_ratio = 16384  [fs_types]         ext3 = {                 features = has_journal         }         ext4 = {                 features = has_journal,extent,huge_file,flex_bg,metadata_csum,64bit,dir_nlink,extra_isize                 inode_size = 256         }         small = {                 inode_size = 128                 inode_ratio = 4096         }         floppy = {                 inode_size = 128                 inode_ratio = 8192         }         big = {                 inode_ratio = 32768         }         huge = {                 inode_ratio = 65536         }         news = {                 inode_ratio = 4096         }         largefile = {                 inode_ratio = 1048576                 blocksize = -1         }         largefile4 = {                 inode_ratio = 4194304                 blocksize = -1         }         hurd = {              blocksize = 4096              inode_size = 128         }  [options]         fname_encoding = utf8      mkfs, mke2fs 명령은 /sbin 디렉터리에 있다.            여기서 mkfs.ext3 명령은 mkfs -t ext3 명령과 동일하다.           $ ls /sbin/mk* /sbin/mkdosfs      /sbin/mkfs.ext2   /sbin/mkfs.minix  /sbin/mkhomedir_helper  /sbin/mkswap /sbin/mke2fs       /sbin/mkfs.ext3   /sbin/mkfs.msdos  /sbin/mkinitramfs /sbin/mkfs         /sbin/mkfs.ext4   /sbin/mkfs.ntfs   /sbin/mklost+found /sbin/mkfs.bfs     /sbin/mkfs.fat    /sbin/mkfs.ubifs  /sbin/mkntfs /sbin/mkfs.cramfs  /sbin/mkfs.jffs2  /sbin/mkfs.vfat   /sbin/mksmbpasswd   mkfs 명령으로 파일 시스템 생성      mkfs 명령으로 /dev/sdb 파티션에 파일 시스템을 생성한다.        mkfs명령으로 파일 시스템을 만들 때 출력되는 정보를 볼 수있다.   블록의 크기, inode의 개수, 블록의 개수, 블록 그룹의 개수, 그룹당 블록과 inode의 개수, 수퍼블록의 백업 위치 등 정보   이제 mount만 하면 바로 사용할 수 있다.      mkfs.ext3 명령을 /dev/sdb2 파티션에 ext3 파일 시스템을 생성한다.            mkfs.ext3 = mkfs -t ext3           $ sudo mkfs.ext3 /dev/sdb2 mke2fs 1.42.8 (20-Jun-2013) Filesystem label= OS type: Linux Block size=1024 (log=0) Fragment size=1024 (log=0) Stride=0 blocks, Stripe width=0 blocks 128016 inodes, 512000 blocks 25600 blocks (5.00%) reserved for the super user First data block=1 Maximum filesystem blocks=67633152 63 block groups 8192 blocks per group, 8192 fragments per group 2032 inodes per group Superblock backups stored on blocks: \t8193, 24577, 40961, 57345, 73729, 204801, 221185, 401409  Allocating group tables: done Writing inode tables: done Creating journal (8192 blocks): done Writing superblocks and filesystem accounting information: done  $     위 메시지를 살펴보면, ext2와 ext3의 차이가 저널링기능임을 살펴볼 수 있다.            ext3 파일 시스템을 생성하는 과정의 끝부분에 저널을 저장하는 부분을 별도로 생성한다.           mke2fs 명령으로 파일 시스템 생성하기     mke2fs 명령으로 /dev/sdc 파티션에 ext3 파일 시스템을 생성해보자.   $ sudo mke2fs -t ext3 /dev/sdc1 mke2fs 1.42.8 (20-Jun-2013) Filesystem label= OS type: Linux Block size=1024 (log=0) Fragment size=1024 (log=0) Stride=0 blocks, Stripe width=0 blocks 128016 inodes, 512000 blocks 25600 blocks (5.00%) reserved for the super user First data block=1 Maximum filesystem blocks=67633152 63 block groups 8192 blocks per gorup, 8192 fragments per group 2032 inodes per group Superblock backups stored on blocks: \t8193, 24577, 40961, 57345, 73729, 204801, 221185, 401409  Allocating group tables: done Writing inode tables: done Creating journal (8192 blocks): done Writing superblocks and filesystem accounting information: done  $      mke2fs 명령으로 /dev/sdc2 파티션에 ext4 파일 시스템을 만든다.            블록 크기를 4096 바이트로 지정한다.           $ sudo mke2fs -t ext4 -b 4096 /dev/sdc2 mke2fs 1.42.8 (20-Jun-2013) Filesystem label= OS type: Linux Block size=4096 (log=2) Fragment size=4096 (log=2) Stride=0 blocks, Stripe width=0 blocks 128000 inodes, 128000 blocks 6400 blocks (5.00%) reserved for the super user First data block=1 Maximum filesystem blocks=1234217728 4 block groups 32768 blocks per gorup, 32768 fragments per group 32000 inodes per group Superblock backups stored on blocks: \t32768, 98304  Allocating group tables: done Writing inode tables: done Creating journal (4096 blocks): done Writing superblocks and filesystem accounting information: done  $   디스크 마운트          파티션 나누기 -&gt; 파일 시스템 생성 -&gt; 디렉터리 계층 구조에 마운트!            마운트 포인트 준비하기       $ sudo mkdir /mnt/hdd1      파일 시스템 마운트하기            /dev/sdb 디스크의 파일 시스템을 마운트 해보자.           $ sudo mount /dev/sdb1 /mnt/hdd1   ","categories": ["linux-filesystem"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-filesystem/linux-linux_filesystem-filesystem_architecture/",
        "teaser": null
      },{
        "title": "시험에서 입출력, STL",
        "excerpt":"scanf(), printf()   특정 자료형 거르기       특정 갯수만큼만 받기    scanf(\"%1d\", &amp;a);     %1d 와 같이 중간에 숫자를 넣은 만큼 입력을 받는다.            12345 입력 시, 1 2 3 4 5 따로 받을 수 있다.           scanf(\"%5s\", str);     %5s 와 같이 string도 중간에 숫자를 넣은 만큼 입력을 받는다.            “hello world” » “%3s” » “hel”           scanf 로 끝까지 받기      scanf의 리턴 값은 성공적으로 입력 받은 인자 개수이다.   파일의 끝까지 받아야 하는 경우     while( scanf(\"%d %d\", &amp;a, &amp;b) == 2);           한줄 입력      scanf(), cin »으로는 한 줄입력 불가!   fgets(s, 100, stdin);\t\"fgets()는 줄 바꿈까지 입력 받음!! 주의!!\" getline(cin, s);   ","categories": ["algorithm"],
        "tags": [],
        "url": "https://markyang920413.github.io//algorithm/algorithm-algorithm-IO_STL/",
        "teaser": null
      },{
        "title": "Time complexity",
        "excerpt":"Time Complexity     O(1): 단순 계산(a+b, 배열 접근 연산)   O(logN): N개를 절반으로 계속 나눔   O(N): 1중 for문   O(NlogN)   O(N2): 2중 for문   O(N3): 3중 for문   O(2N): 크기가 N인 집합의 부분 집합   O(N!): 크기가 N인 순열     대략 1억 = 1초(2000s 컴)     1 초가 걸리는 입력의 크기     O(1)   O(logN)   O(N) = 1억   O(NlogN) = 5백만   O(N2) = 1만   O(N3) = 500   O(2N) = 20 (220 = 1048576)   O(N!) = 10 (10! 단 10개만 넣어도.. 1초)     ","categories": ["algorithm"],
        "tags": [],
        "url": "https://markyang920413.github.io//algorithm/algorithm-algorithm-time_complexity/",
        "teaser": null
      },{
        "title": "M1 Mac 로제타2 설치, 로제타 사용 brew 설치, M1용 jekyll설치",
        "excerpt":"M1 Rosetta2 설치     command line   // 1. 라이센스 동의 필요 $ softwareupdate --install-rosetta  // 2. 라이선스 자동 동의 $ /usr/sbin/softwareupdate --install-rosetta --agree-to-license           응용프로그램 -&gt; Iterm 정보 가져오기 -&gt; 로제타를 사용하여 열기 옵션 활성화            command line       $ arch -x86_64 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"  # ~/.zshrc에 추가 export PATH=/opt/homebrew/bin:/Users/yangdonghyeon/.rbenv/shims:/opt/homebrew/bin:/Users/yangdonghyeon/.rbenv/shims:/opt/homebrew/bin:/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Apple/usr/bin:/opt/homebrew/bin:$PATH  $ alias ibrew='arch -x86_64 /usr/local/bin/brew'      x86_64용으로 파일을 열기 위해선 실행파일 앞에 arch -x86_64를 붙인다.          x86_64용 brew 설치확인   $ ibrew config HOMEBREW_VERSION: 3.0.4 ORIGIN: https://github.com/Homebrew/brew HEAD: ee52b19179d056f3dd2fdf9c52214d3d51dbb9d9 Last commit: 2 days ago Core tap ORIGIN: https://github.com/Homebrew/homebrew-core Core tap HEAD: 6559768c37c501716601f18362d1abf55479fe29 Core tap last commit: 16 minutes ago Core tap branch: master HOMEBREW_PREFIX: /usr/local HOMEBREW_CASK_OPTS: [] HOMEBREW_MAKE_JOBS: 8 Homebrew Ruby: 2.6.3 =&gt; /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/bin/ruby CPU: octa-core 64-bit westmere Clang: 12.0 build 1200 Git: 2.24.3 =&gt; /Library/Developer/CommandLineTools/usr/bin/git Curl: 7.64.1 =&gt; /usr/bin/curl macOS: 11.2.2-x86_64\t\t\t# x86_64 확인 CLT: 12.4.0.0.1.1610135815 Xcode: 12.4 Rosetta 2: true\t\t\t\t# Rosetta 2: true 확인      ibrew로 이제 x86_64용 brew를 실행한다.   M1 Mac용 jekyll 설치   주의! jekyll은 로제타2를 사용한 brew 커맨드를 사용하여 설치해야한다. 따라서, 위 처럼 로제타2 설치를 필요로한다.      specific ruby사용을 위한 rbenv 사용            rbenv 설치           $ ibrew install rbenv ..install complete  # 혹시 brew메세지가 아래 처럼 해라하면 ~/.zshrc에 넣기 export RUBY_CONFIGURE_OPTS=\"--with-openssl-dir=$(brew --prefix openssl@1.1)\"  $ rbenv init  # ~/.zshrc에 추가 eval \"$(rbenv init -)\"  $ rbenv install 2.7.2 $ rbenv global 2.7.2 $ ruby -v ruby 2.7.2p137 (2020-10-01 revision 5445e04352) [x86_64-darwin20]\t# x86_64 확인!!!      jekyll 설치   # 블로그 디렉터리로 가서 $ arch -x86_64 gem install --user-install bundler jekyll $ arch -x86_64 bundle update $ arch -x86_64 bundle install      local hosting   $ arch -x86_64 bundle exec jekyll serve   ","categories": ["mac"],
        "tags": [],
        "url": "https://markyang920413.github.io//mac/m1_rosetta2/",
        "teaser": null
      },{
        "title": "LVM",
        "excerpt":"LVM     LVM은 독립적으로 구성된 디스크 파티션을 하나로 연결하여 한 파티션처럼 사용할 수 있도록 해준다.            PV(physical volume, 물리 볼륨): /dev/sdb1, /dev/sdb2 같은 실제 물리 디스크의 파티션       VG(volume group, 볼륨 그룹): 여러 개의 PV를 그룹으로 묶은 것을 말한다. 예: /dev/sdb1, /dev/sdb2가 GRP1이라는 그룹을 만들 때 GRP1을 VG라고 한다.       LV(logical volume, 논리 볼륨): VG를 다시 적절한 크기의 파티션으로 나눌 때, 각 파티션을 LV라고 함       PE(physical extent): PV가 가진 일정한 블록을 의미       LE(logical extent): LV가 가진 일정한 블록을 의미                    물리 파티션(PV) 세 개를 묶어 VG 하나를 만들고, 다시 LV 두 개로 분리. LV에 파일 시스템 생성 후 마운트   LVM 명령                  구분       기능       명령                 PV       PV 생성       pvcreate [파티션 이름]                 PV       PV 상태 확인       pvscan                 VG       VG 생성       vgcreate [VG 명] [PV 명1] [PV 명2] …                 VG       VG 활성화       vgchange -a y [VG 명]                 VG       VG 비활성화       vgchange -a n [VG 명]                 VG       VG 삭제       vgremove [VG 명]                 VG       VG 정보 확인       vgdisplay -v [VG 명]                 VG       VG에 PV 추가       vgextend [VG 명] [PV 명]                 VG       VG에 PV 삭제       vgreduce [VG 명] [PV 명]                 VG       VG명 변경       vgrename [기존 VG 명] [새로운 VG 명]                 LV       LV 생성       lvcreate -l [PE 수] [VG 명] -n [LV 명]                 LV       LV 삭제       lvremove [LV 명]                 LV       LV 상태 확인       lvscan                 LV       LV 용량 확대       lvextent -l [+PE 수] [LV 명]                 LV       LV 용량 축소       lvextent -l [-PE 수] [LV 명]           LVM 생성하기     기존 파일 시스템을 LVM으로 만드는 과정            /dev/sdb1, /dev/sdb2는 각 500MB인데 이를 LVM으로 1GB 짜리 LV를 생성하여 마운트 해보자.           ","categories": ["linux-filesystem"],
        "tags": [],
        "url": "https://markyang920413.github.io//linux-filesystem/linux-linux_filesystem-LVM/",
        "teaser": null
      }]
